---
layout: page
title:  "Data Structure"
subtitle: "Computer Science of Data Structure"
date:   2021-10-14 11:11:11 +0530
categories: ["CS"]
comments: true
---
## Pointer
👉 자료형과 주소값을 저장하는 변수  
👉 int *ptr = &a; // & ; 주소 연산자 (ampersand)  
👋 포인터 변수 앞 * 붙이면 해당 주소에 저장된 값을 의미  
👋 int a = 3; (가정) // cout << *ptr << endl; // 3 출력  

<br>

## Call-by-Value　VS　Call-by-Reference ✔️
#### - Call-by-Value
👉 함수 호출 시 인자 전달 과정에서 발생  
👉 데이터를 복사하는 과정에서 발생  
#### - Call-by-Reference
👉 전달되는 인자를 레퍼런스로 받으면 데이터의 복사 연산이 필요하지 않음 ∴ 성능 향상  
👉 원본 데이터 변경 막을때는 const  
👋 1. 포인터를 넘겨주는 방식 ; add(&a, &b) // void add(int *a, int *b)  
👋 2. 레퍼런스를 이용하는 방식 ; add(a, b) // void add(int &a, int &b)  

<br>

## 함수 오버로딩 ✔️
👉 동일한 이름을 가진 함수를 중복해서 정의하는 것  
👉 단, 반드시 인자 개수 혹은 타입이 달라야 함  
👉 가능한 이유 : 호출할 함수를 매개변수의 정보까지 참조해서 호출하기 때문  
👉 return 타입만 다를 경우는 error  

<br>

## 오버라이딩 ✔️
👉 상속 받았을 때 부모 클래스의 함수를 사용하지 않고 다른 기능을 실행할 때 함수를 자식클래스에서 같은 이름으로 재정의해서 사용하는 것  

<br>

## 프로그래밍 패러다임
👉 프로그래머에게 프로그래밍의 관점을 갖게하고 코드를 어떻게 작성할 지 결정하는 역할  
### - 명령형 프로그래밍
👉 무엇(What)을 할 것인지를 나타내기보다 어떻게(How) 할 것인지를 설명하는 방식  
#### -- 객체 지향 프로그래밍 ✔️
👉 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 패러다임  
👋 코드 재사용이 용이하며, 유지 보수가 쉬우므로 대형 프로젝트에 적합  
👋 But, 처리속도가 상대적으로 느리므로, 객체가 많으면 용량이 커질 수 있음
#### -- 절차 지향 프로그래밍(절차적 프로그래밍)
👉 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결이 되도록 만드는 프로그래밍 패러다임  
### - 선언형 프로그래밍
👉 어떻게(How) 할 것인지를 나타내기보다 무엇(What)을 할 것인지를 설명하는 방식  
#### -- 함수형 프로그래밍
👉 부수 효과를 없애고 순수 함수를 만들어 모듈화 수준을 높이는 프로그래밍 패러다임  
👉 객체 지향 프로그래밍에서 멤버 변수를 다룸에 있어 예상치 못한 버그가 일어날 수 있기에 이를 보완하기 위해 쓰임  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>