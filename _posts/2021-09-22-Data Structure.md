---
layout: page
title:  "Data Structure"
subtitle: "Computer Science of Data Structure"
date:   2021-10-14 11:11:11 +0530
categories: ["CS"]
comments: true
---
## Pointer
👉 자료형과 주소값을 저장하는 변수  
👉 int *ptr = &a; // & ; 주소 연산자 (ampersand)  
👋 포인터 변수 앞 * 붙이면 해당 주소에 저장된 값을 의미  
👋 int a = 3; (가정) // cout << *ptr << endl; // 3 출력  

<br>

## Call-by-Value 🆚 Call-by-Reference ✔️
#### - Call-by-Value
👉 함수 호출 시 인자 전달 과정에서 발생  
👉 데이터를 복사하는 과정에서 발생  
#### - Call-by-Reference
👉 전달되는 인자를 레퍼런스로 받으면 데이터의 복사 연산이 필요하지 않음 // ∴ 성능 향상  
👉 원본 데이터 변경 막을때는 const  
👋 1. 포인터를 넘겨주는 방식 // add(&a, &b), void add(int *a, int *b)  
👋 2. 레퍼런스를 이용하는 방식 // add(a, b), void add(int &a, int &b)  

<br>

## 함수 오버로딩(Overloading) ✔️
👉 동일한 이름을 가진 함수를 중복해서 정의하는 것  
👉 단, 반드시 인자 개수 혹은 타입이 달라야 함  
👉 가능한 이유 : 호출할 함수를 매개변수의 정보까지 참조해서 호출하기 때문  
👉 return 타입만 다를 경우는 error  

<br>

## 오버라이딩(Overriding) ✔️
👉 상속 받았을 때 부모 클래스의 함수를 사용하지 않고 다른 기능을 실행할 때 함수를 자식클래스에서 같은 이름으로 재정의해서 사용하는 것  

<br>

## 프로그래밍 패러다임
👉 프로그래머에게 프로그래밍의 관점을 갖게하고 코드를 어떻게 작성할 지 결정하는 역할  
### - 명령형 프로그래밍
👉 무엇(What)을 할 것인지를 나타내기보다 어떻게(How) 할 것인지를 설명하는 방식  
#### -> 객체 지향 프로그래밍 ✔️
👉 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 패러다임  
👋 코드 재사용이 용이하며, 유지 보수가 쉬우므로 대형 프로젝트에 적합  
👋 But, 처리속도가 상대적으로 느리므로, 객체가 많으면 용량이 커질 수 있음  
#### -> 절차 지향 프로그래밍(절차적 프로그래밍)
👉 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결이 되도록 만드는 프로그래밍 패러다임  
### - 선언형 프로그래밍
👉 어떻게(How) 할 것인지를 나타내기보다 무엇(What)을 할 것인지를 설명하는 방식  
#### -> 함수형 프로그래밍
👉 부수 효과를 없애고 순수 함수를 만들어 모듈화 수준을 높이는 프로그래밍 패러다임  
👉 객체 지향 프로그래밍에서 멤버 변수를 다룸에 있어 예상치 못한 버그가 일어날 수 있기에 이를 보완하기 위해 쓰임  

<br>

## 제네릭 프로그래밍(Generic Programming)
👉 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두고 재사용성을 높일 수 있는 프로그래밍 방식  
👋 Generic Programming is a style of computer programming in which algorithms are written in terms of types to be specified-later that are then instantiated when needed for specific types provided as parameters  

<br>

## 객체 지향 프로그래밍의 5가지 키워드
👉 클래스/객체, 추상화, 캡슐화, 상속, 다형성  

<br>

## Class
👉 어떠한 객체를 만들기 위해 변수와 메서드를 정의하는 틀  

<br>

## Object 🆚 Instance
#### - Object
👉 소프트웨어 세계에 구현할 대상  
#### - Instance
👉 소프트웨어 세계에 구현된 실체  
👋 An Object is an Instance of a Class  
👋 a = Cookie() // a 객체는 Cookie 클래스의 인스턴스  

<br>

## 데이터 추상화(Data Abstraction)
👉 현실 세계의 사물을 데이터적인 측면과 기능적인 측면으로 모델링하여 시스템 내의 사물로 정의  

<br>

## 다형성(Polymorphism)
👉 보이는 모습은 하나이지만 실질적으로 쓰이는 기능은 여러 가지를 수행 가능하다는 것  
👋 Polymorphism is the provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types  
👋 Overloading, Overriding  

<br>

## 상속(Inheritance)
👉 이미 존재하는 클래스(or 객체)로 부터 기본적인 특성(멤버 함수 및 변수)을 물려받아 새로운 클래스를 작성하는 것  
👋 Inheritance is when an object or class is based on another object or class, using the same implementation  
👋 Inheritance in most class-based object oriented languages is a mechanism in which one object acquires all the properties and behaviors of parent object  

<br>

## 캡슐화(Encapsulation)
👉 관련있는 데이터와 함수를 하나의 단위로 묶는 것  
👋 코드를 재수정없이 재활용할 수 있음  
👉 또한, 객체가 기능을 어떻게 구현했는지 외부에 감추는 것  
👉 즉, 정보 은닉의 의미를 포함하고 있음  

<br>

## 정보 은닉(Information hiding)
👉 객체 내의 데이터 및 함수에 대한 접근 권한을 제어  
👋 객체 안의 데이터가 다른 객체에게 잘못 조작되는 것을 막아줌으로 에러를 방지  
👋 public, private, protected  

<br>

## 접근 제한자 getter, setter 쓰는 이유
👋 getter, setter는 정보 은닉이라는 특성을 잘 보여주고 있음  
👉 사용하는 결정적인 이유는 객체의 무결성을 보장하기 위함  
👉 메서드를 통해서만 접근할 수 있기 때문에, 객체 안의 데이터가 다른 객체에게 잘못 조작되는 것을 막아줌  
👉 또한, 메서드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있음  

<br>

## Preprocessor
👉 전처리기 구문(#으로 시작하는 구문)을 처리하는 역할 // .cpp -> .i  
👋 A **Preprocessor** is a program that processes its input data to produce output that is used as input to another program  

<br>

## Compiler
👉 고수준의 언어를 기계어와 가장 유사한 상태인 어셈블리어로 변환하는 역할 // .i -> .s  
👋 A **Compiler** is a computer program that translates computer code written in one programming language into another language  

<br>

## Assembler
👉 완전히 기계어로 변환하는 역할 // .s -> .o  
👋 An **Assembler** program creates object code by translating combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents  

<br>

## Linker
👉 여러 개의 오브젝트 파일들을 합치거나 라이브러리를 합쳐주는 역할 // .o -> .exe  
👋 **Linker** is a computer program that takes one or more object files generated by a compiler and combines them into a single executable file, etc  

<br>

## Compile
👉 사람이 이해하는 언어를 컴퓨터가 이해할 수 있는 언어로 바꾸어주는 과정  
👋 컴파일 과정은 위의 4가지 과정(P -> C -> A -> L)을 거침  

<br>

## Build
👉 소스코드 파일을 실행 가능한 소프트웨어 산출로 만드는 과정  

<br>

## Compile Error
👉 컴파일시 발생하는 에러, 주로 syntax 오류로 인해 발생하는 에러  

<br>

## Runtime Error
👉 프로그램 실행시 발생하는 에러, 주로 논리적 오류로 인해 발생하는 에러  
👋 논리적 오류 ; Divide by Zero, Infinite Loop, Out of Bounds 등  

<br>

## Struct(C++)
👉 사용자가 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 타입  

<br>

## Template(C++)
👉 C++ 프로그래밍 언어의 한 기능으로, 함수와 클래스가 제네릭 형과 동작할 수 있게 도와줌  
👋 Templates are a feature of the C++ Programming language that allows functions and classes to operate with generic types  

<br>

## 프로그램 실행 순서
👉 1. 사용자가 OS에게 프로그램 실행요청함  
👉 2. OS는 프로그램의 정보를 읽어 메모리에 로드함  
👉 3. CPU는 프로그램 코드를 가져다 메모리를 관리하고 명령문을 실행  
👉 4. 동적메모리가 할당되면 FreeStore 영역을 사용 (아래쪽으로 이동)  
👉 5. 스택메모리가 할당되면 FreeStore 영역을 사용 (위쪽으로 이동)  

<br>

## 메모리 구조 ✔️
### - Code
### - Data
### - Heap
### - Stack



<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>