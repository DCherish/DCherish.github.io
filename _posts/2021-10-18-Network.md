---
layout: page
title:  "Network"
subtitle: "Computer Science of Network"
date:   2021-10-18 11:11:11 +0530
categories: ["CS"]
comments: true
---
## Protocol
👉 형식, 네트워크 송수신 메세지의 순서 등을 미리 정하는 것(약속하는 것)  

<br>

## Throughput
👉 송신자와 수신자 사이에서 bit를 전송할 수 있는 평균 rate  

<br>

## OSI 5계층
👉 응용 계층, 전송 계층, 네트워크 계층, 데이터링크 계층, 물리 계층  
👋 표준, 일반적으로 많이 쓰임  

<br>

## OSI 7계층
👉 응용 계층, 표현 계층, 세션 계층, 전송 계층, 네트워크 계층, 데이터링크 계층, 물리 계층  
👋 통신사 내부관리용으로 많이 쓰임  

<br>

## Why Layering?
👉 정해진 계층 구조에 따라 모듈화 과정을 거쳐 trouble shooting에 용이  
👉 최적화 측면에서는 불리할 수 있음  
👋 packet header의 overhead  

<br>

## OSI Layer
👉 응용 계층  
　　👉 사용자와 가장 가까운 계층  
　　👉 우리가 사용하는 응용 서비스, 프로세스가 이 계층에서 동작함  
　　👉 데이터 단위 : Message  
　　👋 HTTP, SMTP  
👉 표현 계층  
　　👉 전송 데이터의 구문과 의미에 대한 처리를 담당하는 역할  
　　👉 데이터 단위 : Message  
　　👋 SSL  
👉 세션 계층  
　　👉 송수신 프로세스 사이의 세션의 확립 및 유지, 종료를 담당하는 역할  
　　👉 데이터 단위 : Message  
👉 전송 계층  
　　👉 양 끝단의 사용자들이 신뢰성 있는 데이터를 주고 받게 하는 역할  
　　👉 흐름 제어, 오류 제어 기능이 있음  
　　👉 데이터 단위 : Segment(TCP) / Datagram(UDP)  
　　👋 TCP, UDP  
👉 네트워크 계층  
　　👉 목적지까지 가장 안전하고 빠르게 데이터를 전송하는 기능인 라우팅을 담당함  
　　👉 데이터 단위 : Packet  
　　👋 IP, ICMP  
👉 데이터링크 계층  
　　👉 물리계층에서 송수신되는 정보의 오류와 흐름을 관리하여 안전하게 정보의 전달을 수행할 수 있도록 돕는 역할  
　　👉 데이터 단위 : Frame  
👉 물리 계층  
　　👉 데이터를 물리 매체 상으로 전송하는 역할  

<br>

## HTTP(HyperText Transfer Protocol)
👉 인터넷에서 데이터를 주고 받을 수 있는 프로토콜  
👉 Stateless, Connectionless 특징  
👉 약점을 보완하기 위해 쿠키 및 세션을 사용  
👋 Stateless : 이전 데이터를 유지하지 X  
👋 Connectionless : 요청에 맞는 응답을 보낸 후 연결을 끊음  
　　👉 non-persistent connection 방식  
　　　　👉 최대 한 개의 object만 TCP connection에 전송  
　　　　👉 여러 개의 object를 다운로드하려면 여러 connection이 필요  
　　👉 persistent connection 방식  
　　　　👉 여러 개의 object가 TCP connection을 통해 전송될 수 있음  

<br>

## HTTP status code
👉 1XX : 요청을 받았으며 작업을 계속함  
👉 2XX : 요청을 성공적으로 처리함  
👋 200 // OK  
👉 3XX : 요청을 마치기 위해 추가 동작이 필요함  
👉 4XX : 클라이언트 오류, 요청이 올바르지 X  
👋 400, 404 // Bad Request, Not Found  
👉 5XX : 서버 오류, 올바른 요청이었지만 서버가 응답할 수 X  
👋 502, 505 // Bad Gateway, HTTP Version Not Supported  

<br>

## HTTP 0.9
👉 최초의 HTTP  
👉 1.0의 이전 버전을 의미 (실존 X)  
👉 한 줄로 요청이 가능한 원라인 프로토콜  

<br>

## HTTP 1.0
👉 해당 버전부터 자세한 정보를 담기 시작  
👋 0.9는 단순 하이퍼텍스트를 전송하는 것에 집중  
👉 1. 버전 정보를 요청 정보에 포함  
👉 2. 응답 결과를 응답 정보에 포함  
　　👋 200, 404 등  
👋 3. 통신을 헤더와 바디로 분리  
　　👋 메타 데이터 전송 허용, 프로토콜 확장 가능성 확보  
👋 4. 새로운 헤더 정보를 통해 HTML의 다른 문서들의 전송도 가능하도록 기능을 추가  

<br>

## HTTP 1.1
👉 첫 번째 표준 프로토콜  
👉 여러 추가 기능이 있음  
👋 HTTP/1.0은 초창기 여러 버전으로 구현되기 시작  
👋 그 중 하나가 1.0이고 이보다 좋은 것을 1.1로 채택  
👉 1. 커넥션 재사용 가능  
👉 2. 파이프라이닝 추가  
　　👋 첫 요청에 대한 응답이 전송되기 전에 후속 요청 가능  
👉 3. Chunk된 응답 지원  
　　👋 한 번 응답 시 모든 정보 담지 않고 분할 응답 가능  
👉 4. 캐시 제어 메커니즘 도입  
👋 5. 언어, 인코딩, 타입을 포함한 콘텐츠 협상 도입  
　　👋 클라이언트와 서버로 하여금 교환하려는 가장 적합한 콘텐츠에 대한 동의를 가능  
👋 6. 헤더의 Host 정보로 인해 동일 IP 주소에 다른 도메인을 호스트하는 기능 가능  
👉 조금 느림.. why?  
　　👉 1. 연결당 하나의 요청과 응답을 처리 // 동시 전송 문제  
　　👉 2. HOL Blocking // 특정 응답 지연  
　　👉 3. RTT 증가 // 양방향 지연  
　　👉 4. 헤더가 큼 // 쿠키로 인해  

<br>

## HTTP 2.0
👉 성능 개선에 초점  
👉 1. 한 커넥션에 여러 개의 메시지를 주고 받을 수 O  
👉 2. 요청이 커넥션 상에 다중화되므로 HOL Blocking 발생 X  
👉 3. 헤더 정보 HPACK 압축 방식을 이용하여 압축 전송  
👉 4. 페이지 로딩 속도 향상  
👉 5. 프로토콜 협상 메커니즘  
　　👋 HTTP/1.1, HTTP/2.0, 기타 선택  
👉 6. HTTP/1.1과의 높은 호환성  
👋 7. 요청 리소스간 의존 관계를 설정  
👋 8. HTML문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 O  

<br>

## HTTP 3.0
👉 TCP 기반이 아닌 UDP QUIC를 사용하여 통신하는 프로토콜  
👉 1. 딜레이 감소  
👉 2. 멀티플렉싱 지원  
👉 3. 네트워크 스위칭 속도 개선  
👉 HTTP/2.0 보다 빨라짐  
👋 QUIC : 전송 계층 통신 프로토콜  
👋 멀티플렉싱 : 커넥션 상에 요청 다중화  

<br>

## HOL(Head-Of-Line) Blocking
👉 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상  

<br>

## HTTPS(HTTP over SSL)
👉 HTTP에 데이터 암호화가 추가된 프로토콜  
👉 서버와 클라이언트 사이의 모든 통신 내용이 암호화  
👉 공개키/개인키 암호화 방식  

<br>

## 공개키/개인키 암호화 방식
👋 공개키 : 누구에게나 공개가 가능한 키  
👋 개인키 : 개인만이 알고 있어야 하는 키  
👉 데이터 ➕ 공개키 ➡️ 암호화  
👉 암호화 ➕ 개인키 ➡️ 데이터  
　　👉 공개키 암호화, 개인키로만 열 수 있어 안전  
👉 데이터 ➕ 개인키 ➡️ 암호화  
👉 암호화 ➕ 공개키 ➡️ 데이터  
　　👉 개인키 암호화, 공개키로 열린다면 개인키와 매칭됨을 알 수 있어 신뢰성을 보장  

<br>

## HTTPS 동작 과정
👉 Server 측, HTTPS 적용 위해 공개키/개인키 발급  
👉 Server ➡️ CA, 비용을 지불하여 공개키 저장 인증서 발급 요청 
👉 CA 측, CA의 이름 & Server 공개키 & Server 정보 등을 포함하여 CA의 개인키를 통해 인증서 생성  
👉 CA ➡️ Server, 생성한 인증서를 Server에 발급  
👉 Client ➡️ Server, 특정 요청 발생  
👉 Server ➡️ Client, 인증서 제공  
👉 Client 측, CA 공개키를 이용해 인증서를 복호화하여 Server 공개키 획득  
👉 Client ➡️ Server, Server 공개키로 암호화하여 데이터 전송  
👉 Server 측, Server 개인키로 복호화하여 데이터 수신  

<br>

## CA(Certificate Authority)
👉 인증서를 발급하는 기관  
👉 공인된 인증 기관이라면, Browser에는 CA 리스트와 공개키가 내부에 저장되어 있음  

<br>

## SSL(Secure Socket Layer)
👉 공개키 방식과 공개키 방식이 느리다는 단점을 보완한 대칭키 방식을 모두 사용  
👋 대칭키 : 동일한 키 하나로 암호화와 복호화 모두 할 수 있음  
　　👉 매번 랜덤으로 생성되어 다음 번에 사용할 수 없음  
　　👉 안전하고 빠르다는 장점이 있음    

<br>

## 브라우저에 www.google.com을 입력할 경우, 동작 과정
👉 브라우저는 캐싱된 DNS 기록들을 통해 입력한 URL 주소에 대응하는 IP 주소가 있는지 확인함  
👉 캐시에 존재하지 않는다면, 사용자가 입력한 URL 주소 중에서 도메인 네임 부분을 DNS 서버에서 검색함  
👉 DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달함  
👉 전달받은 IP 주소와 웹 페이지 URL 정보는 HTTP 프로토콜을 사용하여 HTTP Request 메시지를 생성함  
👉 생성된 HTTP Request 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송됨  
👉 도착한 HTTP Request 메시지를 통해 서버에서 요청을 처리하면 서버에서 다시 HTTP 프로토콜을 사용하여 HTTP Response 메시지를 생성함  
👉 생성된 HTTP Response 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송됨  
👉 도착한 HTTP Response 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환됨  
👉 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있음  

<br>

## DNS(Domain Name Service)
👋 Domain : 사람이 쉽게 기억하고 입력할 수 있도록 문자로 만든 인터넷 주소  
👋 Domain Name : 네트워크 상에서 컴퓨터를 식별하는 호스트명  
👉 호스트의 도메인 네임을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수핼할 수 있도록 개발된 시스템  
👋 The DNS is a hierarchical and decentralized naming system for computers, services, or other resources connected to the internet of a private notwork  
👋 Most prominently, it translates more readily memorized domain names to the numerical IP addresses needed for locating and identifying computer services  
👋 UDP를 사용  

<br>

## REST 구성 요소
👉 리소스, HTTP URI  
👉 리소스에 대한 행위, HTTP Method  
👉 리소스에 대한 행위의 내용, HTTP Message Payload  

<br>

## REST 특징
👉 Server-Client, Stateless, 캐쉬 처리 가능, 계층화, 인터페이스 일관성  
👉 HTTP 프로토콜을 따르는 모든 플랫폼에서 사용 가능  
👉 HTTP 프로토콜 인프라 그대로 사용하므로 별도 인프라 구축 필요 X  
👉 But, 사용할 수 있는 메소드의 개수가 한정적  
👉 Header 정보를 처리해야하므로 전문성이 요구  

<br>

## HTTP RESTful
👉 REST의 원리를 따르는 시스템을 의미  
👉 REST를 사용했다고 모두 RESTful하다 할 수 없음  
👉 REST API 설계 규칙을 올바르게 지켜야 함  
👉 이해하기 쉽고 사용하기 쉬운 REST API를 만들기 위함  

<br>

## REST API 설계 규칙
👉 1. 대문자보다는 소문자  
👉 2. URI에 파일 확장자는 포함하지 X  
👉 3. URI에 행위를 포함하지 X  
👉 4. URI는 동사보다 명사  
👉 5. 언더바 대신 하이픈을 사용  
👉 6. 마지막 슬래쉬를 포함하지 X  
👋 소확행, 동명, 언하, 마슬  

<br>

## 쿠키
👉 사용자의 브라우저에 저장되고, 통신할 때 HTTP 헤더에 포함되는 작은 텍스트 데이터 파일  
👉 이름, 값, 만료 기간, 도메인, 경로 정보가 있고 키와 값으로 구성되어 있음  
👉 동작 방식  
　　👉 클라이언트가 페이지를 요청  
　　👉 서버에서 쿠키를 생성  
　　👉 HTTP 헤더에 쿠키를 포함시켜 응답  
　　👉 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음  
　　👉 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄  
　　👉 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답  
👋 방문 사이트 로그인 저장 여부, 쇼핑몰 장바구니, 팝업 페이지 등  

<br>

## 세션
👉 쿠키를 기반하고 있으며 서버 측에서 관리  
👉 서버에서는 클라이언트를 구분하기 위해 세선 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지  
👉 동작 방식  
　　👉 클라이언트가 서버에 접속 시 세션 ID를 발급 받음  
　　👉 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음  
　　👉 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청  
　　👉 서버는 세션 ID를 전달 받아 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져와 사용  
　　👉 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답  
👋 로그인 같이 보안상 중요한 작업을 사용할 때  

<br>

## 쿠키 🆚 세션
👉 가장 큰 차이는 사용자의 정보가 저장되는 위치  
　　👉 쿠키는 서버의 자원을 사용하지 않지만, 세션은 서버의 자원을 사용  
👉 보안 면에서 세션이 더 우수, 요청 속도 면에서 쿠키가 더 빠름  
　　👉 1. 쿠키는 로컬에 저장되기 때문에 스니핑 등의 우려가 있지만 세션은 쿠키를 이용하여 세션 ID만 저장하고 그것으로 구분하여 서버에서 처리하기 때문  
　　👉 2. 쿠키는 그 자체에 정보가 있지만 세션은 정보가 서버에 있어 서버의 처리가 필요하기 때문  
👉 세션은 서버의 자원을 사용하기 때문에 무분별하게 사용할 경우 서버의 메모리가 감당할 수 없음  

<br>

## 캐시(Cache)
👉 리소스 파일들의 임시 저장소  
👉 같은 웹페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 됨  
👉 이전에 사용되었던 데이터는 다시 사용될 가능성이 높음  
👉 따라서, 다시 사용될 확률이 있는 데이터들을 빠르게 접근 가능하도록 저장소에 저장하여 페이지 로딩 속도를 개선  
👋 이미지, 비디오, 오디오, css, js 등  

<br>

## 3 way handshake
👉 TCP 통신으로 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정  
<br>
<img src="{{ '/assets/cs/cs_net_1.png' }}" style="width: 660px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## 4 way handshake
👉 TCP 통신의 네트워크 연결을 해제하는 과정  
<br>
<img src="{{ '/assets/cs/cs_net_2.png' }}" style="width: 660px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## GET 🆚 POST
👉 클라이언트가 서버로 요청을 보내는 방법인 HTTP Method 2가지  
👉 GET  
　　👉 어떠한 정보를 가져와서 조회하기 위해 사용  
　　👉 데이터 노출 여부 : URI에 데이터 노출  
　　👉 데이터 위치 : 헤더  
　　👉 전송길이 제한 : O  
　　👉 캐싱가능 여부 : O  
👉 POST  
　　👉 데이터를 서버로 제출하여 추가 또는 수정하기 위하여 사용  
　　👉 데이터 노출 여부 : URI에 데이터 노출되지 X  
　　👉 데이터 위치 : 바디  
　　👉 전송길이 제한 : X  
　　👉 캐싱가능 여부 : X  
👋 캐싱 : 한번 접근 후에 또 요청할 시 빠르게 접근하기 위해 레지스터에 데이터를 저장시켜 놓는 것  

<br>

## PUT 🆚 PATCH
👉 HTTP Method 중 리소스의 업데이트를 의미하는 2가지 Method  
👉 PUT  
　　👉 리소스의 전체를 업데이트  
👉 PATCH  
　　👉 리소스의 일부를 업데이트  

<br>

## Web Server 🆚 Web Application Server
👉 WS  
　　👉 클라이언트의 request를 받아 정적인 컨텐츠(html, css, js)를 response하는 Server  
　　👋 Apache, Nginx 등  
👉 WAS  
　　👉 클라이언트의 request를 받아 DB 조회나 어떤 로직을 처리해야하는 동적인 컨텐츠를 response하는 Server  
　　👋 Tomcat 등  
👉 보통 WAS가 정적 컨텐츠까지 제공하기 때문에 WS없이 사용하기도 하지만, 같이 사용하는 이유는 WAS가 해야할 일의 부담을 줄이기 위해서 사용  

<br>

## 캡슐화(Encapsulation)
👉 송신 데이터에 필요한 정보(헤더)를 붙여서 하위 계층으로 보내는 기술  

<br>

## 역캡슐화(Decapsulation)
👉 캡슐화의 반대되는 개념으로 헤더를 제거하고 상위 계층으로 보내는 기술  

<br>

## ARP Request
👉 특정 IP 주소에 대한 물리주소(MAC)를 요구  

<br>

## ARP Response
👉 특정 IP 주소에 대한 물리주소(MAC)를 응답  

<br>

## Proxy ARP
👉 라우터가 외부 네트워크에 존재하는 호스트의 ARP Request에 대해 자신의 하드웨어 주소로 응답  

<br>

## MAC 주소
👉 네트워크 상에서 서로를 구분하기 위해 장치마다 공퓨하게 부여된 물리적인 주소  

<br>

## IP 주소
👉 인터넷에 연결되어 있는 모든 장치를 식별하기 위해 필요한 고유 주소  

<br>

## IP
👉 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고 받기 위해 사용하는 통신 프로토콜  

<br>

## ICMP
👉 오류에 관한 보고 기능과 네트워크 상태 진단 기능을 통해 IP를 보조하는 기능을 가진 프로토콜  

<br>

## 공인 IP 🆚 사설 IP
👉 공인 IP  
　　👉 전 세계적으로 중복이 되지 않은 고유한 번호  
　　👉 개인이 자유롭게 할당할 수 없고 ISP가 제공하는 IP 주소  
　　👉 외부에서 접근이 가능  
👉 사설 IP  
　　👉 한정된 범위 내에서만 사용하는 IP 주소  
　　👉 IPv4의 부족으로 모든 네트워크가 공인 IP를 사용할 수 없기에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소  
　　👉 외부에서 이 주소로 통신할 수 X  
　　👉 NAT 등을 사용해 주소를 변환하여 통신  
👋 ISP : 인터넷 접속 서비스 등을 제공하는 회사  
👋 NAT : 사설 IP를 공인 IP로 변경하는데 사용하는 통신망의 주소 변환기  


<br>

## IPv4 ➡️ IPv6 제거된 헤더 필드
👉 **헤더 체크섬**, 헤더 길이, 식별자, 플래스, 단편화 옵셋  

<br>

## TCP/IP
👉 TCP와 IP를 합친 말로, 인터넷에서 사용되는 프로토콜  

<br>

## TCP 🆚 UDP
👉 TCP  
　　👉 송신 호스트와 수신 호스트가 신뢰성 있게 정보를 주고 받기 위해 사용하는 프로토콜  
　　👉 연결 방식 : 연결형 서비스  
　　👉 전송 순서 : 순서가 바뀌지 않음  
　　👉 수신 여부 확인 : 확인 O  
　　👉 통신 방식 : 1 on 1  
　　👉 신뢰성 : 높음  
　　👉 속도 : 느림  
　　👋 사용 예시 : Unicast, 파일 전송  
👉 UDP  
　　👉 TCP와는 다르게 신뢰성 관계없이 정보를 주고 받기 위해 사용하는 프로토콜  
　　👉 연결 방식 : 연결형 서비스  
　　👉 전송 순서 : 순서가 바뀔 수 있음  
　　👉 수신 여부 확인 : 확인 X  
　　👉 통신 방식 : 1 on 1 / 1 on N / N on N  
　　👉 신뢰성 : 낮음  
　　👉 속도 : 빠름  
　　👋 사용 예시 : Multicast, Broadcast, **DNS**, 스트리밍  

<br>

## Port
👉 네트워크를 통해 데이터를 주고받는 프로세스를 식별하기 위해 호스트 내부적으로 프로세스가 할당받는 고유한 값, 이를 Port Number라고 함  
👉 쉽게 말해 Port는 논리적인 접속장소, Port Number는 그에 해당하는 값  

<br>

## Well-known Port Number
👉 DNS(53), HTTP(80), HTTPS(443)  

<br>

## 터널링(Tunneling)
👉 특정 프로토콜을 사용하는 네트워크 사이에 다른 프로토콜을 사용하는 네트워크가 존재할 때, 중간 네트워크에서 사용하는 프로토콜로 캡슐화하여 전송하는 방법  

<br>

## 소켓(Socket)
👉 네트워크를 통한 입/출력을 하기 위해 사용자에게 필요한 수단을 제공하는 응용 프로토콜 인터페이스  
👋 A network socket is a software structure within a network node of a computer network that serves as an endpoint for sending and receiving data across the network  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>