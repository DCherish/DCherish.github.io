---
layout: page
title:  "Network"
subtitle: "Computer Science of Network"
date:   2021-10-18 11:11:11 +0530
categories: ["CS"]
comments: true
---
## Protocol
👉 형식, 네트워크 송수신 메세지의 순서 등을 미리 정하는 일종의 협약  

<br>

## OSI 5계층
👉 응용 계층, 전송 계층, 네트워크 계층, 데이터링크 계층, 물리 계층  
✋ 표준, 일반적으로 많이 쓰임  

<br>

## OSI 7계층
👉 응용 계층, 표현 계층, 세션 계층, 전송 계층, 네트워크 계층, 데이터링크 계층, 물리 계층  
✋ 통신사 내부관리용으로 많이 쓰임  

<br>

## Why Layering?
👉 정해진 계층 구조에 따라 모듈화 과정을 거쳐 trouble shooting에 용이  
✋ 최적화 측면에서는 불리할 수 있음  
✋ packet header의 overhead  

<br>

## OSI Layer ✔️
👉 응용 계층  
　　👉 사용자와 가장 가까운 계층  
　　👉 우리가 사용하는 응용 서비스, 프로세스가 동작하는 계층  
　　✋ 데이터 단위 : Message  
　　✋ HTTP, SMTP  
👉 표현 계층  
　　👉 전송 데이터의 구문과 의미에 대한 처리를 담당하는 계층  
　　✋ 데이터 단위 : Message  
👉 세션 계층  
　　👉 송수신 프로세스 사이의 세션의 확립 및 유지, 종료를 담당하는 계층  
　　✋ 데이터 단위 : Message  
　　✋ SSL/TLS : SSL ➡️ TLS : 버전이 업데이트되며 명칭이 변경된 것일뿐, 큰 차이 없음  
👉 전송 계층  
　　👉 양 끝단의 사용자들이 신뢰성 있는 데이터를 주고 받게 하는 계층  
　　✋ 흐름 제어, 혼잡 제어 기능이 있음  
　　✋ 데이터 단위 : Segment(TCP) / Datagram(UDP)  
　　✋ TCP, UDP  
👉 네트워크 계층  
　　👉 목적지까지 가장 안전하고 빠르게 데이터를 전송하는 기능인 라우팅을 담당하는 계층  
　　✋ 데이터 단위 : Packet  
　　✋ IP, ICMP  
👉 데이터링크 계층  
　　👉 물리계층에서 송수신되는 정보의 오류와 흐름을 관리하여 안전하게 정보의 전달이 이뤄지도록 돕는 계층  
　　✋ 데이터 단위 : Frame  
👉 물리 계층  
　　👉 데이터를 물리 매체 상으로 전송하는 계층  

<br>

## HTTP(HyperText Transfer Protocol) ✔️
👉 인터넷에서 데이터를 주고 받을 수 있게 하는 프로토콜  
👋 서버와 클라이언트 사이에서 요청 및 응답이 이루어지는 형태로 동작  
👋 Stateless, Connectionless 특징  
👋 약점을 보완하기 위해 쿠키 및 세션을 사용  
👋 Stateless : 이전 데이터를 유지하지 X  
👋 Connectionless : 요청에 맞는 응답을 보낸 후 연결을 끊음  
　　✋ non-persistent connection 방식  
　　　　✋ 최대 한 개의 object만 TCP connection에 전송  
　　　　✋ 여러 개의 object를 다운로드하려면 여러 connection이 필요  
　　✋ persistent connection 방식  
　　　　✋ 여러 개의 object가 TCP connection을 통해 전송될 수 있음  

<br>

## HTTP status(response) code
👉 클라이언트가 보낸 HTTP 요청에 대한 서버의 상태를 알려주는 코드  
　　👉 1XX : 요청을 받았으며 작업을 계속함  
　　👉 2XX : 요청을 성공적으로 처리함  
　　👋 200 // OK  
　　👉 3XX : 요청을 마치기 위해 추가 동작이 필요함  
　　👉 4XX : 클라이언트 오류, 요청이 올바르지 X  
　　👋 400, 404 // Bad Request, Not Found  
　　👉 5XX : 서버 오류, 올바른 요청이었지만 서버가 응답할 수 X  
　　👋 502, 505 // Bad Gateway, HTTP Version Not Supported  
👋 Gateway : 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간 통신을 가능하게 하는 것  

<br>

## HTTP 0.9 🔥
👉 단순 하이퍼텍스트를 전송하는 것에 집중  
👋 최초의 HTTP  
👋 1.0의 이전 버전을 의미 (실존 X)  

<br>

## HTTP 1.0 🔥
👉 하나의 커넥션 당 하나의 요청과 응답을 처리  
👋 해당 버전부터 자세한 정보를 담기 시작  
✋ 1. 버전 정보를 요청 정보에 포함  
✋ 2. 응답 결과를 응답 정보에 포함  
　　✋ 200, 404 등  
✋ 3. 통신을 헤더와 바디로 분리  
　　✋ 메타 데이터 전송 허용, 프로토콜 확장 가능성 확보  

<br>

## HTTP 1.1
👉 첫 번째 표준 프로토콜, 여러 기능 추가  
👉 1. 파이프라이닝 추가  
　　👉 하나의 커넥션을 통해 여러 요청과 응답할 수 있는 기능  
　　👉 하지만, 정확한 구현이 어렵고 HOL Blocking이 발생한다는 문제점이 있음  
👋 2. 커넥션 재사용 가능  
👋 3. Chunk된 응답 지원  
　　👋 한 번 응답 시 모든 정보 담지 않고 분할 응답 가능  
👋 4. 캐시 제어 메커니즘 도입  

<br>

## HTTP 2.0
👉 성능 개선에 초점  
👉 1. 한 커넥션에 여러 개의 메시지를 동시에 주고 받을 수 있는 멀티플렉싱 기능을 지원  
👉 2. 기존과 다르게 요청과 응답을 순서와 상관없이 보낼 수 있게 되어 HOL Blocking 발생 X  
👋 3. 헤더 정보 HPACK 압축 방식을 이용하여 압축 전송  
👋 4. 페이지 로딩 속도 향상  
👋 5. 프로토콜 협상 메커니즘  
　　👋 HTTP/1.1, HTTP/2.0, 기타 선택  
✋ 6. HTTP/1.1과의 높은 호환성  
✋ 7. 요청 리소스간 의존 관계를 설정  
✋ 8. HTML문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 O  

<br>

## HTTP 3.0
👉 TCP 기반이 아닌 UDP QUIC를 사용하여 통신하는 프로토콜  
👉 1. 딜레이 감소  
👉 2. 멀티플렉싱 지원  
👋 3. 네트워크 스위칭 속도 개선  
👋 HTTP/2.0 보다 빨라짐  
👋 QUIC : 전송 계층 통신 프로토콜  
👋 멀티플렉싱 : 커넥션 상에 요청 다중화  

<br>

## HOL(Head-Of-Line) Blocking
👉 네트워크에서 한 패킷이 같은 큐에 있는 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상  

<br>

## HTTPS(HTTP over SSL) ✔️
👉 HTTP에 데이터 암호화가 추가된 프로토콜  
👉 서버와 클라이언트 사이의 모든 통신 내용이 암호화  
👉 공개키/개인키 암호화 방식  

<br>

## SSL(Secure Socket Layer)
👉 웹 서버와 브라우저 사이의 보안을 위해 만들어짐  
👋 공개키 방식과 공개키 방식이 느리다는 단점을 보완한 대칭키 방식을 모두 사용  
👋 대칭키 : 동일한 키 하나로 암호화와 복호화 모두 할 수 있음  
　　👋 매번 랜덤으로 생성되어 다음 번에 사용할 수 없음  
　　✋ 안전하고 빠르다는 장점이 있음  

<br>

## 공개키/개인키 암호화 방식
👋 공개키 : 누구에게나 공개가 가능한 키  
👋 개인키 : 개인만이 알고 있어야 하는 키  
👉 데이터 ➕ 공개키 ➡️ 암호화  
👉 암호화 ➕ 개인키 ➡️ 데이터  
　　👉 공개키 암호화, 개인키로만 열 수 있어 안전  
👉 데이터 ➕ 개인키 ➡️ 암호화  
👉 암호화 ➕ 공개키 ➡️ 데이터  
　　👉 개인키 암호화, 공개키로 열린다면 개인키와 매칭됨을 알 수 있어 신뢰성을 보장  

<br>

## HTTPS 동작 과정 ✔️
👉 Server 측, HTTPS 적용 위해 공개키/개인키 생성  
👉 Server ➡️ CA, 비용을 지불하여 공개키 저장 인증서 발급 요청  
👉 CA 측, CA의 이름 & Server 공개키 & Server 정보 등을 포함하여 CA의 개인키를 통해 인증서 생성  
👉 CA ➡️ Server, 생성한 인증서를 Server에 발급  
👉 Client ➡️ Server, 특정 요청 발생  
👉 Server ➡️ Client, 인증서 제공  
👉 Client 측, CA 공개키를 이용해 인증서를 복호화하여 Server 공개키 획득  
👉 Client 측, 실제 데이터를 암호화할 대칭키를 생성하여 이를 Server 공개키로 암호화  
👉 Client ➡️ Server, 암호화된 데이터 전송  
👉 Server 측, Server 개인키로 복호화하여 대칭키를 획득, 이후 데이터 통신  

<br>

## CA(Certificate Authority)
👉 인증서를 발급하는 기관  
👉 공인된 인증 기관이라면, Browser에는 CA 리스트와 공개키가 내부에 저장되어 있음  

<br>

## 브라우저에 www.google.com을 입력할 경우, 동작 과정 ✔️
👉 브라우저에 사용자가 찾고 싶은 웹 페이지의 URL 주소를 입력함  
👉 사용자가 입력한 URL 주소 중에서 도메인 네임 부분을 DNS 서버에서 검색함  
👉 DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달함  
👉 전달받은 IP 주소와 웹 페이지 URL 정보는 HTTP 프로토콜을 사용하여 HTTP Request 메시지를 생성함  
👉 생성된 HTTP Request 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송됨  
👉 도착한 HTTP Request 메시지는 HTTP 프로토콜을 사용하여 URL 정보로 변환됨  
👉 웹 서버는 URL 정보에 해당하는 데이터를 검색함  
👉 검색된 데이터는 다시 HTTP 프로토콜을 사용하여 HTTP Response 메시지를 생성함  
👉 생성된 HTTP Response 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송됨  
👉 도착한 HTTP Response 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환됨  
👉 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있음  

<br>

## DNS(Domain Name System) ✔️
👋 Domain : 사람이 쉽게 기억하고 입력할 수 있도록 문자로 만든 인터넷 주소  
👋 Domain Name : 네트워크 상에서 컴퓨터를 식별하는 호스트명  
👉 호스트의 도메인 네임을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 개발된 시스템  
✋ The DNS is a hierarchical and decentralized naming system for computers, services, or other resources connected to the internet of a private notwork  
✋ Most prominently, it translates more readily memorized domain names to the numerical IP addresses needed for locating and identifying computer services  
👋 UDP를 사용  

<br>

## REST(REpresentational State Transfer) ✔️
👉 리소스를 이름으로 구분하여 해당 리소스의 상태를 주고 받는 것  
👉 클라이언트와 서버 통신 방식 중 하나  

<br>

## REST 구성 요소 ✔️
👉 리소스, HTTP URI  
👉 리소스에 대한 행위, HTTP Method  
👉 리소스에 대한 행위의 내용, HTTP Message Payload  

<br>

## RESTful ✔️
👉 REST API 설계 규칙을 올바르게 지킨 서비스  
👋 즉, REST를 사용했다고 모두 RESTful하다 할 수 없음  
✋ 이해하기 쉽고 사용하기 쉬운 REST API를 만들기 위함  

<br>

## REST API ✔️
👉 REST 기반으로 서비스 API를 구현한 것  

<br>

## REST API 설계 규칙 ✔️
👉 1. URI에는 **동**사보다 **명**사  
👉 2. 대문자보다는 **소**문자  
👉 3. 파일 **확**장자는 포함하지 X  
👉 4. **행**위를 포함하지 X  
👉 5. 언더**바** 대신 **하**이픈을 사용  
👉 6. **마**지막에 **슬**래쉬를 포함하지 X  
👋 **동명, 소확행, 바하마슬**  

<br>

## 쿠키
👉 통신할 때 HTTP 헤더에 포함되는 작은 텍스트 데이터 파일  
👋 이름, 값, 만료 기간 등의 정보가 있고 키와 값으로 구성되어 있으며, 사용자의 브라우저에 저장됨  
👉 동작 방식  
　　👉 클라이언트가 페이지를 요청  
　　👉 서버에서 쿠키를 생성  
　　👉 HTTP 헤더에 쿠키를 포함시켜 응답  
　　👉 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음  
　　👉 다시 서버에 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄  
　　👉 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답  
👋 방문 사이트 로그인 저장 여부, 쇼핑몰 장바구니, 팝업 페이지 등  

<br>

## 세션
👉 쿠키를 기반하고 있으며 서버 측에서 관리  
👉 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지  
👉 동작 방식  
　　👉 클라이언트가 서버에 접속 시 세션 ID를 발급 받음  
　　👉 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음  
　　👉 클라이언트는 서버에 요청할 때, 쿠키와 세션 ID를 같이 서버에 전달해서 요청  
　　👉 서버는 세션 ID를 전달 받아 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져와 사용  
　　👉 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답  
👋 로그인 같이 보안상 중요한 작업을 사용할 때  

<br>

## 쿠키 🆚 세션
👉 가장 큰 차이는 사용자의 정보가 저장되는 위치  
　　👉 쿠키는 서버의 자원을 사용하지 않지만, 세션은 서버의 자원을 사용  
👉 보안 면에서 세션이 더 우수, 요청 속도 면에서 쿠키가 더 빠름  
　　👋 1. 쿠키는 로컬에 저장되기 때문에 스니핑 등의 우려가 있지만 세션은 쿠키를 이용하여 세션 ID만 저장하고 그것으로 구분하여 서버에서 처리하기 때문  
　　👋 2. 쿠키는 그 자체에 정보가 있지만 세션은 정보가 서버에 있어 서버의 처리가 필요하기 때문  
✋ 세션은 서버의 자원을 사용하기 때문에 무분별하게 사용할 경우 서버의 메모리가 감당할 수 없음  

<br>

## 캐시(Cache)
👉 CPU의 처리 속도와 메인 메모리의 접근 속도의 차이를 줄이기 위해 사용하는 고속 Buffer Memory  
👉 리소스 파일들의 임시 저장소 역할  
👋 같은 웹페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 됨  
✋ 이전에 사용되었던 데이터는 다시 사용될 가능성이 높음  
✋ 따라서, 다시 사용될 확률이 있는 데이터들을 빠르게 접근 가능하도록 저장소에 저장하여 페이지 로딩 속도를 개선  
✋ 이미지, 비디오, 오디오, css, js 등  

<br>

## 3 way handshake ✔️
👉 TCP 통신 네트워크 연결을 설정하는 과정  
<br>
<img src="{{ '/assets/cs/cs_net_1.png' }}" style="width: 660px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## 4 way handshake ✔️
👉 TCP 통신 네트워크 연결을 해제하는 과정  
<br>
<img src="{{ '/assets/cs/cs_net_2.png' }}" style="width: 660px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## TCP 연결 관련 추가 질문 3가지
👉 1. 연결 설정 과정(3 way)과 연결 종료 과정(4 way)이 단계 차이나는 이유?  
　　👉 Client가 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 FIN에 대한 ACK만 보내고, 데이터를 모두 전송한 후 자신도 FIN 메시지를 보내기 때문  
👉 2. 만약 Server에서 FIN 플래그를 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생하면?  
　　👉 이러한 현상에 대비하여 Client는 Server로부터 FIN 플래그를 수신하더라도 일정한 시간동안 세션을 남겨 놓고 잉여 패킷을 기다리는 TIME_WAIT 과정을 거침  
👉 3. 초기 Sequence Number을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유?  
　　👉 서버 측에서는 패킷의 SYN을 보고 패킷을 구분함  
　　👉 난수가 아닌 순차적인 Number가 전송된다면, Connection을 맺을 때 사용하는 Port는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용되기 때문에 이전의 Connection으로부터 오는 패킷으로 인식할 수 있음  
　　👉 이런 문제가 발생할 가능성을 줄이기 위해서 난수로 ISN을 설정  

<br>

## GET 🆚 POST ✔️
👉 클라이언트가 서버로 요청을 보내는 HTTP Method 2가지  
👉 GET  
　　👉 어떠한 정보를 조회하기 위해 사용하는 Method  
　　👉 데이터 **위치** : 헤더  
　　👉 데이터 **노출** 여부 : URI에 데이터 노출  
　　👉 **캐싱**가능 여부 : O  
　　👉 전송**길이** 제한 : O  
👉 POST  
　　👉 데이터를 서버로 제출하여 추가 또는 수정하기 위해 사용하는 Method  
　　👉 데이터 **위치** : 바디  
　　👉 데이터 **노출** 여부 : URI에 데이터 노출되지 X  
　　👉 **캐싱**가능 여부 : X  
　　👉 전송**길이** 제한 : X  
👋 캐싱 : 한번 접근 후에 또 요청할 시 빠르게 접근하기 위해 데이터를 저장시켜 놓는 것  
👋 **겟포스트, 위치노출, 캐싱길이**

<br>

## PUT 🆚 PATCH
👉 리소스의 업데이트를 의미하는 HTTP Method 2가지  
👉 PUT  
　　👉 리소스의 전체를 업데이트  
👉 PATCH  
　　👉 리소스의 일부를 업데이트  

<br>

## Web Server 🆚 Web Application Server
👉 WS  
　　👉 클라이언트의 request를 받아 정적인 컨텐츠(html, css, js)를 response하는 Server  
　　✋ Apache, Nginx 등  
👉 WAS  
　　👉 클라이언트의 request를 받아 DB 조회와 같은 동적인 컨텐츠를 response하는 Server  
　　✋ Tomcat 등  
👋 보통 WAS가 정적 컨텐츠까지 제공하기 때문에 WS없이 사용하기도 하지만, 같이 사용하는 이유는 WAS가 해야할 일의 부담을 줄이기 위해서 사용  

<br>

## ARP Request
👉 특정 IP 주소에 대한 물리주소(MAC)를 요구  

<br>

## ARP Response
👉 특정 IP 주소에 대한 물리주소(MAC)를 응답  

<br>

## Proxy ARP
👉 라우터가 외부 네트워크에 존재하는 호스트의 ARP Request에 대해 자신의 하드웨어 주소로 응답  

<br>

## MAC 주소
👉 네트워크 상에서 서로를 구분하기 위해 장치마다 고유하게 부여된 물리적인 주소  

<br>

## IP 주소
👉 인터넷에 연결되어 있는 모든 장치를 식별하기 위해 필요한 고유 주소  

<br>

## IP(Internet Protocol) ✔️
👉 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고 받기 위해 사용하는 통신 프로토콜  

<br>

## ICMP(Internet Control Message Protocol)
👉 오류 보고 기능과 네트워크 상태 진단 기능 등 IP를 보조하는 기능을 가진 프로토콜  

<br>

## TCP/IP ✔️
👉 TCP와 IP를 합친 말로, 인터넷에서 사용되는 프로토콜  

<br>

## TCP/IP 흐름 제어 & 혼잡 제어 🔥
👉 흐름 제어  
　　👉 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 방법  
👉 혼잡 제어  
　　👉 송신측의 데이터 전달과 네트워크 데이터 처리 속도 차이를 해결하기 위한 방법  

<br>

## TCP 🆚 UDP ✔️
👉 TCP(Transmission Control Protocol)  
　　👉 송신 호스트와 수신 호스트가 신뢰성 있는 정보를 주고 받기 위해 사용하는 통신 프로토콜  
　　👉 **연결** 방식 : 연결형 서비스  
　　👉 전송 **순서** : 순서가 바뀌지 않음  
　　👉 수신 **여부** 확인 : 확인 O  
　　👉 **통**신 **방**식 : 1 on 1  
　　👉 **신뢰**성 : 높음  
　　👉 **속도** : 느림  
　　👋 사용 예시 : Unicast, 파일 전송  
👉 UDP(User Datagram Protocol)  
　　👉 신뢰성 없는 비연결형 통신 프로토콜  
　　👉 **연결** 방식 : 비연결형 서비스  
　　👉 전송 **순서** : 순서가 바뀔 수 있음  
　　👉 수신 **여부** 확인 : 확인 X  
　　👉 **통**신 **방**식 : 1 on 1 / 1 on N / N on N  
　　👉 **신뢰**성 : 낮음  
　　👉 **속도** : 빠름  
　　👋 사용 예시 : Multicast, Broadcast, DNS, 스트리밍  
👋 **TCPUDP, 연결순서여부, 통방신뢰속도**  

<br>

## Port
👉 네트워크를 통해 데이터를 주고받는 프로세스를 식별하기 위해 호스트 내부적으로 프로세스가 할당받는 고유한 값  
👉 숫자 값이므로 이를 Port Number라고도 함  
✋ 쉽게 말해 Port는 논리적인 접속장소, Port Number는 그에 해당하는 값  

<br>

## Well-known Port Number
👉 DNS(53), HTTP(80), HTTPS(443)  

<br>

## 소켓(Socket)
👉 프로세스 간 통신에 사용되는 양쪽 끝단  
✋ A network socket is a software structure within a network node of a computer network that serves as an endpoint for sending and receiving data across the network  

<br>

## 소켓 프로그래밍
👉 소켓을 이용한 통신 프로그래밍  

<br>

## Nagle 알고리즘
👉 전송 패킷의 수를 줄여 TCP/IP 네트워크의 효율성을 증대시키는 알고리즘  
👉 작은 패킷을 가능한 모아서 한번에 큰 패킷으로 전송하는 매커니즘  
　　👋 데이터를 보낸 후 ACK가 돌아올 때 까지 Buffer에 데이터를 쌓아 한번에 보내는 매커니즘  
　　👋 다중 캡슐화 및 역캡슐화를 방지  
　　👋 전송 속도가 늦어질 수 있음  

<br>
<br>

# 💚 Additional

## 캡슐화(Encapsulation)
👉 송신 데이터에 필요한 정보 즉, 헤더를 붙여 하위 계층으로 보내는 기술  

<br>

## 역캡슐화(Decapsulation)
👉 캡슐화의 반대되는 개념으로 헤더를 제거하고 상위 계층으로 보내는 기술  

<br>

## Throughput
👉 송신자와 수신자 사이에서 bit를 전송할 수 있는 평균 rate  

<br>

## Subnet Mask
👉 네트워크를 여러 개의 서브 네트워크로 나누기 위해 필요한 개념  
　　👋 IP 주소를 효율적으로 사용하기 위함  
👉 브로드캐스트 주소 : 해당 서브 네트워크 범위 내의 가장 큰(마지막) 주소  
👋 ex1)
```
IP : 192.168.188.131 // 11000000 10101000 10111100 10000011
Subnet Mask : 255.255.255.0 // 11111111 11111111 11111111 00000000
Network : 192.168.188.0 // 11000000 10101000 10111100 00000000
Broadcast : 192.168.188.255 // 11000000 10101000 10111100 11111111
```  
👋 ex2)
```
IP : 192.168.188.131 // 11000000 10101000 10111100 10000011
Subnet Mask : 255.255.255.128 // 11111111 11111111 11111111 10000000
Network : 192.168.188.128 // 11000000 10101000 10111100 10000000
Broadcast : 192.168.188.255 // 11000000 10101000 10111100 11111111
```  
👋 ex3)
```
IP : 192.168.16.1 // 11000000 10101000 00010000 00000001
Subnet Mask : 255.255.255.224 // 11111111 11111111 11111111 11100000
Network : 192.168.16.0 // 11000000 10101000 00010000 00000000
Broadcast : 192.168.16.31 // 11000000 10101000 00010000 00011111
```  
👋 ex4)
```
IP : 192.168.188.120 // 11000000 10101000 10111100 01111000
Subnet Mask : 255.255.255.128 // 11111111 11111111 11111111 10000000
Network : 192.168.188.0 // 11000000 10101000 10111100 00000000
Broadcast : 192.168.188.127 // 11000000 10101000 10111100 01111111
```  
👋 ex5)
```
IP : 192.168.188.51 // 11000000 10101000 10111100 00110011
Subnet Mask : 255.255.255.252 // 11111111 11111111 11111111 11111100
Network : 192.168.188.48 // 11000000 10101000 10111100 00110000
Broadcast : 192.168.188.51 // 11000000 10101000 10111100 00110011
```  

<br>

## 공인 IP 🆚 사설 IP
👉 공인 IP  
　　👉 전 세계적으로 중복이 되지 않은 고유한 번호  
　　👉 개인이 자유롭게 할당할 수 없고 ISP가 제공하는 IP 주소  
　　👋 외부에서 접근이 가능  
👉 사설 IP  
　　👉 한정된 범위 내에서만 사용하는 IP 주소  
　　👉 IPv4의 부족으로 모든 네트워크가 공인 IP를 사용할 수 없기에 네트워크 안에서 라우터를 통해 할당받는 가상의 주소  
　　👋 외부에서 이 주소로 통신할 수 X  
　　👋 NAT 등을 사용해 주소를 변환하여 통신  
✋ ISP : 인터넷 접속 서비스 등을 제공하는 회사  
✋ NAT : 사설 IP를 공인 IP로 변경하는데 사용하는 통신망의 주소 변환기  

<br>

## IPv4 ➡️ IPv6 제거된 헤더 필드
👉 헤더 체크섬, 헤더 길이, 식별자, 플래그, 단편화 옵셋  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>