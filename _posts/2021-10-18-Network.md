---
layout: page
title:  "Network"
subtitle: "Computer Science of Network"
date:   2021-10-18 11:11:11 +0530
categories: ["CS"]
comments: true
---
## Protocol
👉 형식, 네트워크 송수신 메세지의 순서 등을 미리 정하는 것(약속하는 것)  

<br>

## Throughput
👉 송신자와 수신자 사이에서 bit를 전송할 수 있는 평균 rate  

<br>

## OSI 5계층
👉 응용 계층, 전송 계층, 네트워크 계층, 데이터링크 계층, 물리 계층  
👋 표준, 일반적으로 많이 쓰임  

<br>

## OSI 7계층
👉 응용 계층, 표현 계층, 세션 계층, 전송 계층, 네트워크 계층, 데이터링크 계층, 물리 계층  
👋 통신사 내부관리용으로 많이 쓰임  

<br>

## Why Layering?
👉 정해진 계층 구조에 따라 모듈화 과정을 거쳐 trouble shooting에 용이  
👉 최적화 측면에서는 불리할 수 있음  
👋 packet header의 overhead  

<br>

## OSI Layer
👉 응용 계층  
　　👉 사용자와 가장 가까운 계층  
　　👉 우리가 사용하는 응용 서비스, 프로세스가 이 계층에서 동작함  
　　👋 HTTP, SMTP  
👉 표현 계층  
　　👉 전송 데이터의 구문과 의미에 대한 처리를 담당하는 역할  
　　👋 SSL  
👉 세션 계층  
　　👉 송수신 프로세스 사이의 세션의 확립 및 유지, 종료를 담당하는 역할  
👉 전송 계층  
　　👉 양 끝단의 사용자들이 신뢰성 있는 데이터를 주고 받게 하는 역할  
　　👉 흐름 제어, 오류 제어 기능이 있음  
　　👋 TCP, UDP  
👉 네트워크 계층  
　　👉 목적지까지 가장 안전하고 빠르게 데이터를 전송하는 기능인 라우팅을 담당함  
　　👋 IP, ICMP  
👉 데이터링크 계층  
　　👉 물리계층에서 송수신되는 정보의 오류와 흐름을 관리하여 안전하게 정보의 전달을 수행할 수 있도록 돕는 역할  
👉 물리 계층  
　　👉 데이터를 물리 매체 상으로 전송하는 역할  

<br>

## HTTP(HyperText Transfer Protocol)
👉 인터넷에서 데이터를 주고 받을 수 있는 프로토콜  
👉 Stateless, Connectionless 특징  
👉 약점을 보완하기 위해 쿠키 및 세션을 사용  
👋 Stateless : 이전 데이터를 유지하지 X  
👋 Connectionless : 요청에 맞는 응답을 보낸 후 연결을 끊음  
　　👉 non-persistent connection 방식  
　　　　👉 최대 한 개의 object만 TCP connection에 전송  
　　　　👉 여러 개의 object를 다운로드하려면 여러 connection이 필요  
　　👉 persistent connection 방식  
　　　　👉 여러 개의 object가 TCP connection을 통해 전송될 수 있음  

<br>

## HTTP status code
👉 1XX : 요청을 받았으며 작업을 계속함  
👉 2XX : 요청을 성공적으로 처리함  
👋 200 // OK  
👉 3XX : 요청을 마치기 위해 추가 동작이 필요함  
👉 4XX : 클라이언트 오류, 요청이 올바르지 X  
👋 400, 404 // Bad Request, Not Found  
👉 5XX : 서버 오류, 올바른 요청이었지만 서버가 응답할 수 X  
👋 502, 505 // Bad Gateway, HTTP Version Not Supported  

<br>

## HTTP 0.9
👉 최초의 HTTP  
👉 1.0의 이전 버전을 의미 (실존 X)  
👉 한 줄로 요청이 가능한 원라인 프로토콜  

<br>

## HTTP 1.0
👉 해당 버전부터 자세한 정보를 담기 시작  
👋 0.9는 단순 하이퍼텍스트를 전송하는 것에 집중  
👉 1. 버전 정보를 요청 정보에 포함  
👉 2. 응답 결과를 응답 정보에 포함  
　　👋 200, 404 등  
👋 3. 통신을 헤더와 바디로 분리  
　　👋 메타 데이터 전송 허용, 프로토콜 확장 가능성 확보  
👋 4. 새로운 헤더 정보를 통해 HTML의 다른 문서들의 전송도 가능하도록 기능을 추가  

<br>

## HTTP 1.1
👉 첫 번째 표준 프로토콜  
👉 여러 추가 기능이 있음  
👋 HTTP/1.0은 초창기 여러 버전으로 구현되기 시작  
👋 그 중 하나가 1.0이고 이보다 좋은 것을 1.1로 채택  
👉 1. 커넥션 재사용 가능  
👉 2. 파이프라이닝 추가  
　　👋 첫 요청에 대한 응답이 전송되기 전에 후속 요청 가능  
👉 3. Chunk된 응답 지원  
　　👋 한 번 응답 시 모든 정보 담지 않고 분할 응답 가능  
👉 4. 캐시 제어 메커니즘 도입  
👋 5. 언어, 인코딩, 타입을 포함한 콘텐츠 협상 도입  
　　👋 클라이언트와 서버로 하여금 교환하려는 가장 적합한 콘텐츠에 대한 동의를 가능  
👋 6. 헤더의 Host 정보로 인해 동일 IP 주소에 다른 도메인을 호스트하는 기능 가능  
👉 조금 느림.. why?  
　　👉 1. 연결당 하나의 요청과 응답을 처리 // 동시 전송 문제  
　　👉 2. HOL Blocking // 특정 응답 지연  
　　👉 3. RTT 증가 // 양방향 지연  
　　👉 4. 헤더가 큼 // 쿠키로 인해  

<br>

## HTTP 2.0
👉 성능 개선에 초점  
👉 1. 한 커넥션에 여러 개의 메시지를 주고 받을 수 O  
👉 2. 요청이 커넥션 상에 다중화되므로 HOL Blocking 발생 X  
👉 3. 헤더 정보 HPACK 압축 방식을 이용하여 압축 전송  
👉 4. 페이지 로딩 속도 향상  
👉 5. 프로토콜 협상 메커니즘  
　　👋 HTTP/1.1, HTTP/2.0, 기타 선택  
👉 6. HTTP/1.1과의 높은 호환성  
👋 7. 요청 리소스간 의존 관계를 설정  
👋 8. HTML문서 상에 필요한 리소스를 클라이언트 요청없이 보내줄 수 O  

<br>

## HTTP 3.0
👉 TCP 기반이 아닌 UDP QUIC를 사용하여 통신하는 프로토콜  
👉 1. 딜레이 감소  
👉 2. 멀티플렉싱 지원  
👉 3. 네트워크 스위칭 속도 개선  
👉 HTTP/2.0 보다 빨라짐  
👋 QUIC : 전송 계층 통신 프로토콜  
👋 멀티플렉싱 : 커넥션 상에 요청 다중화  

<br>

## HOL(Head-Of-Line) Blocking
👉 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상  

<br>

## HTTPS(HTTP over SSL)
👉 HTTP에 데이터 암호화가 추가된 프로토콜  
👉 서버와 클라이언트 사이의 모든 통신 내용이 암호화  
👉 공개키/개인키 암호화 방식  

<br>

## 공개키/개인키 암호화 방식
👋 공개키 : 누구에게나 공개가 가능한 키  
👋 개인키 : 개인만이 알고 있어야 하는 키  
👉 데이터 ➕ 공개키 ➡️ 암호화  
👉 암호화 ➕ 개인키 ➡️ 데이터  
　　👉 공개키 암호화, 개인키로만 열 수 있어 안전  
👉 데이터 ➕ 개인키 ➡️ 암호화  
👉 암호화 ➕ 공개키 ➡️ 데이터  
　　👉 개인키 암호화, 공개키로 열린다면 개인키와 매칭됨을 알 수 있어 신뢰성을 보장  

<br>

## HTTPS 동작 과정
👉 Server 측, HTTPS 적용 위해 공개키/개인키 발급  
👉 Server ➡️ CA, 비용을 지불하여 공개키 저장 인증서 발급 요청 
👉 CA 측, CA의 이름 & Server 공개키 & Server 정보 등을 포함하여 CA의 개인키를 통해 인증서 생성  
👉 CA ➡️ Server, 생성한 인증서를 Server에 발급  
👉 Client ➡️ Server, 특정 요청 발생  
👉 Server ➡️ Client, 인증서 제공  
👉 Client 측, CA 공개키를 이용해 인증서를 복호화하여 Server 공개키 획득  
👉 Client ➡️ Server, Server 공개키로 암호화하여 데이터 전송  
👉 Server 측, Server 개인키로 복호화하여 데이터 수신  

<br>

## CA(Certificate Authority)
👉 인증서를 발급하는 기관  
👉 공인된 인증 기관이라면, Browser에는 CA 리스트와 공개키가 내부에 저장되어 있음  

<br>

## SSL(Secure Socket Layer)
👉 공개키 방식과 공개키 방식이 느리다는 단점을 보완한 대칭키 방식을 모두 사용  
👋 대칭키 : 동일한 키 하나로 암호화와 복호화 모두 할 수 있음  
　　👉 매번 랜덤으로 생성되어 다음 번에 사용할 수 없음  
　　👉 안전하고 빠르다는 장점이 있음    

<br>

## 브라우저에 www.google.com을 입력할 경우, 동작 과정
👉 브라우저는 캐싱된 DNS 기록들을 통해 입력한 URL 주소에 대응하는 IP 주소가 있는지 확인함  
👉 캐시에 존재하지 않는다면, 사용자가 입력한 URL 주소 중에서 도메인 네임 부분을 DNS 서버에서 검색함  
👉 DNS 서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달함  
👉 전달받은 IP 주소와 웹 페이지 URL 정보는 HTTP 프로토콜을 사용하여 HTTP Request 메시지를 생성함  
👉 생성된 HTTP Request 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송됨  
👉 도착한 HTTP Request 메시지를 통해 서버에서 요청을 처리하면 서버에서 다시 HTTP 프로토콜을 사용하여 HTTP Response 메시지를 생성함  
👉 생성된 HTTP Response 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송됨  
👉 도착한 HTTP Response 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환됨  
👉 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있음  

<br>

## DNS(Domain Name Service)
👋 Domain : 사람이 쉽게 기억하고 입력할 수 있도록 문자로 만든 인터넷 주소  
👋 Domain Name : 네트워크 상에서 컴퓨터를 식별하는 호스트명  
👉 호스트의 도메인 네임을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수핼할 수 있도록 개발된 시스템  
👋 The DNS is a hierarchical and decentralized naming system for computers, services, or other resources connected to the internet of a private notwork  
👋 Most prominently, it translates more readily memorized domain names to the numerical IP addresses needed for locating and identifying computer services  
👋 UDP를 사용  

<br>

## REST 구성 요소
👉 리소스, HTTP URI  
👉 리소스에 대한 행위, HTTP Method  
👉 리소스에 대한 행위의 내용, HTTP Message Payload  

<br>

## REST 특징
👉 Server-Client, Stateless, 캐쉬 처리 가능, 계층화, 인터페이스 일관성  
👉 HTTP 프로토콜을 따르는 모든 플랫폼에서 사용 가능  
👉 HTTP 프로토콜 인프라 그대로 사용하므로 별도 인프라 구축 필요 X  
👉 But, 사용할 수 있는 메소드가 4개로 한정적  
👉 Header 정보를 처리해야하므로 전문성이 요구  

<br>

## HTTP RESTful
👉 REST의 원리를 따르는 시스템을 의미  
👉 REST를 사용했다고 모두 RESTful하다 할 수 없음  
👉 REST API 설계 규칙을 올바르게 지켜야 함  
👉 이해하기 쉽고 사용하기 쉬운 REST API를 만들기 위함  

<br>

## REST API 설계 규칙
👉 1. 대문자보다는 소문자  
👉 2. URI에 파일 확장자는 포함하지 X  
👉 3. URI에 행위를 포함하지 X  
👉 4. URI는 동사보다 명사  
👉 5. 언더바 대신 하이픈을 사용  
👉 6. 마지막 슬래쉬를 포함하지 X  
👋 소확행, 동명, 언하, 마슬  

<br>

## 쿠키
👉 사용자의 브라우저에 저장되고, 통신할 때 HTTP 헤더에 포함되는 작은 텍스트 데이터 파일  
👉 이름, 값, 만료 기간, 도메인, 경로 정보가 있고 키와 값으로 구성되어 있음  
👉 동작 방식  
　　👉 클라이언트가 페이지를 요청  
　　👉 서버에서 쿠키를 생성  
　　👉 HTTP 헤더에 쿠키를 포함시켜 응답  
　　👉 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음  
　　👉 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄  
　　👉 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답  
👋 방문 사이트 로그인 저장 여부, 쇼핑몰 장바구니, 팝업 페이지 등  

<br>

## 세션
👉 쿠키를 기반하고 있으며 서버 측에서 관리  
👉 서버에서는 클라이언트를 구분하기 위해 세선 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지  
👉 동작 방식  
　　👉 클라이언트가 서버에 접속 시 세션 ID를 발급 받음  
　　👉 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음  
　　👉 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청  
　　👉 서버는 세션 ID를 전달 받아 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보를 가져와 사용  
　　👉 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답  
👋 로그인 같이 보안상 중요한 작업을 사용할 때  

<br>

## 쿠키 🆚 세션
👉 가장 큰 차이는 사용자의 정보가 저장되는 위치  
　　👉 쿠키는 서버의 자원을 사용하지 않지만, 세션은 서버의 자원을 사용  
👉 보안 면에서 세션이 더 우수, 요청 속도 면에서 쿠키가 더 빠름  
　　👉 1. 쿠키는 로컬에 저장되기 때문에 스니핑 등의 우려가 있지만 세션은 쿠키를 이용하여 세션 ID만 저장하고 그것으로 구분하여 서버에서 처리하기 때문  
　　👉 2. 쿠키는 그 자체에 정보가 있지만 세션은 정보가 서버에 있어 서버의 처리가 필요하기 때문  
👉 세션은 서버의 자원을 사용하기 때문에 무분별하게 사용할 경우 서버의 메모리가 감당할 수 없음  

<br>

## 캐시(Cache)
👉 리소스 파일들의 임시 저장소  
👉 같은 웹페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 됨  
👉 이전에 사용되었던 데이터는 다시 사용될 가능성이 높음  
👉 따라서, 다시 사용될 확률이 있는 데이터들을 빠르게 접근 가능하도록 저장소에 저장하여 페이지 로딩 속도를 개선  
👋 이미지, 비디오, 오디오, css, js 등  

<br>

## 3 way handshake
👉 TCP 통신으로 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정  
<br>
<img src="{{ '/assets/cs/cs_net_1.png' }}" style="width: 480px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## 4 way handshake
👉 TCP 통신의 네트워크 연결을 해제하는 과정  
<br>
<img src="{{ '/assets/cs/cs_net_2.png' }}" style="width: 600px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## Transaction Isolation Level(격리 수준)
👉 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준  
👉 DB는 트랜잭션이 ACID 특징과 같이 독립적인 수행을 하기 위해 필요  
👉 4가지의 레벨  
　　👉 레벨 0 : SELECT 문장이 수행되는 동안 해당 데이터에 공유 락이 걸리지 않는 레벨  
　　👉 트랜잭션에 처리 중인 혹은 아직 커밋이 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용하는 레벨  
　　👉 다른 사용자가 아직 완료되지 않은 트랜잭션이지만 해당 데이터를 읽을 수 있음  
　　👉 레벨 1 : SELECT 문장이 수행되는 동안 해당 데이터에 공유 락이 걸리는 레벨  
　　👉 트랜잭션에 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기함  
　　👉 완료하지 않은 트랜잭션에는 접근할 수 없으며 커밋이 이루어진 트랜잭션만 조회할 수 있음  
　　👉 레벨 2 : 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 공유락이 걸리는 레벨  
　　👉 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장  
　　👉 다른 사용자는 그 영역에 해당하는 데이터에 대한 수정이 불가능  
　　👉 레벨 3 : 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 공유락이 걸리는 레벨  
　　👉 완벽한 읽기 일관성 모드를 제공  
　　👉 다른 사용자는 그 영역에 해당하는 데이터에 대한 수정 및 입력이 불가능  
👉 낮은 단계의 격리 수준을 이용할 때 발생하는 현상  
　　👉 Dirty Read : 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 형상  
　　👉 Non-Repeatable Read : 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 두 쿼리의 결과가 상이하게 나타나는 비일관성 현상  
　　👉 Phantom Read : 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상  

<br>

## E-R Model
👉 개체-관계 모델  
👉 구조화된 데이터에 대한 일련의 표현  
👉 ERM 프로세스의 산출물 : E-R Diagram  

<br>

## DB 이중화
👉 물리적으로 떨어져 있는 여러 DB에 대해 로컬 DB의 변경된 내용을 원격 DB에 복제하고 관리하는 것  
👋 실시간 데이터 백업 및 서버 부하 분산을 위해  

<br>

## Oracle 🆚 MySQL
👉 Oracle RDBMS는 대용량에 성능을 최적화하였기 때문에 일반적으로 대기업에서 많이 쓰임  
👉 MySQL은 진입장벽이 낮고 단일 DB로 제한이 되어 있어 일반적으로 중소기업 혹은 개인이 쓰기에 적합  

<br>

## 무결성(Integrity) ✔️
👉 DB에서 저장된 값들에 대해 여러가지 제한을 통하여 데이터에 대한 신뢰를 보장하게 하여 일관성을 유지시켜주는 것  
　　👉 영역 무결성(Domain Integrity) : 자료형, 규칙과 제약, 값 범위 등을 제한  
　　👉 참조 무결성(Entity Integrity) : 기본 키와 참조 키 간의 관계가 항상 유지됨을 보장  
　　　　👉 관련된 테이블의 레코드 간의 관계를 유효하게 하는 규칙  
　　　　👉 사용자의 실수로 관련 데이터가 삭제 or 수정되는 것을 막아줌  
　　　　👉 설정조건 #1 : 기본 테이블에서 사용한 필드는 기본키 or 고유 인덱스가 설정되어 있어야 함  
　　　　👉 설정조건 #2 : 기본 테이블, 관계 테이블 둘 다 액세스 테이블  
　　　　👉 설정조건 #3 : 관계를 설정하는 테이블은 형식이 같아야 함  
　　　　👉 쉽게 얘기하자면 외래키 값은 NULL 혹은 참조 릴레이션의 기본키 값과 동일함을 의미  
　　👉 개체 무결성(Domain Integrity) : 테이블에 있는 모든 형들이 유일한 식별자를 가질 것을 요구  

<br>

## Key ✔️
👉 DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 속성을 뜻함  
　　👉 기본 키(Primary Key) : 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성 // 오직 한 개, NULL X, 중복 값 X  
　　　　👋 복합 키(Composite Key) : 둘 이상의 속성으로 구성된 기본 키  
　　　　👋 자연 키(Natural Key) : 실제로 어떤 개체가 가지고 있는 속성으로 구성된 키  
　　　　👋 대리 키(Surrogate Key) : 보안 혹은 성능 향상을 위해 사용되는 인공적이거나 합성적인 키, 인공 키라고도 함  
　　👉 후보 키(Candidate Key) : 특정 튜플을 유일하게 식별할 수 있는 최소한의 속성들의 집합으로 구성된 키 // 유일성 O, 최소성 O  
　　👉 대체 키(Candidate Key) : 후보 키가 둘 이상일때, 기본 키를 제외한 후보 키  
　　👉 슈퍼 키(Super Key) : 특정 튜플을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합으로 구성된 키 // 유일성 O, 최소성 X  
　　👉 외래 키(Foreign Key) : 참조되는 릴레이션의 기본 키와 대응되어 릴레이션 간의 참조 관계를 표현하는 중요한 도구  
　　👉 부분 키(Partial Key) : 약한 개체를 유일하고 최소로 구분해 낼 수 있는 키  
👋 유일성 : 특정 튜플을 바로 찾아낼 수 있는 고유한 속성을 의미  
👋 최소성 : 키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없는, 따라서 반드시 필요한 최소의 속성을 의미  

<br>

## DDL(Data Definition Language)
👉 DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어  
👉 즉, 스키마를 정의하거나 조작하기 위해 사용하는 언어  
👋 CREATE, ALTER, DROP // 생성, 변경, 삭제  

<br>

## DML(Data Manipulation Language)
👉 사용자로 하여금 데이터를 처리할 수 있게 하는 도구로써 사용자와 DBMS 간의 인터페이스를 제공  
👉 즉, 데이터를 조작하기 위해 사용되는 언어  
👋 SELECT, INSERT, DELETE, UPDATE // 검색, 삽입, 삭제, 변경  

<br>

## DCL(Data Control Language)
👉 데이터의 무결성, 보안 및 권한 제어, 회복 등을 하기 위해 사용되는 언어  
👉 즉, 데이터를 보호하고 관리하는 목적으로 사용하는 언어  
👋 COMMIT, ROLLBACK, GRANT, REVOKE // 신규 적용, 이전 복원, 권한 부여, 권한 취소  

<br>

## DQL(Data Query Language)
👉 SELECT 만을 따로 분리해서 쿼리로 표현하는 유형  

<br>

## TCL(Transaction Control Language)
👉 COMMIT, ROLLBACK 만을 따로 분리해서 표현하는 유형  

<br>

## 인덱스(Index) ✔️
👉 추가적인 쓰기 작업과 저장 공간을 활용하여 DB 테이블 검색 속도를 향상시키기 위한 자료구조  
👉 1. Hash Table  
　　👉 칼럼의 값으로 생성된 Hash를 기반으로 인덱스를 구현  
　　👉 장점은 검색이 매우 빠름 (시간 복잡도 O(1))  
　　👉 단점은 연속적인 데이터를 위한 순차 검색이 불가능 (부등호 <, >)  
👉 2. B+ Tree  
　　👉 자식 노드가 2개 이상인 B Tree를 개선한 자료구조  
　　👉 leaf node들은 LinkedList로 연결되어 있어 순차 검색이 용이함  
　　👉 검색이 Hash Table보단 늦음 (시간 복잡도 O(logn))  

<br>

## 왜 Hash Table 대신 B+ Tree를 흔히 사용?
👉 Hash Table은 모든 값이 정렬되어 있지 않아 특정 기준보다 크거나 작은 값을 쉽게 찾을 수 없음  
👉 따라서, 기준 값보다 크거나 작은 요소들을 항상 탐색할 수 있어야 하는 DB 인덱스로 B+ Tree가 더 자주쓰임  

<br>

## 왜 B+ Tree를 사용? 다른 자료구조?
👉 시간적인 성능에서 뛰어나거나 혹은 검색에 있어 시간적인 성능이 떨어져도 결국 삽입 및 삭제를 포함한 종합적인 성능에서 B+ Tree가 우수  

<br>

## 인덱스(Index) 관리
👉 인덱스가 적용된 칼럼에 INSERT, DELETE, UPDATE가 수행된다면  
　　👉 INSERT : 새로운 데이터에 대한 인덱스를 추가  
　　👉 DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행  
　　👉 UPDATE : 기존의 인덱스를 사용하지 않음을 처리, 갱신된 데이터에 대한 인덱스를 추가  
⚠️ 기존의 인덱스를 '삭제'하는 것이 아닌 '사용하지 않음'을 처리함에 주의  
⚠️ 따라서, 인덱스를 사용함으로써 성능이 향상될 수 있지만, INSERT/DELETE/UPDATE가 빈번한 속성에 인덱스를 적용할 경우 인덱스의 크기가 비대해지기에 성능이 오히려 저하되는 역효과가 일어날 수 있음  

<br>

## DB 정규화 ✔️
👉 관계형 DB에서 중복을 최소화하기 위해 데이터를 구조화하는 작업  
👉 제 1 정규화  
　　👉 테이블에 칼럼이 **원자 값**을 갖도록 테이블을 분해  
<br>
<img src="{{ '/assets/cs/cs_db_1.png' }}" style="width: 350px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 제 2 정규화  
　　👉 제 1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해  
　　👋 **완전 함수 종속** : 기본 키의 부분 집합이 결정자가 되어선 X  
<br>
<img src="{{ '/assets/cs/cs_db_2.png' }}" style="width: 420px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 제 3 정규화  
　　👉 제 2 정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해  
　　👋 **이행적 종속** : A ➡️ B & B ➡️ C이면, A ➡️ C
<br>
<img src="{{ '/assets/cs/cs_db_3.png' }}" style="width: 420px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 BCNF 정규화  
　　👉 제 3 정규화를 진행한 테이블에 대해 **모든 결정자**가 **후보키**가 되도록 테이블을 분해  
<br>
<img src="{{ '/assets/cs/cs_db_4.png' }}" style="width: 420px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## 정규화 장점과 단점
👉 DB 변경시 발생하는 **이상 현상**들을 해결할 수 있음  
👉 연동 프로그램에 최소한의 영향만 미치게 만들어 응용 프로그램 수명 연장  
👉 But, 릴레이션 간의 연산(JOIN)이 많아져 응답 시간이 느려질 수 있음  

<br>

## Join
👉 두 개 이상의 테이블이나 DB를 연결하여 데이터를 검색하는 방법  
👋 INNER, LEFT, RIGHT, FULL Join // 교집합, 왼쪽 테이블 기준, 오른쪽 테이블 기준, 합집합  

<br>

## 이상 현상(Anomaly) ✔️
👉 논리적 오류가 발생하여 데이터 조작시 불일치가 발생하는 현상  
👉 삽입 이상 : 튜플 삽입시 의도하지 않은 자료까지 삽입해야만 테이블에 추가가 가능한 현상  
👉 삭제 이상 : 튜플 삭제시 유용한 다른 정보까지 삭제되어버리는 현상  
👉 갱신 이상 : 튜플 수정시 중복된 데이터의 일부만 수정되어 데이터 모순이 일어나는 현상  

<br>

## DB Lock
👉 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구  
👉 공유 락(Shared Lock) : 트랜잭션이 읽기를 할 때 사용되는 락  
　　👉 데이터를 읽을수는 있지만 쓸 수 없음  
👉 배타 락(Exclusive Lock) : 트랜잭션이 읽고 쓰기를 할 때 사용되는 락  
　　👉 데이터를 읽고 쓸 수 있음  

<br>

## DB Deadlock
👉 여러 개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태  
👉 예방 기법  
　　👉 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 락킹  
　　👉 But, 데이터가 많이 필요하면 모든 데이터를 락킹해야해서 트랜잭션의 병행성을 보장하지 X  
　　👉 또한, 몇몇의 트랜잭션은 계속 처리를 못하게 되는 **기아 상태**가 발생할 수 있음  
👉 회피 기법  
　　👉 Wait-Die : 다른 트랜잭션이 데이터를 점유하고 있을 때, 기다리거나 포기하는 방식  
　　👉 Wound-Wait : 다른 트랜잭션이 데이터를 점유하고 있을 때, 빼앗거나 기다리는 방식  
👉 탐지 기법  
　　👉 Union-Find를 이용하여, 사이클이 존재하는지 여부로 교착 상태를 알 수 있음  

<br>

## Hint
👉 SQL을 튜닝하기 위한 지시구문  
👉 옵티마이저가 최적의 계획으로 SQL문을 처리하지 못하는 경우 개발자가 직접 최적의 실행 계획을 제공하는 것  

<br>

## Clustering
👉 여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식  
👉 동기 방식으로 노드들 간의 데이터를 동기화  
👉 1개의 노드가 죽어도 다른 노드가 살아있어 시스템을 장애 없이 운영할 수 있음  
👉 여러 노드들 간의 데이터를 동기화 하는 시간이 필요하므로 리플리케이션에 비하면 성능이 낮음  

<br>

## Replication
👉 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식  
👉 비동기 방식으로 노드들 간의 데이터를 동기화  
👉 비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없음  
👉 노드들 간의 데이터가 동기화 되지 않아 일관성 있는 데이터를 얻지 못할 수 있음  

<br>

## 커넥션 풀
👉 일정량의 커넥션 객체를 미리 만들어 pool에 저장하는 기법  
👉 프로그램 요청이 들어오면 커넥션 객체를 빌려주고, 해당 객체의 임무가 완료되면 다시 반납 받아 pool에 저장  
👉 불필요하게 커넥션을 생성하고 삭제하는 일이 사라져서 이와 관련된 비용을 줄여 성능 향상에 도움이 됨  
👋 커넥션 : DB 연결 객체  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>