---
layout: page
title:  "iOSML"
subtitle: "Computer Science of iOS & ML"
date:   2022-08-15 11:11:11 +0530
categories: ["CS"]
comments: true
---
# 💛 Swift

## map

👉 컬렉션이 보유한 각 값을 매개변수를 통해 전달받은 함수에 적용한 후 새로운 컬렉션을 반환  

<br>

## filter

👉 컬렉션이 보유한 값 중 매개변수 함수 결과가 True인 값만 새로운 컬렉션에 넣어 반환  

<br>

## reduce

👉 초기값에 컬렉션이 보유한 각 값들을 매개변수로 전달받은 함수의 연산 결과로 모든 값을 계산함  

<br>

## compactMap

👉 컬렉션이 보유한 각 값들을 매개변수로 전달받은 함수에 적용한 후 해당 값이 nil이 아닌 값들만 새로운 컬렉션에 넣어 반환함  

<br>

## flatMap

👉 매개변수로 전달받은 함수가 또 다른 컬렉션을 생성하는 경우 이를 1차원의 컬렉션으로 만들며, 해당값이 nil이 아닌 경우만 새로운 컬렉션에 넣어 반환함  

<br>

## compactMap 🆚 flatMap

👉 기존의 flatMap의 경우에는 배열을 flatten하게 만들고, nil을 제거, 옵셔널 바인딩을 하는 역할  
👉 Swift 4.1부터는 1차원 배열에서 nil을 제거하고 옵셔널 바인딩을 하고 싶을때는 compactMap을 사용  
👉 flatMap은 2차원 배열을 1차원 배열로 flatten하게 만들지만, compactMap은 1차원 배열로 만들지 않음  
👉 nil이 포함된 2차원 배열에서 flatmap과 compactmap을 순서대로 체이닝 연결하면 1차원 배열로 nil을 제거하고 옵셔널 바인딩을 해줄 수 있음  
👉 1차원 배열에서는 동일한 결과  

<br>

## Swift의 sort() 구현 방식?

👉 Insertion Sort와 Merge Sort가 합쳐진 형태인 Tim Sort로 구현되어 있음  
👉 시간 복잡도 : 최선의 경우 O(n), 최악의 경우 O(nlogn)  

<br>

## Any 🆚 AnyObject

👉 Any와 AnyObject는 모든 타입과 클래스 타입을 저장할 수 있다는 특징을 갖고 있음  
👉 Any는 함수 타입을 포함한 모든 타입의 인스턴스를 나타낼 수 있는 프로토콜  
👉 반면, AnyObject는 클래스 타입의 인스턴스만을 나타낼 수 있는 프로토콜  

<br>

## Optional

👉 nil의 허용 여부를 나타내는 것, ? 키워드로 옵셔널을 표시함  

<br>

## Struct 🆚 Class 🆚 Enum

👉 struct와 enum은 값 타입의 인스턴스를 가지지만, class는 참조 타입의 인스턴스를 가짐  
👉 struct와 enum은 상속이 불가능하지만, class는 상속이 가능  
👉 struct와 class는 생성자가 있지만, enum에는 생성자가 없음  

<br>

## Swift Method

👉 Instance Method  
　　👉 클래스를 실체화하여 생성된 인스턴스를 통해 호출할 수 있는 메서드  
👉 Type Method  
　　👉 인스턴스의 생성 없이 타입 자체에서 바로 호출할 수 있는 메서드  
　　👉 Static Method  
　　　　👉 subclass에서 오버라이딩이 불가능한 메서드  
　　👉 Class Method  
　　　　👉 subclass에서 오버라이딩이 가능한 메서드  

<br>

## class 성능 향상 방법

👉 상속이 없는 클래스는 final로 선언하기  
　　👉 class 성능 향상은 Dispatch 과정 관련  
　　👉 Dispatch? 어떠한 메서드를 실행하여 처리할지 결정하는 과정  
　　👉 Dispatch 종류?  
　　　　👉 Static Dispatch : 컴파일 시점에 어떤 메서드가 사용될 지 결정  
　　　　👉 Dynamic Dispatch : 런타임 시점에서 어떤 메서드가 사용될 지 결정  
　　　　　　👉 Dynamic Dispatch는 참조에 따라 함수를 호출하기 때문에 overhead가 발생  
　　　　　　👉 이러한 overhead는 class가 상속이 가능하여 override 될 수 있는 메서드에서 발생  
　　　　　　👉 만약, override가 확실히 되지 않음을 컴파일러에게 알려주면 overhead가 없어지면서 성능이 향상  
👉 외부 접근이 없는 경우 private 키워드 사용하기  
　　👉 private 키워드 사용 시, 컴파일러가 파일 내부에서만 override 여부를 판단하면 되기 때문에 final 키워드를 컴파일러가 추론하여 적용할 수 있어 final과 동일한 이유로 성능이 향상  
👉 변수 선언 시 타입을 지정하기  
👉 변경이 없는 변수는 let 키워드를 사용하기  

<br>

## 탈출 클로저

👉 @escaping 키워드가 붙은 클로져  
👉 함수가 리턴된 후 함수의 스코프 밖에서 실행시키는 클로져로, 함수의 매개변수로 클로져를 전달하는 방식  
👉 함수가 리턴된 후에도 클로져를 실행할 수 있어 비동기 작업이 가능하게 해준다는 특징이 있음 

<br>

## Property Wrapper

👉 프로퍼티를 구현할 때 반복적으로 사용되는 패턴을 줄이기 위해 사용  
👉 반복되는 로직들을 프로퍼티 자체에 연결하는 방식  
👉 wrappedValue를 반드시 필요로 함  

<br>

## Result

👉 성공과 실패에 대한 결과 값을 반환하고 싶은 경우 사용하는 타입  
👉 Result 타입은 enum이며, 두 개의 제네릭한 결과를 리턴하고 이 때 Failure은 Error를 상속받은 타입이어야 함  
👉 Success 타입은 void, string, int 등 값 타입을 사용해도 됨  

<br>

# Codable

👉 자신을 외부 표현으로 인코딩할 수 있는 유형인 Encodable과 외부 표현으로부터 자신을 디코딩할 수 있는 유형인 Decodable로 구성된 타입  
👉 주로, API에서 JSON Data를 받아와 이 중 필요한 데이터를 모델로 정리한 Struct, Class 혹은 Enum을 작성할 때 사용  

<br>

# CodingKey

👉 Codable 프로토콜에서 주로 JSON Key를 사용자가 정의한 프로퍼티에 매핑하기 위해 사용하는 프로토콜  
👉 ex)  
```swift
struct Coffee: Codable {
        var name: String

        enum CodingKeys: String, CodingKey {
                case name = "order_Drink_Name"
        }
}
```  

<br>

# Copy On Write

👉 데이터 복사 시 실제로 값을 복사하지 않고, 동일한 값을 참조하다가 데이터 변경이 발생될 시 값을 복사해 변경하는 기법  
👉 Collection Type을 복사해서 사용할 때 일어남  
👉 실제 변경이 발생할 때 복사를 하고 그 전엔 참조를 통해 불필요한 복사를 줄이는 매커니즘  
👉 기존의 메모리 낭비 및 오버헤드를 줄일 수 있다는 장점이 있지만, 생성되는 사본 수를 확인하기 위해 참조 횟수를 계산해야 한다는 단점이 존재  

<br>

# Swift init

👉 Designated init  
　　👉 Swift의 초기화 이니셜라이져로, 클래스의 모든 프로퍼티를 초기화시키는 역할  
　　👉 init 이라고도 불림  
👉 Convinience init  
　　👉 보조 이니셜라이져로, 일부 프로퍼티를 원하는 값으로 저장하는 역할을 하기에 C.i. 내부에서 반드시 D.i.를 호출해야 함  

<br>

## init 메소드 .(dot)연산자 가능한지?

👉 객체가 초기화도 되어 있지 않기 때문에 getter 메소드를 호출할 수 없음  

<br>

# Subscripts

👉 컬렉션, 리스트 시퀀스 등 집합의 특정 요소에 간단하게 접근할 수 있는 문법  
👉 배열의 인스턴스는 인덱스를 통해, 딕셔너리의 인스턴스는 키 값을 통해 접근  
👉 인스턴스 메소드와 다른 점은 read-write 혹은 read-only만 가능  
👉 ex)
```swift
var dict = ["Kim": 1, "Lee": 2]
dict["Park"] = 3 // Subscript 문법

var arr = [3, 2, 4, 8]
arr[0] = 1 // Subscript 문법
print(arr[0]) // Subscript 문법
```  

<br>

# String Subscripts

👉 string은 character의 collection이며, character는 각각 다른 크기의 메모리를 차지할 수 있는 유니코드를 준수하고 있기 때문에, Subscript로 접근 할 수 없음  

<br>

# KVC 🔥

👉 Key-Value Coding  
👉 객체의 값을 직접 가져오지않고, Key 또는 KeyPath를 이용해서 간접적으로 데이터를 가져오거나 수정하는 방법  
👋 [Link][Link6]  

<br>

# KVO 🔥

👉 Key-Value Observing  
👉 객체의 프로퍼티의 변경사항을 다른 객체에 알리기 위해 사용하는 코코아 프로그래밍 패턴  
👉 NSObject를 상속한 클래스에서만 KVO를 사용할 수 있음  
👉 Model과 View와 같이 논리적으로 분리된 파트간의 변경사항을 전달하는데 유용  
👋 [Link][Link7]  

<br>

# Delegate 🆚 Notification

👉 두 방식 모두 객체가 서로 종속되지 않고 소통하기 위해 만들어짐  
👉 Deleagate  
　　👉 프로토콜을 정의하고 이를 대신 처리할 객체가 채택 및 구현하는 방식  
　　👉 주로 이벤트를 1:1로 전달할 때 많이 사용  
　　👉 제 3객 체를 필요로 하지 X, 확실한 처리 가능, 많은 줄의 코드 필요, 다수의 객체에게 이벤트를 알리고 싶을 경우 비효율적  
👉 Notification  
　　👉 싱글턴 객체인 NotificationCenter를 통해 이벤트 발생 여부를 addObserver한 객체들에게 post하는 방식  
　　👉 주로 이벤트를 1:N로 전달할 때 용이  
　　👉 Delegate 보다 적은 줄의 코드 필요, 다수의 객체에게 동시에 이벤트를 전달이 가능, 제 3 객체를 반드시 필요로 함, 컴파일 시점에 구독 여부를 확인하는 것이 불가능  

<br>

# Protocol

👉 최소한으로 가져야 할 속성이나 메서드를 정의만 하는 청사진 역할  
👉 프로토콜을 적용할 객체에, 프로토콜에서 정의했던 속성과 메소드를 반드시 모두 구현해야 함  

<br>

# 객체 지향 프로그래밍 🆚 프로토콜 지향 프로그래밍

👉 객체 지향 프로그래밍  
　　👉 상속을 통해 수직적으로 타입을 확장하는 구조  
　　👉 슈퍼클래스를 그대로 상속 받기에 필요 없는 메소드와 변수를 모두 물려 받아야 하는 단점  
　　👉 또한, 하나의 서브클래스는 하나의 슈퍼클래스만 가질 수 있음  
👉 프로토콜 지향 프로그래밍  
　　👉 프로토콜 확장을 통해 수평적으로 타입을 확장하는 구조  
　　👉 슈퍼클래스와 서브클래스 사이가 독립적이기에 필요 없는 메소드나 변수를 갖지 않게 할 수 있음  
　　👉 또한, 상속과는 다르게 다수의 프로토콜을 가지는 것이 가능  

<br>

# Hashable & Equatable

👉 Hashable  
　　👉 채택한 타입이 유일한 값으로 구분될 수 있도록 하는 프로토콜  
　　👉 내부의 hash function을 통해 해시 값을 결정  
　　👉 Hashable은 Equatable 프로토콜을 상속하고 있음  
　　　　👉 H가 E를 상속해야 하는 이유는, 객체의 동일 여부는 명확한 판단 기준을 필요로 하며, 어떤 기준으로 두 객체가 같다라고 말할 것인지 결정해야 함  
　　　　👉 Equatable : 값의 비교가 가능함을 보장해주는 프로토콜  
　　　　👉 ==, != 연산자를 정의하여 객체의 동일 여부의 기준을 결정함  
　　　　👉 즉, Equatable 프로토콜을 상속 받아 Hashable 타입이 객체의 동일 여부를 판단할 수 있도록 함  

<br>

# Mutating

👉 Swift에서 Class는 참조 타입이며, Struct와 Enum은 값 타입임  
👉 값 타입의 프로퍼티는 기본적으로 메서드 내부에서 수정할 수 없는데, 수정이 필요한 경우 Mutating 키워드를 사용하여 수정이 가능해 짐  
👉 이후, 메서드가 종료될 때 변경한 모든 내용을 원래 Struct 혹은 Enum에 기록  

<br>

# Extension

👉 이미 존재하는 클래스, 구조체, 열거형 혹은 프로토콜 타입에 새로운 기능을 추가하는 것  
👉 원본 소스 코드에 접근할 수 없는 유형을 확장하는 기능도 포함되어 있음  
👉 연산 프로퍼티, instance/type method, 프로토콜 등을 추가할 수 있음  
👉 extension 내부에서 함수 오버라이딩 가능한지?  
　　👉 해당하는 메소드가 Objective-C와 호환되는 경우 오버라이딩이 가능은 하지만, 일반적으로 권장되는 방법은 아님  
　　👉 그 이유는, extension은 추가적인 기능의 확장을 사용하는 개념이기 때문  

<br>

# Swift Access Control(접근 제어자)

👉 open  
　　👉 모듈 외부에서 access가 가능  
👉 public  
　　👉 open과 동일하지만 외부 상속과 override가 불가능  
👉 internal(default 값)  
　　👉 같은 모듈 안에서 access가 가능  
👉 fileprivate  
　　👉 같은 파일 안에서 access가 가능  
👉 private  
　　👉 같은 스코프 안에서 access가 가능  

<br>

# Defer

👉 함수 안에서 작성되는 클로저  
👉 작성된 위치와 상관없이 함수 종료 직전에 실행되는 구문  
👉 호출되는 순서  
　　👉 하나의 스코프에서 여러 defer를 사용할 경우 스택처럼 쌓임  
　　👉 가장 먼저 넣은 defer 코드가 가장 마지막에 호출됨  
　　👉 가장 마지막에 넣은 defer 코드가 가장 먼저 호출됨  
👉 defer를 호출되기 전에 해당 스코프가 종료(에러반환, 리턴 등)되거나, 리턴값이 Never(비반환)인 경우에는 defer가 호출되지 X  

<br>
<br>


# 💛 iOS

## App LifeCycle
👉 App의 실행 및 종료 등 시스템이 발생시키는 Event에 의해 App의 상태가 전환되는 일련의 과정을 뜻함  
👉 Not Running ➡️ Active  
　　👉 앱을 터치해서 실행이 되는 상태  
👉 Active ➡️ Inactive ➡️ Background  
　　👉 앱을 활성화 상태에서 비활성화 상태로 만든 뒤, 백그라운드에서도 계속 실행 중인 상태  
👉 Active ➡️ Inactive ➡️ Suspended  
　　👉 앱을 활성화 상태에서 비활성화 상태로 만든 뒤, 백그라운드에서도 정지되어 있는 상태  
👉 Background ➡️ Active  
　　👉 백그라운드에서 실행 중인 앱이 다시 포어그라운드에서 활성화되는 상태  
<br>
👉 1. Not Running  
　　👉 실행되지 않았거나, 시스템에 의해 종료된 상태  
👉 2. Inactive  
　　👉 실행 중이지만 이벤트를 받고있지 않은 상태  
　　👉 ex) 앱 실행 중 미리 알림 혹은 일정 알림이 화면에 덮여서 앱이 실질적으로 이벤트는 받지 못하는 상태  
👉 3. Active  
　　👉 어플리케이션이 실질적으로 활동하고 있는 상태  
👉 4. Background  
　　👉 백그라운드 상태에서 실질적인 동작을 하고 있는 상태  
　　👉 ex) 백그라운드에서 음악을 실행  
👉 5. Suspend  
　　👉 백그라운드 상태에서 활동을 멈춘 상태  
　　👉 빠른 재실행을 위하여 메모리에 적재된 상태지만 실질적으로 동작하고 있지는 않는 상태  
　　👉 메모리가 부족할 때 시스템이 강제종료  
👋 [Link][Link1]  
👋 [Link][Link2]  
👋 [Link][Link3]  

<br>

👉 추가적으로,
👉 [앱이 foreground에 있을 때와 background에 있을 때 어떤 제약사항이 있나요?](https://github.com/lunchScreen/Interview_Questions/issues/42)
👉 Foreground 는 애플리케이션이 클라이언트에게 보여지고 있는 상태로 메모리 및 시스템 리소스에 높은 우선 순위를 가지고 있습니다.
👉 Background 는 앱이 백그라운드에 있지만 여전히 실행되고 있는 상태를 말함.
👉 앱이 백그라운드에 있을 땐 가능한 적은 메모리공간을 사용해야 하기 때문에 사용자의 이벤트를 받기 어렵다는 특징이 있습니다.

<br>

## iOS 앱을 실행한다면?
!!!!!!!!!!!//사진1
<img src="{{ '/assets/cs/.png' }}" style="width: 600px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
<br/>

👉 main 함수가 실행됩니다.  
👉 main 함수는 UIApplicationMain 함수를 호출합니다.  
👉 UIApplicationMain은 UIApplication 인스턴스를 생성합니다.  
👉 그리고 Info.plist에서 필요한 데이터를 로드합니다. main Nib 파일을 여기서 찾아 로드합니다.  
👉 UIApplication은 AppDelegate 인스턴스를 생성하고 UIApplication을 위임합니다.  
👉 UIApplication은 RunLoop를 생성합니다.  
👉 준비가 완료되면 AppDelegate의 didFinishlaunchingWithOptions를 호출합니다.  
👉 세션에 대한 설정이 완료되면 SceneDelegate의 willConnectToSession이 호출됩니다.  
![image](https://user-images.githubusercontent.com/46087477/150353961-db9c84a8-2eb3-4d42-b108-690943f718de.png)

<br>

## iOS 12 이전 🆚 iOS 13 이후
👉 iOS 12 이전 동작 (Scene을 지원하지 않는 경우) ; SceneDelegate가 없음  
👉 UIkit은 모든 Life Cycle을 UIApplicationDelegate 객체에 전달한다.  
👉 AppDelegate는 앱의 모든 window를 관리한다.  
!!!!!!!!!!!//사진2
<img src="{{ '/assets/cs/.png' }}" style="width: 600px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
<br>
👉 iOS 13 이후 동작 (Scene을 지원하는 경우) ; SceneDelegate가 있음  
👉 Scene이란 개념이 생김으로써 동일한 앱 두개를 실행시킬 수 있게 됨  
: Scene을 지원하는 경우 UIKit은 Scene에 각각 별도의 Life Cycle을 전달. storyBoard의 Scene과는 개념이 살짝 다르니 혼동 x  
: 사용자는 각 앱에 대해 여러 Scene을 만들 수 있으며, 이를 별도로 보여주고 숨길 수도 있다.  
: 각 Scene마다 각자의 Life Cycle이 있기 때문에 각각 다른 상태에 있을 수 있다.  
: Scene Delegate는 Application Delegate와 같은 역할(앱의 Life Cycle 이벤트를 관리)  
: 사용자나 시스템이 앱에게 새로운 Scene을 요청하면 UIKit이 해당 Scene을 생성한다.  
!!!!!!!!!!!//사진3
<img src="{{ '/assets/cs/.png' }}" style="width: 600px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## UIApplicationMain()
👉 앱이 실행되면 시스템은 @UIApplicationMain을 통해 UIApplicationMain() 함수를 호출한다. (@을 붙이면 뒤의 키워드의 코드를 불러올 수 있다.)  
👉 UIApplicationMain() 함수를 통해 UIApplication 객체와 AppDelegate를 생성, 이벤트 Cycle을 설정함.  

<br>

## UIApplication()
👉 사진123  

<br>

## AppDelegate()
👉 사진123  

<br>

## UIResponder()
👉 UIResponder는 모든 UIView의 상위 객체이면서 이벤트를 받고 처리하거나 다른 UIResponder 객체에게 전달하는 역할을 합니다. UIKit은 first responder에게 발생한 이벤트를 전달하고 UIResponder는 해당 이벤트를 자신이 처리할 수 있다면 처리하고, 처리할 수 없다면 next 프로퍼티에 할당된 다음 Responder에게 전달합니다.  

<br/>

## 7. UIApplication 객체는 어떤 일을 하나요?

👉 UIApplication은 UIApplicationMain에서 만들어지는 싱글톤 객체입니다. UIApplication은 최초에 런루프를 만들고 AppDelegate에게 delegate를 위임합니다.  

<br/>

## 8. UIApplicationDelegate는 어떤 종류의 메서드들을 포함하고 있나요?

👉 앱을 시작하고 앱의 `생명주기`가 변화될 때마다 상황에 상응하는 메서드가 있습니다.  
👉 `백그라운드`에서 다운로드 작업이 진행되어야할 때의 메서드가 있습니다.  
👉 앱의 `Scene`이 새로 생성되거나 지워질 때 호출되는 메서드도 있습니다.  
👉 APN 등록처럼 앱의 실행이 시작되면서 등록해야하는 `서비스` 작업들에 대한 메서드가 있습니다.  

<br/>

## 9. 앱 생명주기와 관련된 UIApplicationDelegate 메서드를 말해보세요.

👉 [상태 변화에 따라 다른 동작을 처리하기 위한 앱델리게이트 메서드들을 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/81)  
👉 application:willFinishLaunchingWithOptions: 어플리케이션이 최초 실행될 때 호출되는 메소드  
👉 application:didFinishLaunchingWithOptions: 어플리케이션이 실행된 직후 사용자의 화면에 보여지기 직전에 호출  
👉 applicationDidBecomeActive: 어플리케이션이 Active 상태로 전환된 직후 호출  
👉 applicationWillResignActive: 어플리케이션이 Inactive 상태로 전환되기 직전에 호출  
👉 applicationDidEnterBackground: 어플리케이션이 백그라운드 상태로 전환된 직후 호출  
👉 applicationWillEnterForeground: 어플리케이션이 Active 상태가 되기 직전에, 화면에 보여지기 직전의 시점에 호출.  
👉 applicationWillTerminate: 어플리케이션이 종료되기 직전에 호출  

<br/>

## 10. 앱이 In-Active 상태가 되는 시나리오를 설명하시오.

👉 [앱이 In-Active 상태가 되는 시나리오를 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/45)  
👉 사용자로부터 이벤트를 받지 못하는 상황에서 in-active 상태가 되는데, 대표적으로, 시리가 켜지거나 전화 수신, 배터리 부족 알림 등 이 있습니다.  

<br>

## 6. 앱이 시작할 때 UIApplicationMain 함수에 의해서 생성되는 객체는 무엇인가?

###
👉 [앱이 시작할 때 UIApplicationMain 함수에 의해서 생성되는 객체는 무엇인가?](https://github.com/lunchScreen/Interview_Questions/issues/82)  
👉 UIApplicationMain이 실행되면 `UIApplication` 이라는 싱글턴 객체가 생성됩니다.  
👉 또한 AppDelegate와 SceneDelegate 객체도 생성합니다.  
👉 마지막으로 앱의 루트가 되는 Window 객체를 생성하고 최초 뷰 컨트롤러를 할당합니다.  

👉 추가적으로,  
👉 [@Main에 대해서 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/141)  

<br>

## 4. 앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?

👉 [앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?](https://github.com/lunchScreen/Interview_Questions/issues/127)  
👉 `UIViewController`입니다. 뷰 컨트롤러는 UIKit으로 구성된 앱의 뷰 계층관계를 관리하고 뷰를 그리는 로직을 담고 있습니다.  

<br/>

## 56. UIViewController의 상위 클래스들을 모두 말하고 설명해주세요.
👉 UIViewController는 UIResponder를 상속하고, UIResponder는 NSObject를 상속합니다.  
👉 UIResponder는 이벤트를 받고 리스폰더 체인을 구성할 수 있게 합니다.  
👉 NSObject는 Objective-C의 루트 클래스로 NSObject를 상속해 Objective-C 런타임에 대한 인터페이스나 기능을 사용할 수 있도록 합니다.  

<br/>

## 20. 모든 View Controller 객체의 상위 클래스는 무엇이고 그 역할은 무엇인가?

👉 [모든 View Controller 객체의 상위 클래스는 무엇이고 그 역할은 무엇인가?](https://github.com/lunchScreen/Interview_Questions/issues/19)  
👉 UIViewController이며, UIViewController는 데이터 변경에 따라 뷰를 업데이트하고, 뷰에서 발생하는 사용자 이벤트와 상호작용하는 등의 역할을 갖고 있습니다.  
👉 UIViewController의 상위클래스는 UIResponder입니다.  
👉 UIResponder 앞에 있음 + 밑에 있음  

<br/>

## 22. View 객체에 대해 설명하시오.

👉 [View 객체에 대해 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/70)  
👉 View 객체는 UIView 클래스의 인스턴스로, 화면의 직사각형 영역에 콘텐츠를 관리하고 보여주는 역할을 하는 사용자 인터페이스의 기본 구성 요소라고 함.  
👉 View 객체는 사용자와 애플리케이션이 상호 작용하는 주요 방법이기 때문에 터치, 레이아웃 및 서브 뷰 관리, 이벤트 처리 등의 역할을 수행함.  
👉 UIbutton, UIImageView과 같은 모든 뷰 클래스의 상위 클래스입니다.  

<br/>

## 23. UIView 에서 Layer 객체는 무엇이고 어떤 역할을 담당하는지 설명하시오.

👉 [UIView 에서 Layer 객체는 무엇이고 어떤 역할을 담당하는지 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/31)  
👉 객체에 나타나는 콘텐츠들을 관리하는 CALayer 타입의 layer를 가지고 있습니다.  
👉 UIView는 이미지나 애니메이션들은 직접 제어하지 않고, View에게 작업을 주면 View 내부의 Layer객체에서 직접 수행을 하게 됩니다.  
👉 CA는 Core Animation 프레임워크의 약자로, UIKit보다 한단계 낮은 저수준의 인터페이스를 제공하는 프레임워크입니다.  

<br/>

## 24. UIWindow 객체의 역할은 무엇인가?

👉 [UIWindow 객체의 역할은 무엇인가?](https://github.com/lunchScreen/Interview_Questions/issues/43)  
👉 UIWindow는 직접적으로 시각적인 내용을 나타내지는 않지만 화면을 구성하는 모든 뷰들의 부모가 되는 컨테이너 역할을 하는 객체입니다.  

<br/>

## 25. UINavigationController의 역할이 무엇인지 설명하시오.

👉 [UINavigationController 의 역할이 무엇인지 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/44)  
👉 UINavigationController는 스택처럼 화면들을 쌓아서 화면 간 이동을 관리하는 컨테이너이며,  
👉 네비게이션 바에서는 뒤로 가기 버튼과 커스터마이징한 버튼을 추가할 수 있고, 옵션으로 툴바 뷰도 제공합니다  

<br/>

## 49. UIResponder에 대해 설명해주세요.
👉 UIResponder는 모든 UIView의 상위 객체이면서 이벤트를 받고 처리하거나 다른 UIResponder 객체에게 전달하는 역할을 합니다. UIKit은 first responder에게 발생한 이벤트를 전달하고 UIResponder는 해당 이벤트를 자신이 처리할 수 있다면 처리하고, 처리할 수 없다면 next 프로퍼티에 할당된 다음 Responder에게 전달합니다.  

<br/>

## 50. Responder Chain은 그럼 뭔가요?
👉 UIKit이 모든 UIResponder를 엮어서 관리하는 체인입니다. 각 리스폰더는 next프로퍼티로 자신의 다음 리스폰더를 참조하고 있습니다.  

<br/>

## 51. 그럼 기본적으로 클래스별로 이벤트가 전달되는 순서가 어떤지
👉 UIView, UIViewController, UIWindow, UIApplication, UIApplicationDelegate 순으로 이벤트가 전달됩니다. 만약 어떤 뷰나 뷰 컨트롤러가 상위뷰에 속해져있는 뷰라면 해당 뷰나 뷰 컨트롤러에 이벤트를 전달합니다.  

<br/>

## 52. Responder Chain을 임의로 변경하려면 어떻게 해야할까요?
👉 특정한 뷰의 next 프로퍼티를 오버라이딩해서 다음 리스폰더를 지정할 수 있고, becomeFirstResponder 메서드를 사용해서 특정한 뷰를 firstResponder로 만들 수 있습니다. 이때는 이벤트가 first responder에게 전달됩니다.   

<br/>

## 53. 그럼 이벤트는 어떤 형태로 전달되는지? 터치 이벤트는 다른게 있는지?
👉 이벤트는 UIEvent 객체로 전달됩니다. 터치 이벤트는 UITouch 객체로 관리되고 UIEvent 객체를 통해 접근할 수 있습니다. 터치 이벤트 객체는 터치된 시간, 터치된 영역, 터치 강도, 터치 위치 등의 정보를 포함하고 있습니다.  

<br/>

## 54. UIControl에서 이벤트가 발생하면 해당 이벤트를 처리하기까지의 과정을 설명해주세요.
👉 UIControl은 addTarget 메서드를 정의할 수 있게 합니다. 이때 target과 action을 인자로 전달할 수 있습니다. target은 어떤 객체이던지 들어갈 수 있지만 일반적으로는 이벤트를 처리할 뷰 컨트롤러를 지정합니다. 만약 target에 nil이 들어가면 UIControl은 발생한 이벤트에 대한 처리를 구현하고 있는 리스폰더를 리스폰더 체인을 통해 찾아냅니다.   
👉 action은 이벤트를 처리할 메서드에 대한 시그니처를 나타냅니다. 만약 이벤트가 발생하면 UIControl 객체는 이 메서드를 호출하고 UIApplication이 호출 메시지를 받아 리스폰더 체인에서 이 메서드를 찾아 이벤트를 전달합니다. @IBAction이 이런 메서드를 식별할 수 있도록 합니다.  

<br/>

## 45. UIControl에 대해서 설명해주세요.

👉 UIControl은 UIView를 상속받는 객체로 사용자의 인터렉션에 대한 기능을 제공합니다. UIControl은 상태 정보를 제공하고 addTarget으로 UIControl 객체에서 어떤 이벤트가 발생했을 때 처리할 메소드를 지정할 수 있습니다.

<br>

## View LifeCycle
![view life cycle](https://docs-assets.developer.apple.com/published/f06f30fa63/UIViewController_Class_Reference_2x_ddcaa00c-87d8-4c85-961e-ccfb9fa4aac2.png)
<br>
👉 [View 렌더링사이클에 대해서 설명해주세요](https://github.com/lunchScreen/Interview_Questions/issues/124)
👉 1. viewDidLoad()  
　　👉 뷰가 생성될 때, 가장 먼저 실행되는 메소드
　　👉 특별한 경우가 아니라면 딱 한 번 실행되기 때문에 초기화 할 때 사용 할 수 있음  
👉 2. viewWillAppear()  
　　👉 뷰가 생성되기 직전에 항상 실행이 되기 때문에 뷰가 나타나기 전에 실행해야 하는 작업들을 여기서 할 수 있습니다.  
👉 3. viewDidAppear()  
　　👉 뷰가 생성되고 난 뒤에 실행 됩니다.  
　　👉 데이터를 받아서 화면에 뿌려주거나 애니메이션 등의 작업을 하는 로직을 위치시킬 수 있습니다.  
　　👉 ViewWillAppear 에서 로직을 넣었다가 뷰에 반영이 안되는 경우가 있기 때문입니다.  
👉 4. viewWillDisappear  
　　👉 뷰가 사라지기 직전에 실행 됩니다.  
👉 5. viewDidDisappear()  
　　👉 뷰가 사라지고 난 뒤에 실행 됩니다.  
!!!!!!!!!!!//사진4
<img src="{{ '/assets/cs/.png' }}" style="width: 600px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
!!!!!!!!!!!//사진5
<img src="{{ '/assets/cs/.png' }}" style="width: 600px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👋 [Link][Link4]  

👉 추가적으로, super.viewDidLoad()를 제거하면 어떤 일이 일어나는지?  
👉 상위 클래스의 viewDidLoad를 호출하지 않아도 문제는 일어나지 않지만, UIKit의 viewDidLoad가 언제 구현이 바뀔지 모르고, 내부에 중요한 초기화 코드가 들어갈 수도 있기 때문에 당장 영향이 없더라도 super.viewDidLoad를 호출하는 것이 바람직하다고 생각합니다.  

<br>

## Delegate

👉 객체 간의 데이터 통신을 할 경우 전달자 역할을 하는 ios의 디자인 패턴입니다.
👉 Delegate는 이벤트 처리할 때 많이 사용하게 되는데 특정 객체에서 발생한 이벤트를 다른 객체에게 전달할 수 있도록 해줍니다.  
👉 UITableView, UICollectionView 등에서 많이 쓰이고 있음  
👉 [Delegate란 무언인가 설명하고, retain 되는지 안되는지 그 이유를 함께 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/13)  
👉 Delegate는 **객체 간의 데이터 통신을 할 경우 전달자 역할**을 하는 ios의 디자인 패턴입니다.  
👉 Delegate는 이벤트 처리할 때 많이 사용하게 되는데 특정 객체에서 발생한 이벤트를 다른 객체에게 전달할 수 있도록 해줍니다.  
👉 retain이란 메모리가 해제되지 않아 누수가 생기는 현상으로 객체 간의 참조 타입을 주고받는 Delegate에 따로 처리가 없다면 retain 현상이 일어날 수 있습니다.  
👉 따라서, Delegate를 weak으로 선언하여 retain을 방지해야 합니다.  

<br>

## Memory Management

👉 스위프트는 ARC로 메모리 관리를 한다. // 좀 더 자세하게  
👉 ARC : 자동 참조 계수(ARC: Automatic Reference Counting)를 뜻하며, 인스턴스가 더 이상 필요없을 때 사용된 메모리를 자동으로 해제해준다.  
👉 [ARC란 무엇인지 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/4)  
👉 강한 순환 참조 : 강환 순환 참조는 ARC로 메모리를 관리할 때 발생할 수 있는 문제이다. 두 개의 객체가 서로 강한 참조를 하는 경우 발생할 수 있다.  
👉 [순환 참조에 대하여 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/148)  
👉 [강한 순환 참조 (Strong Reference Cycle) 는 어떤 경우에 발생하는지 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/154)  
👉 [Strong 과 Weak 참조 방식에 대해 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/6)
👉 강한 순환 참조의 해결법 : 서로 강한 참조를 하는 경우 발생한다면, 둘 중 하나의 강한 참조를 변경해주면 된다. 강한 참조를 **약한(weak) 참조** 혹은 **미소유(unowned) 참조**로 변경하면 강한 순환 참조 문제를 해결할 수 있다. 약한 참조는 옵셔널일 때 사용하고, 미소유 참조는 옵셔널이 아닐 때 사용한다. // 약한 참조 vs 미소유 참조 // 자세하게  
👋 [Link][Link5]  
👋 [메모리 관리 ARC](http://jhyejun.com/blog/memory-management-arc)  
👋 [weak와 unowned의 사용법](http://jhyejun.com/blog/how-to-use-weak-and-unowned)  
👋 [클로저에서의 강한 순환 참조](http://jhyejun.com/blog/strong-reference-cycles-in-closure)  

<br>

## assign vs weak

👉 assign : 객체의 retain count 를 증가시키지 않습니다. 외부에서 retain count 를 감소시켜 객체가 소멸될수 있기 때문에 int 와 같은 primitive type 에 적합합니다. // retain count?  👉 [Retain Count 방식에 대해 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/150)  
👉 weak : assign 과 거의 동일하지만 assign 은 객체가 소멸되어도 포인터 값이 변하지 않습니다. weak 는 객체가 해제되는 시점에 포인터값이 nil 이 됩니다. assign 의 문제점은 객체가 해제되어도 포인터값이 남아있어 접근하려다 죽는 경우가 생긴다는 점입니다. Objective-C 는 기본적으로 nil 에 접근할때는 에러가 발생하지 않습니다.  
👉 retain 과 assign 의 차이점을 설명하시오.??????????


```
Q : weak는 언제 dealloc 될까요?
A : 마지막 강한 참조가 더 이상 객체를 가리키지 않으면 객체는 할당이 해제되고 모든 약한 참조는 dealloc 됩니다.
```

<br>

## 순환 참조에서 weak self 로만 처리하면 되는가? // 알아볼 것

👉 

<br/>

## 13. iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크 이름은 무엇인가?

👉 UIKit  

👉 추가적으로,  
👉 사용자, system, app의 상호작용을 관리하는 main run loop를 제공합니다.  
👉 UI는 main thread 혹은 main dispatch queue에서만 동작하도록 다뤄야 합니다.  
👉 UIKit이란? // 검색검색  

<br/>

## 14. Foundation Kit은 무엇이고 포함되어 있는 클래스들은 어떤 것이 있는지 설명하시오.

👉 [Foundation Kit은 무엇이고 포함되어 있는 클래스들은 어떤 것이 있는지 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/10)  
👉 애플에서 기본으로 제공하는 Cocoa Touch Framework에 포함된 Framework로 String, Double과 같은 기본타입들과 Array, Dictionary같은 콜렉션타입이 들어있어 앱의 기본적인 기능을 제공하는 프레임워크입니다.  

<br/>

## 17. UIKit 클래스들을 다룰 때 꼭 처리해야하는 애플리케이션 쓰레드 이름은 무엇인가?

👉 UI와 관련된 모든 작업은 반드시 앱의 Main 스레드에서 처리해야 합니다.  
👉 Why? UI는 변경을 트리거하는 이벤트가 발생하자마자 변경되는 것이 아니라 런루프의 한 사이클 끝에 변경됩니다. 만약 여러 스레드에서 UI작업을 처리하게 되면 각각 다른 런루프에서 작업을 처리하게 되고, 뷰가 화면에 그려지는 시점이 제각각이 되거나 레이아웃에 대한 계산이 의도했던 것과 다를 수 있을 것 같습니다.  
👉 // 조금 더 자세히 // https://rolypolytoy.tistory.com/22  
👉 강의도 한 번 참고할 것  

<br/>

## 39. 오토레이아웃을 코드로 작성하는 방법은 무엇인가? (1 + 2가지)

👉 [오토레이아웃을 코드로 작성하는 방법은 무엇인가? (1 + 2가지)](https://github.com/lunchScreen/Interview_Questions/issues/2)
👉 SnapKit을 이용하여 오토레이아웃을 작성한다. + NSLayoutContraint, NSLayoutAnchor
👉 SnapKit은 iOS에서 오토레이아웃을 스토리 보드 없이, 쉽고 간략하게 설정해줄 수 있는 기능을 가진 라이브러리입니다. snp.makeConstraint를 이용하여 오토레이아웃을 설정한다.
👉 기본 NSLayoutConstraint 객체를 생성하여 활용하는 방법으로, 제약사항을 파라미터로 하나씩 표현해 객체를 생성하고 이를 Active시켜서 오토레이아웃을 활성화합니다.
👉 다음으로 NSLayoutAnchor를 활용하는 방법으로, NSLayoutConstraint를 좀 더 쉽게 활용하기 위해 만들어진 팩토리 클래스입니다. Anchor를 기준으로 생성하기 때문에 좀 더 직관적이라는 장점이 있습니다.

<br/>

## 40. 왜 오토레이아웃을 코드로 작성을 할까?

👉 Storyboard는 Index 시간, Build 시간에 악영향을 준다
👉 XCode 자체 오류로 인해 Storyboard 내 View Controller가 Inspector 상에 제대로 보이지 않을 수 있다.
👉 SwiftUI를 위해 코드로 View를 구현하는 연습은 도움이 된다.

<br/>

## 42. 스토리보드를 이용했을때의 장단점을 설명하시오.

👉 [스토리보드를 이용했을때의 장단점을 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/12)
👉 스토리보드를 사용하면 시각적으로 뷰를 확인할 수 있기 때문에 오토레이아웃이나 뷰의 구성을 바로바로 학인하고 쉽게 수정할 수 있다는 장점이 있습니다. 하지만 뷰의 재사용이 어렵고 화면이 많아지면 프로젝트를 로드하는 속도가 느려진다는 점, 그리고 협업시에 여러 사람이 스토리보드를 수정하게되면 충돌이 쉽게 발생한다는 단점이 있습니다.

<br/>

## 43. Safearea에 대해서 설명하시오.

👉 [Safearea에 대해서 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/39)
👉 safearea는 iOS 디바이스중 상단 노치 영역과 하단 홈 바 영역을 말합니다. 기본적으로 앱이 이 영역들을 침범하지 못하도록 safearea를 기준으로 오토레이아웃을 설정합니다.

<br/>

## 44. Left Constraint 와 Leading Constraint 의 차이점을 설명하시오.

👉 [Left Constraint 와 Leading Constraint 의 차이점을 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/11)
👉 문자에 대한 제약을 설정할 때 Left는 항상 문자의 시작을 왼쪽에 두지만 Leading은 언어에 따라서 우측에서 좌측으로 읽는 언어는 시작을 오른쪽에, 좌측에서 우측으로 읽는 언어는 시작을 왼쪽에 둡니다.

<br/>

## 40. hugging, resistance에 대해서 설명하시오.

👉 [hugging, resistance에 대해서 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/36)
👉 hugging은 최대 크기에 대한 제한이고, resistance는 최소 크기에 대한 제한입니다. 따라서 hugging의 우선순위가 다른 뷰들보다 높은 뷰는 더 커지지 않으려고 하고, resistence의 우서순위가 다른 뷰들보다 높은 뷰는 더 작아지지 않으려고 합니다.
👉 예를 들어 길이가 정해진 스택 뷰 안에 두 UILabel이 있다고 했을 때, 왼쪽 뷰의 hugging priority가 더 높은 뷰는 스택뷰를 채우기 위해 길이를 늘리지 않고, 오른쪽 뷰가 길이를 늘려 스택뷰를 채우게 됩니다.
👉 반대로 resistence priority가 더 높은 뷰는 더 작아지지 않으려고 하기 때문에 스택뷰의 크기가 두 UILabel의 컨텐츠를 모두 표시하지 못하는 크기라면, resistence priority가 더 낮은 뷰의 크기가 줄어듭니다.

<br/>

## 41. Intrinsic Size에 대해서 설명하시오.

👉 [Intrinsic Size에 대해서 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/29)
👉 Intrinsic Conetent Size는 UIButton, UILabel 등에서 사용되어서 뷰 내부의 컨텐츠에 따라 계산되는 뷰의 크기를 의미합니다. 커스텀 뷰에서는 이 프로퍼티를 오버라이딩해서 크기를 계산해주고 invalidIntrinsicContentSize를 호출해주어야합니다.  

<br/>

## 21. 자신만의 Custom View를 만들려면 어떻게 해야하는지 설명하시오.

👉 [자신만의 Custom View를 만들려면 어떻게 해야하는지 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/20)
👉 Xib 파일을 만들고 UIView를 상속받는 클래스를 생성해 둘을 연결하는 방법으로 커스텀 뷰를 만들거나,
👉 UIView를 상속받는 커스텀 뷰 클래스를 만들고 코드로 정의해 내부에서 레이아웃까지 설정하는 방식으로 커스텀 뷰를 만들 수 있음

<br/>

## 47. Autoresizing과 Autolayout의 차이

👉 Autoresizing mask는 어떤 뷰의 바운드가 변경되었을 때, 그 하위 뷰들의 프레임을 어떻게 변경할지 정의합니다. autoresizing mask는 위, 아래, 왼쪽, 오른쪽에 대해 설정할 수 있고 설정된 방향은 상위뷰의 bounds가 변화함에 따라 함께 변화하게 됩니다. 예를 들어서 오른쪽에 대해 Autoresizing mask를 설정하면 화면의 크기가 변화되어서 가로 길이가 늘어났을 때, 설정한 서브뷰의 가로 길이가 함께 늘어나게 됩니다. 설정이 되어있지 않은 면들은 기존 크기를 그대로 유지합니다.

<br>

## Frame vs Bounds

👉 Frame : 부모뷰의 상대적인 위치(x, y) 및 크기 (너비, 높이)로 표현되는 사각형입니다.  
👉 Bounds : 자체 좌표계 (0,0)를 기준으로 위치 (x, y) 및 크기 (너비, 높이)로 표현되는 사각형입니다.  
👉 [Bounds 와 Frame 의 차이점을 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/1)  
👉 Frame은 슈퍼뷰의 좌표 시스템에서 뷰의 위치와 크기를 나타내고, Bounds는 자신의 좌표 시스템에서 뷰의 위치와 크기를 나타냅니다.  
👉 따라서, Frame의 origin은 슈퍼뷰의 원점에서 얼마나 떨어져 있는가를 나타내며, Bounds의 origin은 항상 (0, 0)입니다.  
👉 Frame의 origin을 변경하면 자신의 위치가 이동하고, Bounds의 origin을 변경하면 viewport가 이동하기 때문에 서브뷰들이 이동하는 것 처럼 보이게 됩니다.  
👉 size에서도 Frame은 슈퍼뷰에서 차지하고 있는 크기를 나타내며, Bounds는 자신 자체의 크기를 나타냅니다.  
👉 이러한 차이로, Frame은 뷰의 위치 및 크기를 설정할 때 사용하고, Bounds는 뷰의 실제 크기를 알고 싶을 때 사용합니다.  

<br>

## Bounds를 사용하는 예시가 어떤게 있을까요?

👉 `스크롤 뷰`는 스크롤 될 때마다 스크롤 뷰의 Bounds를 업데이트 합니다. 만약 왼쪽으로 스와이프해서 스크롤하면 bounds의 x좌표가 증가합니다.  

<br/>

## 46. #selector의 역할이 무엇인지.

👉 [#selector 의 메소드가 어떤 역할을 하는지? (@Objc 를 붙이는 이유는?)](https://github.com/lunchScreen/Interview_Questions/issues/88)
👉 Objective-C 런타임으로 실행되는 메서드를 지정하기 위해서 사용합니다.

<br/>

## 26. TableView를 동작 방식과 화면에 Cell을 출력하기 위해 최소한 구현해야 하는 DataSource 메서드를 설명하시오.

👉 섹션마다 표시할 셀의 개수를 반환하는 numberOfRowsInSection이 있고, 인덱스마다 어떤 셀을 사용할지 반환하는 cellForRowAt이 있습니다.

```swift
 func tableView(UITableView, numberOfRowsInSection: Int)
 func tableView(UITableView, cellForRowAt: IndexPath)
```

<br/>

## 27. 하나의 View Controller 코드에서 여러 TableView Controller 역할을 해야 할 경우 어떻게 구분해서 구현해야 하는지 설명하시오.

 [하나의 View Controller 코드에서 여러 TableView Controller 역할을 해야 할 경우 어떻게 구분해서 구현해야 하는지 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/159)
👉 IBOulet을 만들어두고 delegate가 실행될 때 인자로 전달되는 TableView의 인스턴스를 IBOutlet과 비교하거나, tag를 이용해서 구분할 수 있습니다.

<br/>

## 38. TableView와 CollectionView의 차이점을 설명하시오.

👉 [TableView와 CollectionView의 차이점을 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/25)
👉 두 개의 뷰 모두 Cell을 기반으로 여러 데이터를 표현할 수 있는 View입니다.
👉 테이블 뷰는 기본적으로 수직 스크롤 만이 가능합니다.
👉 반면에 콜렉션 뷰는 테이블뷰에서 할 수 있는 기능을 전부 가지고 있으면서 여러 열과 행을 가질 수 있고 수직/수평 스크롤이 모두 가능하다는 특징이 있습니다.

<br/>

## 35. prepareForReuse에 대해서 설명하시오.

👉 [prepareForReuse에 대해서 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/7)
👉 prepareForReuse는 테이블 뷰나 컬렉션 뷰에서 셀을 재사용할 때 호출되는 메서드입니다. 화면에서 사라진 셀은 리유저블 큐에 저장되고 cellForItemAt 에서 dequeue되었을 때 다시 재사용됩니다. prepareForReuse는 cellForItemAt 이 호출되기 전에 호출되어서 셀의 설정들을 초기화할 수 있도록 도와줍니다.

<br/>

## 45. CollectionViewLayout을 커스텀하게 정의할 때 prepare 메서드가 언제 불리고 어떤 역할을 하는지

👉 콜렉션 뷰가 컨텐츠를 처음 표시하거나 뷰가 변경되어서 레이아웃이 무효화되면 호출됩니다. prepare 메서드가 호출되면 레이아웃 객체에게 레이아웃을 업데이트 하도록 시키게됩니다. 레이아웃이 업데이트 되기 시작하면 콜렉션 뷰가 이 메서드를 호출해서 정의한 레이아웃 객체가 레아이웃을 잡을 수 있게 합니다.

<br/>

## 18. App Bundle의 구조와 역할에 대해 설명하시오.

👉 [App Bundle의 구조와 역할에 대해 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/30)
👉 Bundle 이란 실행 가능한 코드와 리소스를 한 공간에 묶는 디렉터리를 의미합니다.
👉 즉, 앱 번들은 실행 파일, 앱 아이콘, Info.plist, 리소스 등으로 구조를 이루고 있으며 애플리케이션을 실행시키기 위한 모든 것들을 저장하고 있습니다.

<br/>

## 18. Info.plist란?

👉 // 검색요망

<br>

## 3. 실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것을 설명해주세요.

👉 [실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것을 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/91)
👉 시뮬레이터에서는 `카메라, 마이크, 전화, 센서`를 사용할 수 없습니다.
👉 Apple의 푸시 알림 받기와 보내기 기능을 지원하지 않는다
👉 Mac과 iPhone의 성능 차이로 CPU, memory에서 차이가 남
👉 앱 백그라운드 전환, 터치, 다크모드 등 기본적인 기능은 시뮬레이터에서도 가능.

<br/>

## 28. setNeedsLayout와 setNeedsDisplay의 차이에 대해 설명하시오.

👉 [setNeedsLayout와 setNeedsDisplay의 차이에 대해 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/22)  
👉 setNeedsLayout은 뷰의 위치와 크기를 업데이트하는 layoutSubviews를 다음 업데이트 사이클에 호출하도록 예약하는 메서드입니다  
👉 setNeedsDisplay는 뷰의 내용을 그리는 draw 메서드를 다음 업데이트 사이클에 호출하도록 예약하는 메서드입니다.  

## 16. NotificationCenter 동작 방식과 활용 방안에 대해 설명하시오.

👉 [NotificationCenter 동작 방식과 활용 방안에 대해 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/107)  
👉 NotificationCenter는 싱글톤 객체로 Notification을 보낼 객체들을 addObserver로 이곳에 등록합니다.  
👉 Notification을 보낼 때는 post 함수를 호출하면 post와 함께 주어진 정보를 NotificationCenter에 관리되는 객체들에게 모두 보내게 됩니다.  
👉 옵저버 패턴이지만 중간 브로커 역할을 하는 NotificationCenter가 있기 때문에 한번에 여러 객체에게 어떤 정보를 보내고자할 때 브로드캐스팅의 목적으로 사용할 수 있습니다.  
👉 // 조금 쉽게 정리가 필요한 듯, 강의 다시 한 번 참고할 것  

## 앱의 콘텐츠나 데이터 자체를 저장/보관하는 특별한 객체를 무엇이라고 하는가?

👉 대표적으로, UserDefaults와 CoreData가 있음  
👉 UserDefaults  
　　👉 기본적으로, 간단하게 많이 사용하는 기능  
　　👉 앱의 기본 데이터베이스에 영구적으로 데이터를 저장할 수 있는 인터페이스  
　　👉 key와 value 쌍으로 저장  
　　👉 Singleton 패턴으로 설계되어 앱 전체에서 단 하나의 인스턴스만 존재함  
👉 CoreData  
　　👉 좀 더 복잡한 데이터를 저장할 때 적합한 기능  
　　👉 앱에서 모델 계층 개체를 관리하는 데 사용하는 프레임워크  
　　👉 CoreData는 Database가 아닌, 객체 그래프를 관리하는 프레임워크  
　　👉 대표적인 기능이 Persistence이며, SQLite에 의해 지원됨  

<br>

## Swift Singleton

👉 설명은 CS-Basic 참고  
👉 static property 혹은 private init을 사용하여 싱글턴 객체를 만들 수 있음  
👉 UserDefaults, URLSession, NotificationCenter 등에서 활용  

<br/>

## 20. NSCache가 먼데?

👉 ?

<br/>

👉 ## 31. NSCache의 cost랑 오브젝트 개수가 무엇이 다른지?

👉 ?

<br/>

## 29. NSCache와 딕셔너리로 캐시를 구성했을때의 차이를 설명하시오.

👉 [NSCache와 딕셔너리로 캐시를 구성했을때의 차이를 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/73)
👉 NSCache는 내부적으로 캐시정책을 가지고 있어서 저장하는 오브젝트의 개수나 cost를 정해두고 초과되면 정책에 따라 오브젝트를 삭제합니다. 딕셔너리는 내부적으로 따로 정책이 없습니다. 또한 NSCache는 thread safe하기도 합니다.

<br/>

## 30. NSCache 정책이 어떻게 구성되어있는지 아는지?

👉 LRU와 LFU의 하이브리드라고 알고있습니다. 공식문서에 따로 나와있지 않지만 libs 코드를 보았을 때 자주 참조된 데이터는 지우지 않은 채로 가장 오래전 데이터부터 순차적으로 지워주고 있습니다.

https://github.com/gnustep/libs-base/blob/master/Source/NSCache.m

<br/>

## 32. URLSession에 대해서 설명하시오.

👉 [URLSession에 대해서 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/74)
👉 URLSession은 네트워크 통신을 제공하는 기본 프레임워크의 클래스입니다.
👉 SessionTask를 만들고 여기에 통신에 대한 설정과 콜백을 정의해서 넘기면 네트워크 통신이 완료되었을 때 클로저가 실행됩니다.

<br/>

## 33. URLSessionConfiguration 종류

👉 default는 기본 상태, emphemral은 캐시를 지우지 않을 때, backgound는 앱이 백스라운드에서 다운로드를 받을 수 있게 합니다.

<br/>

## 34. URLDownloadTask와 URLSessionDataTask의 차이

👉 dataTask는 NSData 타입으로 데이터를 내려받기 때문에 로컬 저장소에는 저장하지 않습니다. 따라서 백그라운드 세션을 지원하지 않습니다. downloadTask로 내려받은 파일은 temp 디렉토리에 저장됩니다. 따라서 백그라운드 세션을 지원합니다.

<br>

## 5. App thinning에 대해서 설명하시오.

👉 [App thinning에 대해서 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/131)  
👉 앱 시닝은 앱이 설치될 때 앱스토어와 운영체제가 앱이 설치되는 `디바이스의 특성에 맞게` 앱을 설치하는 최적화 기술입니다.  
👉 앱 시닝은 세 가지 기술 요소로 이루어져 있습니다.  
👉 먼저 `슬라이싱`은 앱을 구성하는 여러 버전의 실행 가능한 코드와 리소스들 중 앱을 설치할 `디바이스 스펙에 맞는 버전들만 골라서 설치`하는 것을 의미합니다. 앱을 앱스토어에 올리게되면 앱스토어가 여러 버전의 파일들을 준비하고 다운로드시 디바이스에 맞게 슬라이싱합니다.  
👉 다음은 `주문형 리소스`는 앱을 설치할 때 모든 리소스를 다 설치하는 것이 아니라 일부는 앱 스토어에 저장해두고 사용자가 필요로할 때만 다운로드 하는 방식입니다.  
👉 마지막으로 `비트코드`는 앱스토어에 앱을 올릴 때 기계어로 구성된 바이너리 파일이 아니라 그 전 단계인 비트코드로 업로드 하는 것을 의미합니다. 비트 코드로 된 파일 중 사용자 환경에 맞는 비트코드들만 다시 컴파일해 바이너리를 만들 수 있습니다.  

<br/>

## 36. 다크모드를 지원하는 방법에 대해 설명하시오.

👉 [다크모드를 지원하는 방법에 대해 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/18)
👉 Asset에서 다크모드와 일반 모드에 대한 설정을 해줄 수 있습니다. Any, Dark, Light에 대한 색상을 각각 설정할 수 있습니다.
👉 또, userInterfaceStyle 프로퍼티를 통해 현재 디바이스가 다크모드인지 라이트모드인지 알 수 있기에 이를 이용해 인터페이스를 세팅해줄 수 있을 것 같습니다.
👉 window의 backgroundColor를 systemBackground로 설정하여 기기 테마의 설정을 따라갈 수 있는 것으로 알고 있음  

<br>

## @property 로 프로퍼티를 선언했을때, \_와 .연산자로 접근하는 것의 차이점

👉 \_ 는 인스턴스 변수에 직접 접근하는 연산자  
👉 . 은 getter 메소드 호출을 간단하게 표현한 것  

<br>

## Dynamic Binding

👉 동적 바인딩은 컴파일 타임이 아닌 런타임에 메시지 메소드 연결을 이동시킵니다. 그래서 이 기능을 사용하면 응답하지 않을 수도 있는 객체로 메시지를 보낼 수 있습니다. 개발에 유연성을 가져다 주지만 런타임에는 가끔 충돌을 발생시킵니다.  

<br>

## 의존성 주입이란?
👉 [의존성 주입에 대하여 설명하시오.](https://github.com/lunchScreen/Interview_Questions/issues/5)






<br>
<br>

# 💛 Machine Learning & Deep Learning

## Machine Learning ✔️
👉 컴퓨터가 학습할 수 있도록 하는 알고리즘과 기술을 개발하는 AI의 한 분야  
👋 Linear Regression, Decision Tree, Random Forest, etc  

<br>

## Deep Learning ✔️
👉 머신러닝의 한 분야로, 여러 층을 가진 인공신경망을 이용한 머신러닝  
👋 DNN, CNN, RNN, LSTM, etc  

<br>

## Gradient Descent Algorithm ✔️
👉 cost를 최소화하는 알고리즘  

<br>

## Cost(Loss) Function ✔️
👉 예측 값과 결과 값의 차이 정도를 알려주는 함수  
👋 cost(loss) : 예측 값과 결과 값의 차이 정도를 알려주는 값  
👋 Hypothesis : 훈련을 통해 예측한 방정식, 개념  
👋 cost = tf.reduce_mean(tf.square(hypothesis - Y))  
　　👉 제곱의 이유; 양수 혹은 음수이든 특별한 고려를 하지 않으면서, 오차가 클수록 많은 패널티를 주는 의미  

<br>

## Linear Regression
👉 어떤 변수에 다른 변수들이 주는 영향력을 선형적으로 분석하는 학습 기법  

<br>

## Decision Tree
👉 일련의 분류 규칙을 통해 데이터를 분류하는 학습 기법  
👉 overfitting 문제가 잘 발생함  
👋 overfitting : 학습 결과가 준비한 훈련 데이터에서는 정확하지만 일반적인 상황에 대해 정확도가 현저히 떨어지는 현상  

<br>

## Random Forest
👉 학습 과정에서 구성한 다수의 Decision Tree를 이용하는 학습 기법  
👉 overfitting 문제를 해결할 수 있음  

<br>

## Adaboost
👉 약한 분류기들이 상호 보완하도록 단계적으로, adaptive하게 학습하여 성능이 좋은 강한 분류기를 만드는 방법  
👋 boost : 성능이 낮은 약한 분류기를 조합하여 강한 분류기를 만드는 방법  

<br>

## Clustering
👉 주어진 개체들을 여러 특성을 고려해 유사한 개체끼리 그룹화하는 것  

<br>

## Regression 🆚 Classfication
👉 Regression  
　　👉 연속적인 값을 예측  
👉 Classfication  
　　👉 이산적인 값을 예측  

<br>

## Softmax Regression
👉 다중 클래스 분류 문제를 해결하는 학습 기법  
👋 다중 클래스 분류 문제 : 3개 이상 선택지 중 하나를 택하는 문제  

<br>

## Feed Forwarding
👉 신경망에서 Input Layer부터 Hidden, Output layer를 거쳐 출력되는 과정  

<br>

## Backpropagation ✔️
👉 Output layer에서부터 역방향으로 편미분을 수행해가며 weight, bias를 갱신하는 것  

<br>

## Dropout
👉 overfitting을 방지하기 위하여 일부 데이터를 학습 데이터에 포함하지 않는 것  

<br>

## Regularization
👉 overfitting을 방지하기 위하여 weight를 handling 하는 것  

<br>

## DNN(Deep Neural Network) ✔️
👉 사람의 신경망 원리와 구조를 모방하여 만든 머신러닝 알고리즘  
👉 Hidden layer를 2개 이상으로 많이 구성하여 학습 결과를 향상시킴  
👋 분류 및 수치예측에 강점이 있음  
👋 예측력이 다른 머신러닝 기법에 비해 상대적 우수, Data가 많을수록 성능이 향상  
👋 Hidden Layer 복잡할수록 계산 시간 多, weight 의미를 알기 어려워 결과 해석이 어려움  

<br>

## CNN(Convolutional Neural Network) ✔️
👉 데이터의 특징을 추출하여 특징들의 패턴을 파악하는 머신러닝 알고리즘  
👋 Convolution : 데이터 각 성분의 인접 특성을 고려하여 하나의 특징으로 도출하는 과정  
👋 Pooling : Convolution 과정을 거친 layer의 사이즈를 줄이는 과정  
👋 이미지 처리 작업에 강점이 있음  

<br>

## RNN(Recurrent Neural Network) ✔️
👉 반복적이고 순차적인 데이터 학습에 특화된 머신러닝 알고리즘  
👉 이전 정보를 현재 문제 해결에 있어 활용할 수 있음  
👉 내부에 순환 구조가 포함되어 있기 때문  
👋 자연어 처리 분야에 강점이 있음  
👋 LSTM  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>

[Link1]: https://medium.com/@jgj455/%EC%98%A4%EB%8A%98%EC%9D%98-swift-%EC%83%81%EC%8B%9D-%EC%95%B1-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-878dfe51d182
[Link2]: https://blog.naver.com/PostView.naver?blogId=soojin_2604&logNo=222423840595&parentCategoryNo=&categoryNo=&viewDate=&isShowPopularPosts=false&from=postView
[Link3]: https://jinshine.github.io/2018/05/28/iOS/%EC%95%B1%EC%9D%98%20%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0(App%20Life%20Cycle)%EC%99%80%20%EC%95%B1%EC%9D%98%20%EA%B5%AC%EC%A1%B0(App%20Structure)/
[Link4]: https://developer.apple.com/documentation/uikit/uiviewcontroller
[Link5]: https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48
[Link6]: https://zeddios.tistory.com/1218
[Link7]: https://zeddios.tistory.com/1220