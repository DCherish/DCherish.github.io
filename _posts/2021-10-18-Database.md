---
layout: page
title:  "Database"
subtitle: "Computer Science of Database"
date:   2021-10-18 11:11:11 +0530
categories: ["CS"]
comments: true
---
## SQL
👉 관계형 DBMS의 데이터를 관리하기 위해 설계된 특수 목적의 프로그래밍 언어  

<br>

## DBMS
👉 사용자와 DB 사이에서 사용자의 요구에 따라 정보를 생성해주고 DB를 관리해주는 소프트웨어  

<br>

## Database
👉 일반적으로 컴퓨터 시스템에 전자 방식으로 저장된 구조화된 정보 또는 데이터의 체계화된 집합  

<br>

## NoSQL
👉 기존의 RDBMS와 다른 형태의 데이터로 저장하는 기술  
👉 데이터간의 관계를 정의하지 않으며, 테이블 스키마가 매우 유동적  
👉 매우 대량의 데이터를 다루거나 분산형 구조에 매우 적합  
👋 분산시 데이터를 상호 복사하며 저장하기에 데이터 유실이 매우 적음  
👋 기존의 복잡하고 소량의 데이터에서 단순하고 다량의 로그 형태의 데이터로 변모함에 따라 중요성이 부각됨  
👋 트랜잭션을 지원하지 않음  

<br>

## Schema
👉 DB의 구조와 제약조건에 관하여 전반적인 명세를 기술한 것  

<br>

## Transaction
👉 DB 내에서 한꺼번에 수행되어야 할 일련의 연산들  
👋 A Transaction symbolizes a unit of work perfomed within a DBMS  
👉 4가지의 특성 ACID  
　　👉 원자성(Atomicity) : 분리할 수 없는 하나의 단위, 작업은 모두 완료하거나 모두 취소  
　　👉 일관성(Consistency) : 트랜잭션 수행 전/후 상관없이 DB는 항상 일관된 상태를 유지  
　　👉 격리성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하지 X  
　　👉 영속성(Durability) : 정상적인 종료가 되면 그 결과는 시스템에 영구적 적용  
👉 한꺼번에 완료가 된 경우, 성공적인 종료 'COMMIT', DB 반영  
👉 그렇지 못한 경우, 비정상적인 종료 'ROLLBACK', DB 영향 X  

<br>

## Transaction Isolation Level(격리 수준)
👉 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준  
👉 DB는 트랜잭션이 ACID 특징과 같이 독립적인 수행을 하기 위해 필요  
👉 4가지의 레벨  
　　👉 레벨 0 : SELECT 문장이 수행되는 동안 해당 데이터에 공유 락이 걸리지 않는 레벨  
　　👉 트랜잭션에 처리 중인 혹은 아직 커밋이 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용하는 레벨  
　　👉 다른 사용자가 아직 완료되지 않은 트랜잭션이지만 해당 데이터를 읽을 수 있음  
　　👉 레벨 1 : SELECT 문장이 수행되는 동안 해당 데이터에 공유 락이 걸리는 레벨  
　　👉 트랜잭션에 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기함  
　　👉 완료하지 않은 트랜잭션에는 접근할 수 없으며 커밋이 이루어진 트랜잭션만 조회할 수 있음  
　　👉 레벨 2 : 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 공유락이 걸리는 레벨  
　　👉 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장  
　　👉 다른 사용자는 그 영역에 해당하는 데이터에 대한 수정이 불가능  
　　👉 레벨 3 : 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 공유락이 걸리는 레벨  
　　👉 완벽한 읽기 일관성 모드를 제공  
　　👉 다른 사용자는 그 영역에 해당하는 데이터에 대한 수정 및 입력이 불가능  
👉 낮은 단계의 격리 수준을 이용할 때 발생하는 현상  
　　👉 Dirty Read : 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 형상  
　　👉 Non-Repeatable Read : 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 두 쿼리의 결과가 상이하게 나타나는 비일관성 현상  
　　👉 Phantom Read : 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상  

<br>

## E-R Model
👉 개체-관계 모델  
👉 구조화된 데이터에 대한 일련의 표현  
👉 ERM 프로세스의 산출물 : E-R Diagram  

<br>

## DB 이중화
👉 물리적으로 떨어져 있는 여러 DB에 대해 로컬 DB의 변경된 내용을 원격 DB에 복제하고 관리하는 것  
👋 실시간 데이터 백업 및 서버 부하 분산을 위해  

<br>

## Oracle 🆚 MySQL
👉 Oracle RDBMS는 대용량에 성능을 최적화하였기 때문에 일반적으로 대기업에서 많이 쓰임  
👉 MySQL은 진입장벽이 낮고 단일 DB로 제한이 되어 있어 일반적으로 중소기업 혹은 개인이 쓰기에 적합  

<br>

## 무결성(Integrity) ✔️
👉 DB에서 저장된 값들에 대해 여러가지 제한을 통하여 데이터에 대한 신뢰를 보장하게 하여 일관성을 유지시켜주는 것  
　　👉 영역 무결성(Domain Integrity) : 자료형, 규칙과 제약, 값 범위 등을 제한  
　　👉 참조 무결성(Entity Integrity) : 기본 키와 참조 키 간의 관계가 항상 유지됨을 보장  
　　　　👉 관련된 테이블의 레코드 간의 관계를 유효하게 하는 규칙  
　　　　👉 사용자의 실수로 관련 데이터가 삭제 or 수정되는 것을 막아줌  
　　　　👉 설정조건 #1 : 기본 테이블에서 사용한 필드는 기본키 or 고유 인덱스가 설정되어 있어야 함  
　　　　👉 설정조건 #2 : 기본 테이블, 관계 테이블 둘 다 액세스 테이블  
　　　　👉 설정조건 #3 : 관계를 설정하는 테이블은 형식이 같아야 함  
　　　　👉 쉽게 얘기하자면 외래키 값은 NULL 혹은 참조 릴레이션의 기본키 값과 동일함을 의미  
　　👉 개체 무결성(Domain Integrity) : 테이블에 있는 모든 형들이 유일한 식별자를 가질 것을 요구  

<br>

## Key ✔️
👉 DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기준이 되는 속성을 뜻함  
　　👉 기본 키(Primary Key) : 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성 // 오직 한 개, NULL X, 중복 값 X  
　　　　👋 복합 키(Composite Key) : 둘 이상의 속성으로 구성된 기본 키  
　　　　👋 자연 키(Natural Key) : 실제로 어떤 개체가 가지고 있는 속성으로 구성된 키  
　　　　👋 대리 키(Surrogate Key) : 보안 혹은 성능 향상을 위해 사용되는 인공적이거나 합성적인 키, 인공 키라고도 함  
　　👉 후보 키(Candidate Key) : 특정 튜플을 유일하게 식별할 수 있는 최소한의 속성들의 집합으로 구성된 키 // 유일성 O, 최소성 O  
　　👉 대체 키(Candidate Key) : 후보 키가 둘 이상일때, 기본 키를 제외한 후보 키  
　　👉 슈퍼 키(Super Key) : 특정 튜플을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합으로 구성된 키 // 유일성 O, 최소성 X  
　　👉 외래 키(Foreign Key) : 참조되는 릴레이션의 기본 키와 대응되어 릴레이션 간의 참조 관계를 표현하는 중요한 도구  
　　👉 부분 키(Partial Key) : 약한 개체를 유일하고 최소로 구분해 낼 수 있는 키  
👋 유일성 : 특정 튜플을 바로 찾아낼 수 있는 고유한 속성을 의미  
👋 최소성 : 키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없는, 따라서 반드시 필요한 최소의 속성을 의미  

<br>

## DDL(Data Definition Language)
👉 DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 사용하는 언어  
👉 즉, 스키마를 정의하거나 조작하기 위해 사용하는 언어  
👋 CREATE, ALTER, DROP // 생성, 변경, 삭제  

<br>

## DML(Data Manipulation Language)
👉 사용자로 하여금 데이터를 처리할 수 있게 하는 도구로써 사용자와 DBMS 간의 인터페이스를 제공  
👉 즉, 데이터를 조작하기 위해 사용되는 언어  
👋 SELECT, INSERT, DELETE, UPDATE // 검색, 삽입, 삭제, 변경  

<br>

## DCL(Data Control Language)
👉 데이터의 무결성, 보안 및 권한 제어, 회복 등을 하기 위해 사용되는 언어  
👉 즉, 데이터를 보호하고 관리하는 목적으로 사용하는 언어  
👋 COMMIT, ROLLBACK, GRANT, REVOKE // 신규 적용, 이전 복원, 권한 부여, 권한 취소  

<br>

## DQL(Data Query Language)
👉 SELECT 만을 따로 분리해서 쿼리로 표현하는 유형  

<br>

## TCL(Transaction Control Language)
👉 COMMIT, ROLLBACK 만을 따로 분리해서 표현하는 유형  

<br>

## 인덱스(Index) ✔️
👉 추가적인 쓰기 작업과 저장 공간을 활용하여 DB 테이블 검색 속도를 향상시키기 위한 자료구조  
👉 1. Hash Table  
　　👉 칼럼의 값으로 생성된 Hash를 기반으로 인덱스를 구현  
　　👉 장점은 검색이 매우 빠름 (시간 복잡도 O(1))  
　　👉 단점은 연속적인 데이터를 위한 순차 검색이 불가능 (부등호 <, >)  
👉 2. B+ Tree  
　　👉 자식 노드가 2개 이상인 B Tree를 개선한 자료구조  
　　👉 leaf node들은 LinkedList로 연결되어 있어 순차 검색이 용이함  
　　👉 검색이 Hash Table보단 늦음 (시간 복잡도 O(logn))  

<br>

## 왜 Hash Table 대신 B+ Tree를 흔히 사용?
👉 Hash Table은 모든 값이 정렬되어 있지 않아 특정 기준보다 크거나 작은 값을 쉽게 찾을 수 없음  
👉 따라서, 기준 값보다 크거나 작은 요소들을 항상 탐색할 수 있어야 하는 DB 인덱스로 B+ Tree가 더 자주쓰임  

<br>

## 왜 B+ Tree를 사용? 다른 자료구조?
👉 시간적인 성능에서 뛰어나거나 혹은 검색에 있어 시간적인 성능이 떨어져도 결국 삽입 및 삭제를 포함한 종합적인 성능에서 B+ Tree가 우수  

<br>

## 인덱스(Index) 관리
👉 인덱스가 적용된 칼럼에 INSERT, DELETE, UPDATE가 수행된다면  
　　👉 INSERT : 새로운 데이터에 대한 인덱스를 추가  
　　👉 DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행  
　　👉 UPDATE : 기존의 인덱스를 사용하지 않음을 처리, 갱신된 데이터에 대한 인덱스를 추가  
⚠️ 기존의 인덱스를 '삭제'하는 것이 아닌 '사용하지 않음'을 처리함에 주의  
⚠️ 따라서, 인덱스를 사용함으로써 성능이 향상될 수 있지만, INSERT/DELETE/UPDATE가 빈번한 속성에 인덱스를 적용할 경우 인덱스의 크기가 비대해지기에 성능이 오히려 저하되는 역효과가 일어날 수 있음  

<br>

## DB 정규화 ✔️
👉 관계형 DB에서 중복을 최소화하기 위해 데이터를 구조화하는 작업  
👉 제 1 정규화  
　　👉 테이블에 칼럼이 **원자 값**을 갖도록 테이블을 분해  
<br>
<img src="{{ '/assets/cs/cs_db_1.png' }}" style="width: 350px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 제 2 정규화  
　　👉 제 1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해  
　　👋 **완전 함수 종속** : 기본 키의 부분 집합이 결정자가 되어선 X  
<br>
<img src="{{ '/assets/cs/cs_db_2.png' }}" style="width: 420px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 제 3 정규화  
　　👉 제 2 정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해  
　　👋 **이행적 종속** : A ➡️ B & B ➡️ C이면, A ➡️ C
<br>
<img src="{{ '/assets/cs/cs_db_3.png' }}" style="width: 420px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 BCNF 정규화  
　　👉 제 3 정규화를 진행한 테이블에 대해 **모든 결정자**가 **후보키**가 되도록 테이블을 분해  
<br>
<img src="{{ '/assets/cs/cs_db_4.png' }}" style="width: 420px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## 정규화 장점과 단점
👉 DB 변경시 발생하는 **이상 현상**들을 해결할 수 있음  
👉 연동 프로그램에 최소한의 영향만 미치게 만들어 응용 프로그램 수명 연장  
👉 But, 릴레이션 간의 연산(JOIN)이 많아져 응답 시간이 느려질 수 있음  

<br>

## Join
👉 두 개 이상의 테이블이나 DB를 연결하여 데이터를 검색하는 방법  
👋 INNER, LEFT, RIGHT, FULL Join // 교집합, 왼쪽 테이블 기준, 오른쪽 테이블 기준, 합집합  

<br>

## 이상 현상(Anomaly) ✔️
👉 논리적 오류가 발생하여 데이터 조작시 불일치가 발생하는 현상  
👉 삽입 이상 : 튜플 삽입시 의도하지 않은 자료까지 삽입해야만 테이블에 추가가 가능한 현상  
👉 삭제 이상 : 튜플 삭제시 유용한 다른 정보까지 삭제되어버리는 현상  
👉 갱신 이상 : 튜플 수정시 중복된 데이터의 일부만 수정되어 데이터 모순이 일어나는 현상  

<br>

## DB Lock
👉 여러 개의 트랜잭션들이 하나의 데이터로 동시에 접근하려고 할 때 이를 제어해주는 도구  
👉 공유 락(Shared Lock) : 트랜잭션이 읽기를 할 때 사용되는 락  
　　👉 데이터를 읽을수는 있지만 쓸 수 없음  
👉 배타 락(Exclusive Lock) : 트랜잭션이 읽고 쓰기를 할 때 사용되는 락  
　　👉 데이터를 읽고 쓸 수 있음  

<br>

## DB Deadlock
👉 여러 개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태  
👉 예방 기법  
　　👉 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 락킹  
　　👉 But, 데이터가 많이 필요하면 모든 데이터를 락킹해야해서 트랜잭션의 병행성을 보장하지 X  
　　👉 또한, 몇몇의 트랜잭션은 계속 처리를 못하게 되는 **기아 상태**가 발생할 수 있음  
👉 회피 기법  
　　👉 Wait-Die : 다른 트랜잭션이 데이터를 점유하고 있을 때, 기다리거나 포기하는 방식  
　　👉 Wound-Wait : 다른 트랜잭션이 데이터를 점유하고 있을 때, 빼앗거나 기다리는 방식  
👉 탐지 기법  
　　👉 Union-Find를 이용하여, 사이클이 존재하는지 여부로 교착 상태를 알 수 있음  

<br>

## Hint
👉 SQL을 튜닝하기 위한 지시구문  
👉 옵티마이저가 최적의 계획으로 SQL문을 처리하지 못하는 경우 개발자가 직접 최적의 실행 계획을 제공하는 것  

<br>

## Clustering
👉 여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식  
👉 동기 방식으로 노드들 간의 데이터를 동기화  
👉 1개의 노드가 죽어도 다른 노드가 살아있어 시스템을 장애 없이 운영할 수 있음  
👉 여러 노드들 간의 데이터를 동기화 하는 시간이 필요하므로 리플리케이션에 비하면 성능이 낮음  

<br>

## Replication
👉 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식  
👉 비동기 방식으로 노드들 간의 데이터를 동기화  
👉 비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없음  
👉 노드들 간의 데이터가 동기화 되지 않아 일관성 있는 데이터를 얻지 못할 수 있음  

<br>

## 커넥션 풀
👉 일정량의 커넥션 객체를 미리 만들어 pool에 저장하는 기법  
👉 프로그램 요청이 들어오면 커넥션 객체를 빌려주고, 해당 객체의 임무가 완료되면 다시 반납 받아 pool에 저장  
👉 불필요하게 커넥션을 생성하고 삭제하는 일이 사라져서 이와 관련된 비용을 줄여 성능 향상에 도움이 됨  
👋 커넥션 : DB 연결 객체  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>