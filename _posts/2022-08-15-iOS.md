---
layout: page
title:  "iOS"
subtitle: "Computer Science of iOS"
date:   2022-08-15 11:11:11 +0530
categories: ["CS"]
comments: true
---
# 💛 Swift

## Swift 함수 형태 및 관련 용어
👉 func 함수명(전달인자 레이블 매개변수 레이블: 매개변수 타입)  
　　👋 func hello(to num: Int) { ~ }  
　　👋 func hello(_ str: String) -> String { ~ }  
👉 전달인자 레이블 : 함수 외부에서 매개변수의 역할을 좀 더 명확히 하는 역할, 다르게 레이블을 써줌으로써 오버로딩 가능  
👉 매개변수 : 함수를 정의할 때 외부로부터 전달된 값의 이름, 함수 내부에서 전달된 값을 다루기 위한 역할  
👉 _ : 와일드 카드 패턴, 변수를 사용할 필요가 없을 때 사용, 공란 대신 입력st  
👉 가변 매개변수 : 매개변수로 몇 개의 값이 들어올지 모를 때 사용할 수 있으며, 함수마다 가변 매개변수는 하나만 가질 수 있음  
　　👉 타입 뒤에 ...으로 나타냄  
　　👋 func hello(_ num: Int, _ result: Int...) { ~ }  

<br>

## rawValue(원시값)
👉 열거형의 각 케이스가 기본적으로 갖고 있는 값  
👉 각 케이스는 원시값을 가지고 있지 않을 수 있음 // 열거형의 이름만 있고 타입은 없이 선언되어 있는 경우  
👉 정수형의 첫번째 케이스 기본적으로 0, 한 케이스의 원시값은 이전 케이스의 원시값 + 1  
👉 실수형의 첫번째 케이스 기본적으로 0, 한 케이스의 원시값은 이전 케이스가 정수값일 경우 + 1, 이전 케이스가 실수형일 경우 에러  
👉 String형의 원시값은 기본적으로 자신의 case 이름의 값 혹은 직접 지정한 값  
👉 Character의 원자값은 모두 직접 선언해야 함  

<br>

## associated Value(연관값)
👉 열거형에서 각 케이스들은 각자 단 하나의 원자값만 가질 수 있음  
👉 이러한 단점을 보완하기 위해 각 케이스가 상황에 따라 다른 값을 가지게 하기 위해서 사용하는 개념  
👉 케이스에 튜플 형태로 타입을 명시하여 사용  
　　👋 case caseName(model: String)  
　　👋 case caseName(model: String, size: Int)  
　　👋 let a: ENUM~ = ENUM~.caseName(model: "hello", size: 10) // 직접 값을 지정하여 사용  
👋 [Link][Link1]  

<br>

## 연관값을 가지는 열거형 매칭 🔥
👉 ex1) enum switch  
```swift
let commute = Transportation.subway(line: 2, express: false)

switch commute { // 여기서 Transportation 타입 추론
	case .subway(2): ~ // 따라서, 생략 가능
	case .car: ~
	case .bus(1): ~
	case .bus(2, "seoul", _): ~
	case .bus(3, let src, let dest): ~
	case let .plain(line, station): // 모든 변수의 바인딩 방식이 동일하다면 let이나 var을 맨 앞에 쓸 수 있음
        print("line: \(line), station: \(station)")
    default:
        break // 각 case엔 break가 생략되어 있으며, 공란은 허용하지 않기에 do nothing 기능을 위해서는 break를 명시적으로 작성해야 함
}
```  
👉 ex2) enum if  
```swift
let commute = Transportation.subway(line: 2, express: false)
if case let .subway(2, express) = commute { ~ }
// #1 let을 case뒤에 작성함으로써 인자에 let을 적지 않아도 됨 // if case .subway(2, let express) = commute
// #2 commute가 왼쪽과 매칭되냐의 의미
// #3 .subway로 작성이 가능한 이유는 오른쪽으로부터 타입을 참고하였기 때문
// #4 if case let ; switch문과 같이 모든 케이스를 작성하는 것이 아닌 원하는 단 하나의 경우만 체크할 수 있도록 하여 편하게 사용하도록 하는 swift 문법
// ; The Swift If-Case-Let syntax is a convenient shortcut to avoid a full switch statement when you only want to match a single case.
```  

<br>

## 열거형 특징
👉 enum은 연산 프로퍼티나 메소드를 포함할 수 있으며, 확장이 가능하고, 프로토콜을 따르도록 정의할 수 있음  
　　👋 ex)
```swift
enum HTTPCode: Int {
    case OK = 200
    case NOT_MODIFY = 304
    case SERVER_ERROR = 500

    var value: String { // 연산 프로퍼티 (읽기 전용, get 생략)
        return "HTTP number is \(self.rawValue)"
    }

	var code: Int {
		switch self { // 여기서 self는 자신의 케이스를 의미
		case .OK: return 2022
		case .NOT_MODIFY: return 2023
		}
	}

    func getDescription () -> String { // 메소드 포함 가능 (인스턴스 메소드)
        switch self { // 여기서 self는 자신의 케이스를 의미
        case .OK:
                return "HTTP 코드는 \(self.rawValue)" 입니다
        }
        ~~~
    }
        
    static func getName() -> String { // 타입 메소드
        return "이건 HTTPCode야~~"
    }
}
```  

<br>

## Self 🆚 self
👉 Self : 타입 프로퍼티와 타입 메소드를 가리킬 때 사용  
👉 self : 인스턴스 프로퍼티와 인스턴스 메소드를 가리킬 때 사용  

<br>

## 프로퍼티 종류 3가지
👉 저장 프로퍼티 : 클래스/구조체 에서 사용  
　　👉 클래스/구조체의 인스턴스의 일부가 되는 상수(let) 및 변수(var)  
　　👉 let으로 선언된 저장 프로퍼티는 수정 불가능  
　　👉 var로 선언된 저장 프로퍼티는 수정 가능  
　　👉 선언 시 초기값을 지정할 수 있으며, 수정 또한 가능  
　　👉 lazy 저장 프로퍼티  
　　　　👉 해당 저장 프로퍼티는 사용되기 전까지 생성되지 않음  
　　　　　　👉 따라서, 잘 활용할 경우 성능 향상, 공간낭비를 줄일 수 있다는 장점이 있음  
　　　　👉 반드시 var로 선언되어야 함  
　　　　　　👉 let으로 선언된 프로퍼티는 초기화를 함과 동시에 값을 필요로 하기 때문에, 값이 필요할 때에 초기화를 하는 lazy와는 거리가 있음  
👋 [Link][Link12]  

<br>

👉 연산 프로퍼티 : 클래스/구조체/열거형 에서 사용  
　　👉 반드시 var로 선언해야 함  
　　　　👉 연산 프로퍼티니까 값이 변경되어야 함  
　　　　👉 연산된 값을 저장할 공간, 즉, 다른 변수(저장 프로퍼티)를 반드시 필요로 함  
　　👉 연산 프로퍼티는 get, set 메서드 가지고 있음  
　　　　👉 get만 선언 O (읽기 전용)  
　　　　　　👉 get만 있는 읽기 전용 연산 프로퍼티는 get 생략 가능  
　　　　　　👉 즉, 단순히 { return } 으로 작성 가능  
　　　　👉 get/set 선언 O (읽기/쓰기)  
　　　　👉 set만 선언 X  
　　👉 get의 return 타입은 연산 프로퍼티의 타입과 반드시 같아야 함  
　　👉 set은 작성 방식, 두 가지  
　　　　👉 set { x(저장 프로퍼티) = newValue + 1 }  
　　　　👉 set(tempX) { x(저장 프로퍼티) = tempX + 1 }  
　　👉 ex)  
```swift
struct Info {
    var num = 3 // 저장 프로퍼티

    var cal: Int { // 연산 프로퍼티
        get {
            let tempX = num + 3

            return tempX // return 타입 유의
        }
        set(value) {
            num = value - 3
        }
    }
}
```  
👋 [Link][Link13]  

<br>

👉 타입 프로퍼티 : 클래스/구조체/열거형 에서 사용  
　　👉 static 키워드를 붙임으로써 타입 프로퍼티를 정의할 수 있음  
　　👉 타입 프로퍼티는 타입 자체에 연결하는 프로퍼티로, 저장 타입 프로퍼티, 연산 타입 프로퍼티가 있음  
　　👉 저장 타입 프로퍼티  
　　　　👉 let / var로 선언 가능  
　　　　👉 무조건 기본값을 설정해야 함  
　　　　👉 처음 액세스 할 때는 lazy와 같이 자동으로 지연 초기화  
　　　　　　👉 즉, lazy 키워드는 필요 X  
　　👉 연산 타입 프로퍼티  
　　　　👉 반드시 var로 선언해야 함(연산 인스턴스 프로퍼티처럼)  
　　　　👉 클래스 타입에 대한 연산 타입 프로퍼티의 경우 static 대신 class 키워드를 붙임으로써 서브 클래스가 슈퍼 클래스의 구현을 오버라이드 할 수 있음  
　　　　👉 서브 클래스에서 static 키워드 앞에 override 키워드를 붙여야 함  
　　　　　　👉 override static var ~  
　　　　👉 타입 프로퍼티는 타입 자체에 .연산자를 통해 프로퍼티에 접근  
　　　　　　👉 인스턴스 프로퍼티는 인스턴스에 .연산자를 통해 프로퍼티에 접근  
👋 [Link][Link14]  

<br>

## Property Observer
👉 lazy 저장 프로퍼티를 제외하고, 저장 프로퍼티에 프로퍼티 옵저버를 추가할 수 있음  
👉 willSet  
　　👉 값이 설정되기 직전에 호출되는 메소드, 새롭게 설정될 값이 newValue  
　　👉 willSet 작성 방식, 두 가지  
　　　　👉 willSet { newValue }  
　　　　👉 willSet(A) { A }  
👉 didSet  
　　👉 새로운 값이 설정된 직후에 호출되는 메소드, 새로 설정되기 이전의 값이 oldValue  
　　👉 didSet 작성 방식, 두 가지  
　　　　👉 didSet { oldValue }  
　　　　👉 oldSet(B) { B }  

<br>

## Property Wrapper
👉 프로퍼티를 구현할 때 반복적으로 사용되는 패턴을 줄이기 위해 사용  
👉 반복되는 로직들을 프로퍼티 자체에 연결하는 방식  
👉 wrappedValue를 반드시 필요로 함  

<br>

## Struct 🆚 Class 🆚 Enum
👉 struct와 enum은 값 타입의 인스턴스를 가지지만, class는 참조 타입의 인스턴스를 가짐  
👉 struct와 enum은 상속이 불가능하지만, class는 상속이 가능  
👉 struct와 class는 생성자가 있지만, enum에는 생성자가 없음  
⭐️ 클래스와 구조체의 공통점, 차이점  
　　👉 구조체 : 값 타입  
　　　　👉 var 선언 시 var 저장 프로퍼티 값 변경 가능  
　　　　👉 let 선언 시 모든 저장 프로퍼티 상수화 되어 값 변경 불가능  
　　　　👉 생성자가 없어도 됨  
　　　　　　👉 기본적으로 저장 프로퍼티들을 파라미터로 가지는 이니셜라이져가 있으며 초기값을 준다면 후에 값을 설정해주지 않아도 됨  
　　👉 클래스 : 참조 타입  
　　　　👉 let/var 선언 관계 없이 var 저장 프로퍼티 값 변경 가능  
　　　　👉 let 저장 프로퍼티는 변경 불가능  
　　　　👉 저장 프로퍼티에 초기값이 없으면 생성자(init) 반드시 필요  
　　　　　　👉 단, 저장 프로퍼티에 초기값이 지정되어 있다면 생성자가 없어도 됨  

<br>

## class 성능 향상 방법 🔥
👉 상속이 없는 클래스는 final로 선언하기  
　　👉 class 성능 향상은 Dispatch 과정 관련  
　　👉 Dispatch? 어떠한 메소드를 실행하여 처리할 지 결정하는 과정  
　　👉 Dispatch 종류?  
　　　　👉 Static Dispatch : 컴파일 시점에 어떤 메소드가 사용될 지 결정  
　　　　👉 Dynamic Dispatch : 런타임 시점에서 어떤 메소드가 사용될 지 결정  
　　　　　　👉 Dynamic Dispatch는 참조에 따라 함수를 호출하기 때문에 overhead가 발생  
　　　　　　👉 이러한 overhead는 상속이 가능한 class의 override 될 수 있는 메소드에서 발생  
　　　　　　👉 따라서, override가 확실히 되지 않음을 컴파일러에게 알려주면 overhead가 발생하지 않아 성능이 향상  
👉 외부 접근이 없는 경우 private 키워드 사용하기  
👉 변수 선언 시 타입을 지정하기  
👉 변경이 없는 변수는 let 키워드를 사용하기  

<br>

## Optional
👉 nil의 허용 여부를 나타내는 것, ? 키워드로 옵셔널을 표시함  
👉 옵셔널 종류 2가지  
　　👉 ? : 옵셔널  
　　　　👋 ex)
```swift
var optionalValue: Int? = 100  

optionalValue = optionalValue + 1 // 기존 변수처럼 사용 불가
optionalValue = nil // nil 할당 가능
```  
　　👉 ! : 암시적 추출 옵셔널  
　　　　👉 Non-Optional Type으로 처리되어야 할 때 값을 자동으로 추출해주는 장점이 있음  
　　　　👉 잘못 사용 시, 런타임 에러가 발생할 수 있음  
```swift
var optionalValue: Int! = 100

optionalValue = optionalValue + 1 // 기존 변수처럼 사용 가능
optionalValue = nil // nil 할당 가능
optionalValue = optionalValue + 1 // 옵셔널에 nil이 할당되어 있을 때 접근 시도 -> 런타임 오류
```  

<br>

## Optional 해제
👉 명시적 해제  
　　👉 강제 언래핑 : ! 키워드 사용  
```swift
var number: Int? = 3

print(number) // Optional(3)
print(number!) // 3
```  
　　👉 비강제 언래핑 : 옵셔널 바인딩  
```swift
if let result = number { // 옵셔널 바인딩
 	print(result)
} else {
    print("nil")
}
```  
👉 묵시적 해제  
　　👉 컴파일러에 의한 자동 해제  
```swift
let value: Int? = 6

if value == 6 { // 비교 연산자를 이용하여 다른 값과 비교 할 경우, 컴파일러가 자동적으로 옵셔널 값을 해제
    print("value가 6입니다.")
} else {
    print("value가 6이 아닙니다.")
}
```  
　　👉 옵셔널의 묵시적 해제  
```swift
let str = "12"
var strToInt: Int? = Int(str)
// Int() 함수는 매개변수에 정수로 변환될 수 없는 값이 오면
// nil을 반환하기 때문에 옵셔널 타입으로 선언해야 한다.

print(strToInt) // Optional(12)

var strToInt2: Int! = Int(str)
// 선언 시에 ! 키워드를 사용하면 묵시적으로 옵셔널 해제를 해준다.
// 강제 언래핑 때 사용하는 ! 와는 의미가 다름

print(strToInt2 + 1) // 13
```  

<br>

## Optional Binding
👉 미리 nil 체크를 함과 동시에 Optional 포장지를 벗겨 값을 안전하게 꺼내오는 방식  
👉 값이 있을 때만 값이 바인딩 됨  
👉 주로 if let, if var, guard 와 함께 사용  
　　👉 guard : 한 줄짜리 간편한 if 구문, 구문 항상 else를 달아줘야 함  
👉 쉼표를 사용해 여러 옵셔널 변수들을 한꺼번에 바인딩할 수 있음  
　　👋 ex)  
```swift
if let name = myName, let friend = yourName {
    print("실행 : \(name) and \(friend)")
} else { // 바인딩 실패 시 (하나라도 nil이 존재하는 경우)
    print("Binding Error")
}
```  

<br>

## Optional Chaining
👉 하위 프로퍼티에 옵셔널 값이 있는지 연속적으로 확인하면서 중간에 하나라도 nil이 발견된다면 nil을 반환하는 것  
👋 let count: Int? = A.num?.count  

<br>

## typealias
👉 기존에 선언되어 있는 유형에 새로운 유형의 별칭을 사용함으로써 코드를 더 읽기 쉽고 이해하기 쉽도록 명확하게 만드는 문법  
👋 ex)  
```swift
typealias Hi = (Int, Int, Int)
typealias Hello = (title: Int, content: Int, writer: Int)

var hi: Hi = (3, 3, 3)
var hi2 = Hi(4, 4, 4)

var hello: Hello = (title: 1, content: 2, writer: 3)
var hello2 = Hello(title: 4, content: 5, writer: 6)

print(hi.0) // 3
print(hi2.0) // 4

print(hello.title) // 1
print(hello2.writer) // 6
```  

<br>

## 타입 캐스팅
👉 is : 타입 확인 및 서브클래스 확인  
👉 as : 타입 변환  
　　👉 업캐스팅 : 서브클래스를 슈퍼클래스로 만드는 것, 항상 성공  
　　👉 다운캐스팅 : 슈퍼클래스를 서브클래스로 만드는 것, 실패할 수 있기에 as? 혹은 as! 사용  

<br>

## Swift Method
👉 Instance Method  
　　👉 클래스를 인스턴스화하여 생성된 인스턴스를 통해 호출할 수 있는 메소드  
👉 Type Method  
　　👉 인스턴스의 생성 없이 타입 자체에서 바로 호출할 수 있는 메소드  
　　👉 Static Method  
　　　　👉 subclass에서 오버라이딩이 불가능한 메소드  
　　👉 Class Method  
　　　　👉 subclass에서 오버라이딩이 가능한 메소드  

<br>

## Swift init
👉 Designated init  
　　👉 Swift의 초기화 이니셜라이져로, 클래스의 모든 프로퍼티를 초기화시키는 역할  
　　👉 init 이라고도 불림  
　　　　👉 모든 프로퍼티들은 init 함수가 끝나기 전(초기화 종료 전)에 모두 초기값을 가지고 있어야 함  
　　　　　　👉 만약 초기값이 없는 프로퍼티가 있을 경우, 초기화에 실패하여 인스턴스가 생성되지 않음  
　　　　　　👉 프로퍼티 타입을 "옵셔널 타입"의 "변수"로 설정하는 것 또한 초기화를 진행한 것임 (nil로 자동 초기화)  
　　　　　　　　👉 let으로 선언된 프로퍼티 타입을 옵셔널 타입으로 지정하는 것은 에러, let은 반드시 초기값을 지정  
　　　　👉 상속 받은 서브 클래스에서 D.I.를 작성할 경우, 반드시 super 클래스의 Initializers를 호출해주어야 함  
　　　　👉 ex)  
```swift
class Human {
    let name: String
    var age: Int? // OK
    let num: Int? // Error!
    
    init(name: String) {
        self.name = name
    }
}
 
class Sodeul: Human {
    let alias: String
    
    init(alias: String) { 
        super.init(name: alias) // 없으면 에러 발생
        self.alias = alias
    }
}
```  
👉 Convinience init  
　　👉 보조 이니셜라이져로, 일부 프로퍼티를 원하는 값으로 저장하는 역할을 하기에 C.i. 내부에서 반드시 D.i.를 호출해야 함  
　　　　👉 모든 프로퍼티를 초기화해주는 D.i.를 도와주는 역할  
　　　　👉 ex)  
```swift
class Human {
    var name: String
    var nickName: String
    
    init(name: String, nickName: String) {
        self.name = name
        self.nickName = nickName
    }
    
    convenience init(name: String) {
        self.init(name: name, nickName: "unknown")
    }
}
```  
👋 [Link][Link15]  

<br>

## Swift 초기화 심화 개념 🔥
👉 Initializer Delegation  
　　👉 생성자에서 또 다른 생성자를 호출하여 초기화 코드의 중복을 최대한 제거하고, 모든 프로퍼티를 효율적으로 초기화 하기위해 사용하는 것  
　　👉 Wrong ex)  
```swift
struct Position { // Initializer Delegation 준수 X
    var x: Int
    var y: Int
    
    // 만약, Initializer에서 y를 무조건 0으로 초기화 하고 싶다면

    init(xPos: Int, yPos: Int) {
        x = xPos
        y = yPos // 이 곳을 y = 0으로 수정해야하고
    }

    init(pos: Int) {
        x = pos
        y = pos // 이 곳 또한, y = 0으로 수정해야 함 -> 코드 중복
    }
}
```  
　　👉 Correct ex)  
```swift
struct Position { // Initializer Delegation 준수 O
    var x: Int
    var y: Int

    // 만약, Initializer에서 y를 무조건 0으로 초기화 하고 싶다면
    
    init(xPos: Int, yPos: Int) {
        x = xPos
        y = yPos // 이 곳만 y = 0으로 수정하면 끝 :)
    }

    init(pos: Int) {
        self.init(xPos: pos, yPos: pos)
    }
}
```  
👋 [Link][Link16]  

<br>

👉 deinit  
　　👉 소멸자로, 클래스 인스턴스가 메모리에서 해제되기 직전에 호출됨  
👉 required init?  
　　👉 code ex)  
```swift
class SampleView: UIView {
    override init(frame: CGRect) {
        //code
    }

    required init?(coder: NSCoder) {
        //code
    }
}
```  
　　👉 쉽게 말해, UIView/UIViewController를 상속받는 클래스에서 프로퍼티를 선언하고 init() 메소드를 작성할 것인데, 슈퍼클래스가 NSCoding 프로토콜을 준수하기에, required init?(coder: NSCoder) 메소드를 작성해야 함  
　　　　👉 NSCoding 프로토콜은 이를 구현하는 클래스로부터 실패 가능한 이니셜라이저를 작성하도록 함  
　　　　👉 프로토콜에 적혀있는 이니셜라이저를 구현하면 required 키워드가 붙으며, required 키워드가 붙은 이니셜라이저를 상속받는 자식 클래스에서도 이를 구현해줘야 함  
　　　　👉 UIView/UIViewController는 NSCoding 프로토콜을 구현하고 있기 때문에, 이를 상속받은 클래스에서는 required init?(coder: )를 구현해줘야 할 수도 있음  
　　　　　　👉 즉, 아예 작성을 안하거나, init을 작성한다면 반드시 같이 작성해야 함  
　　　　　　　　👉 swift에서는 자식 클래스에서 지정 이니셜라이저를 따로 작성하지 않은 경우, 부모의 이니셜라이져들을 자동으로 상속  
　　　　　　　　👉 따라서, 새로운 D.i.를 자식 클래스에서 작성하지 않았을 경우에 에러가 발생하지 않았음  
　　　　　　　　👉 하지만, 자식클래스에서 새로운 D.i.를 작성하게 된다면, 부모 클래스의 이니셜라이저들이 자동 상속하지 않기 때문에, required init?(coder: )를 구현하라는 에러가 발생  
　　👉 code로 custom한 UIView/UIViewController 등 무언가를 만들 때에 init을 반드시 해야 하는 이유?  
　　　　👉 인터페이스 빌더에서는 자동으로 초기화를 해주지만, 코드에서는 인터페이스 빌더를 사용하는 게 아니기 때문에 초기화를 하지 않는다면 아무것도 뜨지 않기 때문  
　　　　　　👉 인터페이스 빌더의 대표적인 예시 : Storyboard, Xib  
　　　　👉 다양한 사용 예시  
　　　　　　👋 override init(frame: CGRect) // UIView  
　　　　　　👋 override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) // UIViewController  
　　　　　　👋 override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) // UITableViewCell  
　　　　　　👋 override init(reuseIdentifier: String?) // UITableViewHeaderFooterView  
👋 [Link][Link17]  
👋 [Link][Link18]  

<br>

👉 init? 🆚 init!  
　　👉 init? : 초기화에 성공하면 초기화된 인스턴스가 "Optional Type"으로 리턴, 초기화에 실패하면 "nil"을 리턴  
　　👉 init! : 초기화에 성공하면 초기화된 인스턴스가 "Non Optional Type"으로 리턴, 초기화에 실패하면 크래시가 발생  

<br>

## Protocol
👉 반드시 가져야 할 프로퍼티나 메소드를 정의만 하는 청사진 역할  
👉 프로토콜을 적용할 객체는, 프로토콜에서 정의했던 프로퍼티와 메소드를 반드시 구현해야 함  

<br>

## Protocol Property
👉 프로토콜의 프로퍼티는 반드시 var로 선언되야 함  
👉 프로토콜의 프로퍼티가 get만 필요로 하는 경우, 모든 종류의 프로퍼티에서 요구사항을 충족시킬 수 있음  
　　👉 상수 저장 프로퍼티  
```swift
protocol FullyNamed {
    var fullName: String { get }
}
struct Person: FullyNamed {
	let fullName: String
}
var john = Person(fullName: "John Appleseed")
john.fullName = "Zedd" // error! 'fullName' is a 'let' constant
```  
　　👉 변수 저장 프로퍼티  
```swift
protocol FullyNamed {
	var fullName: String { get }
}
struct Person: FullyNamed {
	var fullName: String
}
var john = Person(fullName: "John Appleseed")
john.fullName = "Zedd" // ok
```  
　　👉 연산 프로퍼티 get  
```swift
protocol FullyNamed {
	var fullName: String { get }
}
struct Person: FullyNamed {
	var name: String // 실제 값 저장될 저장 프로퍼티
	var fullName: String {
		return name
	}
}
var john = Person(name: "John Appleseed")
john.fullName = "Zedd" // error! 'fullName' is a get-only property
print(john.fullName) // ok
```  
　　👉 연산 프로퍼티 get/set  
```swift
protocol FullyNamed {
	var fullName: String { get }
}
struct Person: FullyNamed {
	var name: String // 실제 값 저장될 저장 프로퍼티
	var fullName: String {
		get {
			return name
		}

		set {
			name = newValue
		}
	}
}
var john = Person(name: "John Appleseed")
john.fullName = "Zedd" // ok
print(john.fullName) // ok
```  
👉 프로토콜의 프로퍼티가 get과 set 모두 필요로 하는 경우, 상수 저장 프로퍼티와 읽기 전용 연산 프로퍼티가 될 수 없음  
　　👉 상수 저장 프로퍼티  
```swift
protocol FullyNamed {
	var fullName: String { get set }
}
struct Person: FullyNamed {
	let fullName: String // error! error: type 'Person' does not conform to protocol 'FullyNamed'
}
var john = Person(fullName: "John Appleseed")
```  
　　👉 변수 저장 프로퍼티  
```swift
protocol FullyNamed {
	var fullName: String { get set }
}
struct Person: FullyNamed {
	var fullName: String
}
var john = Person(fullName: "John Appleseed")
john.fullName = "Zedd" // ok
```  

　　👉 연산 프로퍼티 get  
```swift
protocol FullyNamed {
	var fullName: String { get set }
}
struct Person: FullyNamed {
	var name: String // 실제 값 저장될 저장 프로퍼티
	var fullName: String {
		return name // error! error: type 'Person' does not conform to protocol 'FullyNamed'
	}
}
var john = Person(name: "John Appleseed")
```  
　　👉 연산 프로퍼티 get/set  
```swift
protocol FullyNamed {
	var fullName: String { get set }
}
struct Person: FullyNamed {
	var name: String // 실제 값 저장될 저장 프로퍼티
	var fullName: String {
		get {
			return name
		}

		set {
			name = newValue
		}
	}
}
var john = Person(name: "John Appleseed")
john.fullName = "Zedd" // ok
print(john.fullName) // ok
```  

<br>

## Any 🆚 AnyObject
👉 Any는 함수 타입을 포함한 모든 타입의 인스턴스를 나타낼 수 있는 프로토콜  
👉 반면, AnyObject는 클래스 타입의 인스턴스만을 나타낼 수 있는 프로토콜  

<br>

## 객체 지향 프로그래밍 🆚 프로토콜 지향 프로그래밍
👉 객체 지향 프로그래밍  
　　👉 상속을 통해 수직적으로 타입을 확장하는 구조  
　　👉 하나의 서브클래스는 하나의 슈퍼클래스만 가질 수 있다는 제한이 있음  
　　👉 슈퍼클래스를 그대로 상속 받기에 불필요한 변수와 메소드를 모두 물려 받아야 하는 단점  
👉 프로토콜 지향 프로그래밍  
　　👉 프로토콜 확장을 통해 수평적으로 타입을 확장하는 구조  
　　👉 상속과는 다르게 다수의 프로토콜을 가지는 것이 가능  
　　👉 부모 프로토콜과 자식 프로토콜 사이가 서로 독립적이기에 불필요한 프로퍼티나 메소드를 갖지 않게 할 수 있음  

<br>

## map
👉 컬렉션이 보유한 각 값들을 매개변수로 전달받은 함수에 적용한 후 새로운 컬렉션을 반환하는 함수  

<br>

## filter
👉 컬렉션이 보유한 값들 중 매개변수로 전달받은 함수의 결과가 True인 값만 새로운 컬렉션에 넣어 반환하는 함수  

<br>

## reduce
👉 초기값에 컬렉션이 보유한 각 값들을 매개변수로 전달받은 함수에서 모두 계산하여 연산 결과로 반환하는 함수  

<br>

## flatMap 🆚 compactMap
👉 기존의 flatMap은 배열을 flatten하게 만들어 주고, nil을 제거하며, 옵셔널 바인딩을 하는 역할  
　　👉 Swift 4.1부터 flatMap은 2차원 배열을 1차원 배열로 만드는 역할  
👉 Swift 4.1부터 1차원 배열에서 nil을 제거하고 옵셔널 바인딩을 하고 싶을 때 compactMap을 사용  
　　👉 compactMap은 2차원 배열을 1차원 배열로 만들지 않음  
👉 nil이 포함된 2차원 배열에서 flatmap과 compactmap을 순서대로 체이닝 연결하면 1차원 배열로 nil을 제거하고 옵셔널 바인딩을 해줄 수 있음  
👉 1차원 배열에서는 동일한 결과  

<br>

## Swift의 sort() 구현 방식?
👉 Insertion Sort와 Merge Sort가 합쳐진 형태인 Tim Sort로 구현되어 있음  
👉 시간 복잡도 : 최선의 경우 O(n), 최악의 경우 O(nlogn)  

<br>

## Result
👉 성공과 실패에 대한 결과 값을 반환하고 싶을 때 사용하는 타입  
👉 Result 타입은 enum이며, 두 개의 제네릭한 결과를 리턴  
　　👉 Failure 타입은 Error를 상속받은 타입이어야 함  
　　👉 Success 타입은 void, string, int 등 값 타입을 사용해도 됨  

<br>

## Subscripts
👉 컬렉션, 리스트, 시퀀스 등 집합의 특정 요소에 쉽게 접근할 수 있는 문법  
👉 배열에서는 인덱스를 통해, 딕셔너리에서는 키 값을 통해 접근  
👉 ex)
```swift
var dict = ["Kim": 1, "Lee": 2]
dict["Park"] = 3 // Subscript 문법

var arr = [3, 2, 4, 8]
arr[0] = 1 // Subscript 문법
print(arr[0]) // Subscript 문법
```  

<br>

## String of Swift
👉 string은 값 타입으로 분류되며, character의 collection  
👉 character는 각각 다른 크기의 메모리를 차지할 수 있는 유니코드를 준수하기 때문에 Subscript로 접근 X  
👉 또한, character 타입은 힙 영역에 간접적으로 저장되기에, 따라서, String은 값 타입이지만 힙 할당이 발생  

<br>

## String vs NSString
👉 String  
　　👉 구조체, 값 타입  
👉 NSString  
　　👉 클래스, 참조 타입  

<br>

## NSAttributedString vs NSMutableAttributedString
👉 NSAttributedString  
　　👉 텍스트 자체에 스타일을 설정할 수 있는 텍스트 타입  
👉 NSMutableAttributedString  
　　👉 NSAttributedString의 특정 범위에 다양한 스타일(색상, 자간 등)을 설정할 수 있는 텍스트 타입  

<br>

## KVC 🔥
👉 Key-Value Coding  
👉 객체의 값을 직접 가져오지 않고, Key 또는 KeyPath를 이용해서 간접적으로 데이터를 가져오거나 수정하는 방법  
👋 [Link][Link4]  

<br>

## KVO 🔥
👉 Key-Value Observing  
👉 객체의 프로퍼티의 변경사항을 다른 객체에 알리기 위해 사용하는 코코아 프로그래밍 패턴  
👉 Model과 View와 같이 논리적으로 분리된 파트간의 변경사항을 전달하는데 유용  
👉 NSObject를 상속한 클래스에서만 KVO를 사용할 수 있음  
👋 [Link][Link5]  

<br>

## Codable
👉 자신을 외부 표현으로 인코딩할 수 있는 유형인 Encodable과 외부 표현으로부터 자신을 디코딩할 수 있는 유형인 Decodable로 구성된 프로토콜  
👉 주로, API에서 JSON Data를 다룰 때 사용  
　　👉 JSON Data 중 필요한 데이터를 모델로 정리한 Struct, Class 혹은 Enum을 통해 사용  

<br>

## CodingKey
👉 Codable 프로토콜에서 주로 JSON Key를 사용자가 정의한 프로퍼티에 매핑하기 위해 사용하는 프로토콜  
👉 ex)  
```swift
struct Coffee: Codable {
    var name: String

    enum CodingKeys: String, CodingKey {
        case name = "order_Drink_Name"
    }
}
```  

<br>

## Hashable & Equatable
👉 Hashable  
　　👉 채택한 타입이 유일한 값으로 구분될 수 있게 하는 프로토콜  
　　👉 내부의 hash function을 통해 해시 값을 결정  
　　👉 Hashable은 Equatable 프로토콜을 상속하고 있음  
　　　　👉 H가 E를 상속해야 하는 이유  
　　　　　　👉 객체의 동일 여부는 명확한 판단 기준을 필요로 함  
　　　　　　👉 Equatable : 값의 비교가 가능함을 보장해주는 프로토콜  
　　　　　　👉 ==, != 연산자를 정의하여 객체의 동일 여부의 기준을 결정함  
　　　　　　　　👉 즉, Equatable 프로토콜을 상속 받아 Hashable 타입이 객체의 동일 여부를 판단할 수 있도록 함  

<br>

## Identifiable
👉 Hashable 프로토콜을 준수하며, id 프로퍼티 하나만 가지는 아주 단순한 프로토콜  
👉 채택한 타입의 id를 통하여 고유 개체를 비교 및 구분하게 되는 방식  
👉 UUID : 범용 고유 식별자로, 고유하게 식별하기 위해 만들어진 개념  
　　👉 총 36개 문자(32개 문자와 4개의 하이픈)으로 구성되어 있음  

<br>

## CaseIterable
👉 enum 열거형의 값들을 배열 컬렉션과 같이 순회할 수 있도록 해주는 프로토콜  
👉 주로 allCases 타입 프로퍼티와 함께 많이 쓰임  

<br>

## Mutating
👉 Swift에서 Class는 참조 타입이며, Struct와 Enum은 값 타입임  
👉 값 타입의 프로퍼티는 기본적으로 메소드 내부에서 수정할 수 없음  
👉 수정이 필요한 경우 Mutating 키워드를 사용하여 수정이 가능해 짐  
　　👉 메소드가 종료될 때 변경한 모든 내용을 기록하기 때문  

<br>

## Extension
👉 이미 존재하는 클래스, 구조체, 프로토콜 등의 타입에 새로운 기능을 추가하는 것  
👉 연산 프로퍼티, 메소드, 프로토콜 등을 추가할 수 있음  
👉 원본 소스 코드에 접근할 수 없는 유형을 확장하는 기능도 포함되어 있음  
👉 extension 내부에서 함수 오버라이딩 가능한지?  
　　👉 해당하는 메소드가 Objective-C와 호환되는 경우 오버라이딩이 가능은 하지만, 일반적으로 권장되는 방법은 아님  
　　👉 그 이유는, extension은 추가적인 기능의 확장을 사용하는 개념이기 때문  

<br>

## Defer
👉 함수 안에서 작성되는 클로저  
👉 작성된 위치와 상관없이 함수 종료 직전에 실행되는 구문  
👉 호출되는 순서  
　　👉 하나의 스코프에서 여러 defer를 사용할 경우 스택처럼 쌓임  
　　👉 가장 먼저 넣은 defer 코드가 가장 마지막에 호출됨  
　　👉 가장 마지막에 넣은 defer 코드가 가장 먼저 호출됨  
👉 defer가 호출되기 전에 해당 스코프가 에러 등으로 인해 종료되거나, 리턴 값이 Never(비반환)인 경우에는 defer가 호출되지 X  

<br>

## Closure
👉 Named Closure  
　　👉 일반적으로 이름이 있는 함수  
　　👉 ex)  
```swift
func hello() {
    print("hello")
}
```  
👉 Unnamed Closure  
　　👉 이름 없이 사용하는 익명함수  
　　👉 일급 객체 특징을 갖고 있음  
　　👉 클로저는 Named C- & Unnamed C- 모두 포함하지만, 보통 Unnamed C-를 클로저라 함  
　　👉 ex)  
```swift
let closure = { (name: String) -> String in
    return "Hello, \(name)"
}
``` 

<br>

## Escaping Closure
👉 @escaping 키워드가 붙은 클로져  
👉 함수가 리턴된 후 함수의 스코프 밖에서 실행할 수 있는 클로져  
👉 함수가 리턴된 후 클로져를 실행할 수 있어 비동기 작업을 가능하게 해준다는 특징이 있음  
👉 함수의 매개변수로 클로져를 전달하는 방식  
　　👉 함수의 파라미터로 전달된 클로저는 기본적으로 함수 내부 스코프 안에서만 사용이 가능하여, 외부 변수에 담을 수 없음  
　　👉 즉, 기본적으로 탈출 불가능하다는 속성을 가지고 있음  
　　👉 또한, 클로저가 어떤 함수에 파라미터로 넘어간다면, 그 함수가 끝나 리턴 되기 이전에 해당 클로저가 반드시 실행됨  
　　👉 즉, 해당 함수가 끝나게 되면 파라미터로 넘어간 클로저는 사용이 불가능  

<br>

## Swift Access Control(접근 제어자)
👉 open  
　　👉 모듈 외부에서 access 가능  
👉 public  
　　👉 open과 동일하지만 외부 상속과 override 불가능  
👉 internal(default 값)  
　　👉 같은 모듈 안에서 access 가능  
👉 fileprivate  
　　👉 같은 파일 안에서 access 가능  
👉 private  
　　👉 같은 스코프 안에서 access 가능  

<br>

## Copy On Write
👉 데이터 복사 시 실제로 값을 복사하지 않고 단순히 값을 참조만 하다가 데이터 변경이 발생될 시 값을 복사해 변경하는 기법  
👉 Collection Type을 복사해서 사용할 때 일어남  
👉 단순히 값을 참조만 하다가 데이터 변경이 발생될 시 값을 복사하여 불필요한 복사를 줄이는 매커니즘  
👉 기존의 오버헤드를 줄일 수 있음  
👉 생성되는 사본 수를 확인하기 위해 Reference Count를 계산해야 한다는 단점이 존재  


<br>
<br>

# 💛 iOS

## iOS 앱 실행 흐름
👉 iOS 앱은 Objective-C 기반으로 돌아가기 때문에 앱은 main 함수에서 시작함  
　　👉 다만, iOS의 핵심 라이브러리인 UIKit framework가 main 함수를 관리하기 때문에 앱 개발자들이 직접 main 함수에 코드를 작성하지 않음  
👉 UIKit은 main 함수를 다루는 과정에서 UIApplicationMain 함수를 호출  
👉 UIApplicationMain은 UIApplication 싱글톤 객체를 생성  
　　👉 UIApplication 객체를 통해 앱 개발자는 앱의 실행에 부분적으로 관여할 수 있게 됨  
👉 UIApplication은 @main 어노테이션이 있는 클래스를 찾아 app Delegate 객체를 생성하고 Delegate를 위임  
　　👉 @main  
　　　　👉 program의 entry point(프로그램이 시작하는 지점)를 알려주는 속성  
　　　　👉 Swift 5.3 이후 @UIApplicationMain에서 @main으로 변경됨  
👉 Info.plist 파일에서 앱 구성에 필요한 데이터를 로드, Main Nib 파일을 사용하는 경우에는 이 과정에서 로드됨  
👉 UIApplication은 Main Run Loop를 생성하는 등 실행에 필요한 준비를 마무리  
👉 준비가 완료되면, app Delegate의 didFinishlaunchingWithOptions를 호출  

<br>

## UIApplication
👉 UIApplication은 UIApplicationMain에서 만들어지는 싱글톤 객체  
　　👉 UIApplication.shared 형태로 앱 전역에서 접근이 가능  
　　👉 역으로, UIApplicationMain 함수는 UIApplication 싱글톤 객체를 만드는 함수  
👉 app Delegate를 생성해 Delegate를 위임하고, Main Run Loop를 생성하는 역할을 담당  

<br>

## Main Run Loop
👉 유저가 일으키는 이벤트들을 처리하는 프로세스  
👉 UIApplication 객체는 앱이 실행될 때, Main Run Loop를 생성 및 실행하고 이 Loop를 통하여 View 업데이트나 View 관련 이벤트를 처리함  
👉 View와 관련이 되어 있기 때문에, Main Thread에서 실행됨  
👉 이벤트 처리 과정  
　　👉 버튼 터치와 같은 유저 이벤트 발생  
　　👉 시스템을 통해 이벤트가 생성됨  
　　👉 UIKit 프레임워크를 통해 생성된 port로 해당 이벤트가 앱에 전달됨  
　　👉 이벤트는 앱 내부적으로 Queue의 형태로 정리되고, Main Run Loop에 하나씩 Mapping 됨  
　　👉 UIApplication 객체는 이때, 가장 먼저 이벤트를 받는 객체로 어떤 것이 실행되어야 하는 지를 결정  
👉 발생한 이벤트들을 모두 처리하고 권한이 다시 Main Run Loop로 돌아오는 시점을 update cycle이라 함  
👋 [Link][Link2]  

<br>

## 이벤트는 어떤 형태로 전달되며, 터치 이벤트는 다른게 있는지?
👉 이벤트는 UIEvent 객체로 전달됨  
👉 터치 이벤트는 UITouch 객체로 관리되고 UIEvent 객체를 통해 접근할 수 있음  
👉 UITouch 객체는 터치된 위치, 터치 강도, 움직임 등의 정보를 포함  

<br>

## UIControl
👉 사용자에게 보여지는 View가 사용자와 상호작용할 수 있게끔 능력을 부여해주는 클래스  
👉 Target-Action 매커니즘을 이용해 사용자의 액션들을 앱에 전달  
👉 Target-Action 매커니즘은 addTarget 메소드를 이용하여 구현  
👉 addTarget의 파라미터 3가지  
　　👉 target : 액션을 담당할 객체를 설정하는 파라미터, 주로 self  
　　👉 action : 액션에 대한 행위를 정의한 메소드를 선택하는 파라미터, #selector(objc)  
　　👉 controlEvents : 어떤 이벤트가 발생할 때마다 액션을 실행시킬 것인지 지정하는 파라미터  

<br>

## #selector
👉 #selector는 Objective-C 메서드의 이름을 참조하여 메서드를 선택하는 역할  
👉 @objc는 Swift로 작성한 메서드를 Objective-C로 인식하게 하려고 붙임  
👉 Objective-C와의 호환성을 위해 반드시 @objc 키워드를 붙여줘야 함  

<br>

## App LifeCycle
👉 App의 실행 및 종료 등 시스템이 발생시키는 Event에 의해 App의 상태가 전환되는 일련의 과정을 뜻함  
<br>
👉 iOS 13 이후 (SceneDelegate.swift 있음)  
![scene life cycle](https://docs-assets.developer.apple.com/published/c834d5ac04/scene-state@2x.png)
　　<br>
　　👉 Unattached  
　　　　👉 Scene이랑 연결되지 않은 상태  
　　　　　　👉 앱이 실행되지 않은 Not Running과 차이가 있음  
　　👉 Foreground Inactive  
　　　　👉 실행 중이지만 이벤트를 받고 있지 않은 상태  
　　　　👉 앱 실행 중 알림 등으로 화면이 덮여 앱이 실질적으로 이벤트는 받지 못하는 상태  
　　　　　　👉 시리가 켜짐  
　　　　　　👉 전화 수신  
　　　　　　👉 배터리 부족 알림  
　　👉 Foreground Active  
　　　　👉 애플리케이션이 실질적으로 활동하고 있는 상태  
　　👉 Background  
　　　　👉 백그라운드 상태에서 실질적인 동작을 하고 있는 상태  
　　　　👉 ex) 백그라운드에서 음악을 실행  
　　👉 Suspend  
　　　　👉 백그라운드 상태에서 활동을 멈춘 상태  
　　　　👉 빠른 재실행을 위하여 메모리에 적재된 상태지만 실질적으로 동작을 하고 있지 않는 상태  
　　　　👉 메모리가 부족할 때 시스템이 강제종료  
　　⭐️ UISceneDelegate를 통해 Scene 기반 앱의 생명주기 이벤트를 처리함  
　　👉 앱이 Scene을 지원한다면, UIKit은 생명주기 이벤트를 개별적으로 분리하여 전송함  
　　👉 Scene : 실행되고 있는 하나의 앱 UI 인스턴스를 뜻하며 각자 개별적으로 자신의 생명주기를 가지고 있음  
　　　　👉 각자의 생명주기를 갖고 있기 때문에 각자 다른 상태에 있을 수 있음  
　　👉 Scene 기반 앱이더라도 추가적인 부가 이벤트를 처리하기 위해서는 UIApplicationDelegate가 필요함  
　　　　👉 앱 시작 및 종료 관련 이벤트  
<br>
🔥 iOS 12 이전 (SceneDelegate.swift 없음)  
![app life cycle](https://docs-assets.developer.apple.com/published/64a2e0dab8/app-state@2x.png)
　　<br>
　　👉 Not Running  
　　　　👉 실행되지 않았거나, 시스템에 의해 종료된 상태  
　　👉 Inactive  
　　　　👉 실행 중이지만 이벤트를 받고 있지 않은 상태  
　　　　👉 앱 실행 중 알림 등으로 화면이 덮여 앱이 실질적으로 이벤트는 받지 못하는 상태  
　　　　　　👉 시리가 켜짐  
　　　　　　👉 전화 수신  
　　　　　　👉 배터리 부족 알림  
　　👉 Active  
　　　　👉 애플리케이션이 실질적으로 활동하고 있는 상태  
　　👉 Background  
　　　　👉 백그라운드 상태에서 실질적인 동작을 하고 있는 상태  
　　　　👉 ex) 백그라운드에서 음악을 실행  
　　👉 Suspend  
　　　　👉 백그라운드 상태에서 활동을 멈춘 상태  
　　　　👉 빠른 재실행을 위하여 메모리에 적재된 상태지만 실질적으로 동작을 하고 있지 않는 상태  
　　　　👉 메모리가 부족할 때 시스템이 강제종료  
　　⭐️ UIApplicationDelegate를 통해 앱의 생명주기 이벤트를 처리함  
　　👉 Foreground는 메모리 및 시스템 리소스에 높은 우선 순위를 가지고 있음  
　　👉 Background에 있을 땐 가능한 적은 메모리 공간을 사용해야 하기 때문에 사용자의 이벤트를 받기 어렵다는 특징이 있음  
👋 [Link][Link11]  

<br>

## AppDelegate 🆚 SceneDelegate
👉 AppDelegate  
　　👉 AppDelegate는 이름 그대로 앱과 시스템의 연결을 위해 필요한 Delegate 메소드를 담고 있음  
　　👉 즉, 앱의 상태에 대응할 수 있는 메소드들이 들어있음  
　　👉 UIResponder와 UIApplicationDelegate를 상속 및 참조  
　　👉 iOS 13 이후, 더 이상 앱의 생명주기 이벤트를 관리하지 않음  
　　　　👉 앱의 가장 중요한 데이터 구조를 초기화  
　　　　👉 애플 푸쉬 알림 서비스와 같이, 실행 시 요구되는 모든 서비스를 등록하는 역할  
　　　　👉 앱의 Scene을 환경 설정 하는 역할  
　　👉 iOS 13 이후, Session LifeCycle에 대한 역할이 추가 되었음  
　　　　👉 Scene Session을 통해 앱에서 생성한 모든 Scene의 정보를 관리  
　　　　　　👉 Scene Session  
　　　　　　　　👉 Scene을 추적하는 Session 객체  
　　　　　　　　👉 Session에는 고유한 식별자와 Scene의 구성 세부사항이 들어 있음  
👉 SceneDelegate  
　　👉 AppDelegate의 역할 중 UI 생명주기 담당 역할을 SceneDelegate에서 하게 됨  
　　👉 UIResponder와 UIWindowSceneDelegate를 상속 및 참조  

<br>

## 앱 생명주기 관련 대표 메소드 + makeKeyAndVisible
👉 AppDelegate  
　　👉 application:willFinishLaunchingWithOptions: 애플리케이션이 최초 실행될 때 호출되는 메소드  
　　👉 application:didFinishLaunchingWithOptions: 애플리케이션이 실행된 직후 사용자의 화면에 보여지기 직전에 호출  
　　👉 applicationDidBecomeActive(_:): 애플리케이션이 Active 상태로 전환된 직후 호출  
　　👉 applicationWillResignActive(_:): 애플리케이션이 Inactive 상태로 전환되기 직전에 호출  
　　👉 applicationWillEnterForeground(_:): 애플리케이션이 Active 상태가 되기 직전, 화면에 보여지기 직전에 호출  
　　👉 applicationDidEnterBackground(_:): 애플리케이션이 백그라운드 상태로 전환된 직후 호출  
　　👉 applicationWillTerminate: 애플리케이션이 종료되기 직전에 호출  
👉 SceneDelegate  
　　👉 scene(_ willConnectTo: options:): scene이 앱에 추가될 때 호출  
　　👉 sceneDidDisconnect(_:): scene의 연결이 해제될 때 호출  
　　👉 sceneDidBecomeActive(_:): scene과의 상호작용이 시작될 때 호출  
　　👉 sceneWillResignActive(_:): scene과의 상호작용을 중지할 때 호출  
　　👉 sceneWillEnterForeground(_:): scene이 Foreground로 진입할 때 호출  
　　👉 sceneDidEnterBackground: scene이 Background에 진입한 후 호출  
👋 makeKeyAndVisible : key window로 설정  
　　👉 key window : window가 여러개 존재할 때, 가장 앞쪽에 배치된 window를 key window로 지칭  

<br>

## UIResponder
👉 앱에서 발생하는 이벤트들을 담고 있는 추상형 인터페이스 객체  
👉 이벤트가 발생하면 UIKit은 이를 처리하기 위해 앱의 First Responder에게 이를 전달하여 처리하도록 함  
　　👉 UIView, UIViewController 등 많은 UIKit의 핵심 객체들은 모두 UIResponder 인스턴스임  
　　👉 First Responder  
　　　　👉 이벤트를 처리하기에 가장 적절한 리스폰더 객체  
　　　　👉 발생한 이벤트의 타입을 기준으로 First Responder를 결정  
👉 주어진 Responder가 이벤트를 처리 하지 않을 경우, Responder Chain의 다음 Responder로 해당 이벤트를 전달  
　　👉 Responder Chain  
　　　　👉 UIKit이 모든 UIResponder를 엮어서 관리하는 체인  
　　　　👉 UIkit은 미리 정의된 규칙을 사용하여 리스폰더 체인을 동적으로 관리하고 어떤 객체가 이벤트를 수신한 다음에 어떤 객체를 선택할 지 결정  
　　　　👉 각 Responder는 next 프로퍼티로 자신의 다음 리스폰더를 참조하고 있음  
　　　　👉 next 프로퍼티를 오버라이딩해서 다음 리스폰더를 임의로 변경할 수 있음  
　　　　　　👉 becomeFirstResponder 메소드를 사용해서 특정한 뷰를 First Responder로 만들 수 있음  
　　　　　　　　👉 해당 객체를 지금 윈도우의 First Responder로 만들어 줄 것을 요청하는 함수
　　　　　　　　　　👉 하지만, 무조건 First Responder가 되는 것을 보장하지 않음  
　　　　　　　　👉 주로, 키보드를 올리는 액션을 취하기 위해 이 함수를 호출  
　　　　　　👉 반대로 resignFirestResponder 메소드도 존재함  
　　　　　　　　👉 해당 객체에게 지금 윈도우의 First Responder로서의 상태를 포기한다는 요청을 알리는 함수  
　　　　　　　　👉 주로, 키보드를 내리는 액션을 취하기 위해 이 함수를 호출  
　　　　👉 기본적으로 UIView ➡️ UIViewController ➡️ UIWindow ➡️ UIApplication ➡️ UIApplicationDelegate 순으로 이벤트가 전달됨  

<br>

## UIApplicationDelegate
👉 UIApplication 객체의 작업에 개발자가 접근할 수 있도록 하는 메소드들을 담고 있음  

<br>

## UIWindowSceneDelegate
👉 UIWindowSceneDelegate를 통해 Scene 기반 앱의 특별한 작업을 처리함  
👉 UISceneDelegate를 상속받는 서브클래스    

<br>

## UIWindow
👉 UIView의 하위 클래스로, 모든 View들의 컨테이너 역할을 함  
👉 UI에 배경을 제공하고, 중요한 이벤트를 처리하는 객체  

<br>

## View
👉 UIView 클래스의 인스턴스  
👉 화면의 직사각형 영역에 콘텐츠를 관리하고 보여주는 역할을 하는 UI의 기본 구성 요소  
👉 View는 사용자와 애플리케이션이 상호 작용하는 주요 방법이기 때문에 터치, 서브 뷰 관리, 이벤트 처리 등의 역할을 수행  
👉 UIbutton, UIImageView와 같은 모든 뷰 클래스의 상위 클래스  

<br>

## UIView Layer 객체
👉 UIView는 객체에 나타나는 콘텐츠들을 관리하는 CALayer 타입의 layer를 가지고 있음  
👉 즉, UIView는 이미지나 애니메이션들은 직접 제어하지 않고, View에게 작업을 주면 View 내부의 Layer 객체에서 처리  
👉 CA는 Core Animation 프레임워크의 약자로, UIKit보다 한 단계 낮은 저수준의 인터페이스를 제공하는 프레임워크  

<br>

## UIViewController
👉 모든 View Controller 객체의 상위 클래스로, UIKit으로 구성된 앱의 뷰 계층 관계를 관리하고 뷰를 그리는 로직을 담고 있음  
👉 데이터 변경에 따라 뷰를 업데이트하고, 뷰에서 발생하는 사용자 이벤트와 상호작용하는 등의 역할을 갖고 있음  
👉 UIViewController는 UIResponder를 상속하고, UIResponder는 NSObject를 상속  
　　👉 NSObject는 대부분의 Objective-C 클래스 계층 구조의 루트 클래스로, 하위 클래스에서 런타임 시스템 기능을 사용할 수 있도록 함  
　　　　👉 런타임 시스템은 Objective-C 용 운영체제 같은 것으로, 객체 생성 및 해제에 따른 메모리 영역 관리 등의 역할을 함  

<br>

## UINavigationController
👉 iOS 네비게이션 스택에 화면들을 쌓아서 화면 간 이동을 관리하는 컨테이너  
👉 네비게이션 바에서는 뒤로 가기 버튼과 커스터마이징한 버튼을 추가할 수 있음  
👉 관련 개념  
　　👉 navigationController?.navigationBar.prefersLargeTitles = true / false  
　　　　👉 네비게이션 바 타이틀에 큰 글씨를 출력할 수 있게함을 설정하는 속성  
　　　　👉 root에서 한 번만 설정 후, 각 화면에서 navigationItem.largeTitleDisplayMode로 지정  
　　　　　　👉 navigationItem.largeTitleDisplayMode = .always / .never  
　　　　　　　　👉 네비게이션 바 타이틀에 큰 글씨를 출력함 / 큰 글씨를 출력하지 않음  
　　👉 Navigation Prompt  
　　　　👉 navigation title 위쪽에 부가적인 설명을 할 수 있도록 설정하는 것  

<br>

## presentingViewController 🆚 presentedViewController
👉 ex) A에서 present B, B에서 present C를 한 경우  
　　👉 B의 presentedViewController C  
　　👉 B의 presentingViewController는 A  

<br>

## View LifeCycle
<br>
![view life cycle](https://docs-assets.developer.apple.com/published/f06f30fa63/UIViewController_Class_Reference_2x_ddcaa00c-87d8-4c85-961e-ccfb9fa4aac2.png)
👉 viewDidLoad()  
　　👉 뷰가 생성될 때, 가장 먼저 실행되는 메소드  
　　👉 특별한 경우가 아니라면 단 한 번 실행되기 때문에 초기화 할 때 사용  
　　　　🔥 super.viewDidLoad()를 제거하면?  
　　　　　　👉 상위 클래스의 viewDidLoad를 호출하지 않아도 문제는 일어나지 X  
　　　　　　👉 But, UIKit의 viewDidLoad가 언제 구현이 바뀔지 모르고, 내부에 중요한 초기화 코드가 들어갈 수도 있음  
　　　　　　👉 So, 당장 영향이 없더라도 super.viewDidLoad를 호출하는 것이 바람직하다고 생각  
👉 viewWillAppear()  
　　👉 뷰가 생성되기 직전에 항상 실행되는 메소드  
　　👉 뷰가 나타나기 전에 실행해야 하는 작업들을 처리할 때 사용  
👉 viewDidAppear()  
　　👉 뷰가 생성되고 난 뒤에 실행되는 메소드  
　　👉 데이터를 받아서 화면에 뿌려주거나 애니메이션 등의 작업을 하는 로직을 위치 시킴  
　　👉 ViewWillAppear에 로직을 넣었다가 뷰에 반영이 안되는 경우가 있기 때문  
👉 viewWillDisappear  
　　👉 뷰가 사라지기 직전에 실행되는 메소드  
👉 viewDidDisappear()  
　　👉 뷰가 사라지고 난 뒤에 실행되는 메소드  
👉 navigationController.pushViewController()  
<br>
<img src="{{ '/assets/cs/cs_im_3.png' }}" style="width: 400px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 present(), modalPresentationStyle = .default  
<br>
<img src="{{ '/assets/cs/cs_im_1.png' }}" style="width: 400px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 present(), modalPresentationStyle = .fullScreen  
<br>
<img src="{{ '/assets/cs/cs_im_2.png' }}" style="width: 400px; height: auto; margin-left: auto; margin-right: auto; display: block;">  

<br>

## assign 🆚 weak (Objective-C 개념)
👉 assign(unowned in swift)  
　　👉 객체의 retain count를 증가시키지 X  
　　　　👉 retain count  
　　　　　　👉 객체 하나가 다른 객체에 의해 참조되거나 소유된 횟수를 의미  
　　　　　　👉 ARC가 없던 시절에는 개발자가 메모리 관리를 직접 했어야 함  
　　　　　　👉 메모리를 관리하는 방법에 retain과 release 키워드 사용하였고, 이를 MRC(Manual Retain Count)라고 함  
　　　　　　　　👉 retain  
　　　　　　　　　　👉 객체의 레퍼런스 카운트를 증가 시킴  
　　　　　　　　　　👉 카운트되어 있으면 메모리에서 해제하지 않음  
　　　　　　　　👉 release  
　　　　　　　　　　👉 객체의 레퍼런스 카운트를 감소 시킴  
　　　　　　　　　　👉 객체를 더 이상 사용하지 않거나 메모리에서 해제하고 싶을 때 이 함수를 호출하여 레퍼런스 카운트를 감소 시킴  
👉 weak(weak in swift)  
　　👉 assign과 거의 동일하지만, assign은 객체가 소멸되어도 포인터 값이 변하지 않는 반면, weak는 객체가 해제되는 시점에 포인터 값이 nil이 됨  
　　👉 assign의 문제점은 객체가 해제되어도 포인터 값이 남아있어 접근하려다 죽는 경우가 생김  
　　👉 Objective-C는 기본적으로 nil에 접근할 때는 에러가 발생하지 X  
　　👉 마지막 강한 참조가 더 이상 객체를 가리키지 않으면 객체는 할당이 해제되고 모든 약한 참조는 dealloc 됨  

<br>

## 순환 참조(강한 순환 참조(Strong Reference Cycle), 강한 참조)
👉 두 가지 이상의 객체가 서로에 대한 강한 참조 상태를 가지고 있어 메모리에서 해제되지 않는 상태  
👉 Swift는 메모리를 자동으로 관리하기 위하여 ARC(Automatic Reference Counting)를 통해 메모리를 관리  
　　👉 ARC
　　　　👉 메모리 영역 중 힙 영역을 자동으로 관리해 주는 역할을 수행  
　　　　　　👉 자동으로 Reference Count를 계산하여 Count가 0이 되면, 즉, 인스턴스가 더 이상 필요없을 때, 사용된 메모리를 자동으로 해제  
　　　　　　👋 Swift에서 클래스 인스턴스, 클로저 등 참조 타입의 값은 모두 자동으로 힙에 할당됨  
　　　　　　👋 Swift는 ARC를 통해 힙에 할당된 메모리가 더 이상 참조되지 않으면 자동으로 해제해주기 때문에 free와 같이 따로 메모리 해제를 하지 않았던 것  
　　　　👉 ex) let sodeul = Human(name: "Sodeul", age: 26)  
　　　　　　👉 지역 변수 sodeul은 스택에 할당되고, 실제 인스턴스는 힙에 할당되며, sodeul엔 힙에 할당된 인스턴스의 주소 값이 들어가게 됨  
　　　　　　👉 인스턴스를 새로 생성할 때, 해당 인스턴스에 대한 RC가 증가하며, 힙에 같이 저장됨  
　　　　👉 + ex) let clone = sodeul  
　　　　　　👉 기존 인스턴스를 다른 변수에 대입할 때, 참조에 의해 인스턴스의 clone에 주소 값이 대입되며 RC가 증가하는 방식  
👉 서로 강한 참조를 하고 있는 경우, Reference Count가 0이 될 수 없어 Memory가 해제되지 않는 일이 발생  
👉 해결 방법  
　　👉 두 객체 중 하나의 강한 참조를 변경해주면 됨  
　　👉 강한 참조를 약한(weak) 참조 혹은 미소유(unowned) 참조로 변경하여 문제를 해결  
　　　　👉 약한 참조(weak)  
　　　　　　👉 인스턴스를 참조할 때 Reference Count를 증가시키지 않음  
　　　　　　👉 인스턴스가 메모리에서 할당 해제된 경우, 자동으로 nil이 할당되어 메모리가 해제됨  
　　　　　　👉 옵셔널일 때 사용  
　　　　👉 미소유 참조(unowned)  
　　　　　　👉 인스턴스를 참조할 때 Reference Count를 증가시키지 않음  
　　　　　　👉 인스턴스가 메모리에서 할당 해제될 때 nil로 초기화하지 않으며, nil이 되면 에러가 발생  
　　　　　　👉 따라서, 에러를 발생하는 것을 방지하기 위해 되도록 약한 참조를 사용하는 것을 권장  
　　　　　　👉 혹은, unowned로 가리키는 인스턴스가 먼저 메모리에서 해제될 일이 확실하게 발생하지 않을 때 사용할 것  
👋 [Link][Link3]  
👋 [Link][Link31]  

<br>

## Closure 강한 순환 참조 🔥
👉 클로저는 클래스처럼 참조 타입  
👉 클래스 인스턴스의 프로퍼티에 클로저를 할당할 때 클로저에 참조를 할당하기 때문에 강한 순환 참조가 발생할 수 있음  
👉 클로져의 본문이 인스턴스를 캡쳐(capture)할 때 클로저가 self를 캡쳐하게 되면서 강한 순환 참조가 발생할 수 있음  
　　👉 캡쳐  
　　　　👉 클로저의 본문에서 인스턴스의 프로퍼티에 접근하거나 인스턴스의 메소드를 호출하는 것  
👉 해결 방법  
　　👉 클로저와 클래스 인스턴스 사이에서 강한 순환 참조 해결법은 클로저의 선언부에서 캡쳐 목록을 정의하는 것으로 해결  
　　👉 약한 참조 혹은 미소유 참조로 선언하여 정의  
　　　　👉 캡쳐 목록  
　　　　　　👉 클로저 본문에서 하나 이상의 참조 타입을 어떤 참조로 캡쳐할 지를 정의하는 리스트  
　　　　　　👉 대괄호([]) 키워드를 사용하여 정의  

<br>

## Cocoa Touch Framework
👉 Foundation과 UIKit을 포함하며 iOS 애플리케이션을 개발할 때 사용하는 프레임워크를 Cocoa Framework라 함  
👉 그 중 터치와 관련된 애플리케이션을 개발할 때 사용하는 프레임워크를 Cocoa Touch Framework라 함  

<br>

## Foundation
👉 Cocoa Touch Framework에 포함된 Framework  
👉 Primitive Type, Collection Type 및 데이터 저장, 네트워킹 등 앱의 기본적인 기능들을 제공하는 프레임워크  

<br>

## UIKit
👉 iOS 앱을 만들고, User Interface를 구성하는 데 필수적인 프레임워크  
👉 UI는 Main Thread 혹은 Dispatch Main Queue에서만 동작해야 함  
　　👉 결론은, 애플에서 그렇게 설계하였기 때문  
　　👉 UIKit는 Thread-safe 하지 않게 설계되지 않았음  
　　　　👉 UIKit과 같은 매우 큰 프레임워크의 모든 속성을 Thread-safe 하게 설계하는 것은 현실적으로 불가능하며, 느려짐과 같은 성능 저하가 발생할 수 있음  
　　🔥 Main Run Loop가 뷰의 업데이트를 관리하는 View Drawing Cycle을 통해 뷰를 동시에 업데이트를 하는 매커니즘으로 설계하여 동작하고 있는데, Main Thread가 아닌 Background Thread가 각자의 Run Loop로 그런 동작을 하게 되었을때, 뷰가 자기 멋대로 동작할 수 있음  

<br>

## GCD(Grand Central Dispatch)
👉 C언어 기반의 저수준 API  
👉 C언어 기반이기에 NSOperation보다 가볍고 성능적으로 우수  
👉 Block(Closure)로 구현되어 있어 코드 가독성이 좋고 간단하게 사용 가능하다는 장점이 있음  
👉 KVO, 작업 취소/재사용 등은 직접 구현하여야 한다는 단점이 있음  
👉 DispatchQueue를 통해 Multi-Threading을 지원  
　　👉 DispatchQueue  
　　　　👉 앱의 Main Thread 혹은 Background Thread에서 작업 실행을 순차적 혹은 동시적으로 관리하는 객체  
　　　　　　👉 MainQueue  
　　　　　　　　👉 시스템 작동 시 자동으로 생성  
　　　　　　　　👉 일반적으로 순차적으로 작업을 실행  
　　　　　　　　👉 UI 관련 작업은 반드시 이 메인큐에서 동작해야 함  
　　　　　　👉 GlobalQueue  
　　　　　　　　👉 메인 큐에서 동작하는 작업에 영향을 주지 않기 위하여 백그라운드에서 동작하는 큐  
　　　　　　　　👉 일반적으로 동시적으로 작업을 실행  
　　　　　　　　👉 네트워크 통신과 같이 끝나는 시간을 정확히 알 수 없는 작업을 처리할 때 사용  
　　　　　　　　👉 끝나는 시간을 정확히 알 수 없기에 Qos(Quality Of Service)를 이용해 우선순위를 정함  
　　　　　　　　　　🔥 Qos 우선 순위 5가지  
　　　　　　　　　　　　👉 Userinteractive : 바로 수행되어야 할 것 (가장 중요한 것)  
　　　　　　　　　　　　👉 Userintiated : Userinteractive보단 덜 중요하지만 사용자가 기다리고 있는 것  
　　　　　　　　　　　　👉 Userdefault : 우선 순위를 신경쓰지 않는 것 (중요한 정도가 상관없는 것)  
　　　　　　　　　　　　👉 Utility : 시간이 조금 오래 걸리는 것  
　　　　　　　　　　　　👉 background : 사용자한테 당장 인식될 필요가 없는 것  

<br>

## NSOperation
👉 Objective-C 기반의 고수준 API  
👉 고수준 API인 만큼, GCD엔 없는 기능인 KVO, 작업 취소/재사용 등의 기능을 제공해서 사용하기 편하다는 장점이 있음  
👉 내부적으로 C로 구현된 GCD를 고수준 언어로 Wrapping하여, GCD보다 다소 무겁고 약간의 오버헤드를 발생시킴  
👉 NSOperationQueue에 NSOperation을 추가하여 실행시키는 방법  
　　👉 NSOperationQueue는 병렬 큐로 동작함  

<br>

## AutoLayout
👉 제약 조건(Constraints)에 따라 뷰 계층 구조에 있는 모든 뷰의 크기와 위치를 동적으로 지정하는 것  
　　👉 제약 조건  
　　　　👉 다른 객체를 이용해 상대적인 제약을 주는 것  
👉 코드를 이용하여 오토 레이아웃을 작성하는 이유 및 방법 1+2가지  
　　👉 Storyboard 방식은 Index 시간 및 Build 시간에 악영향을 미침  
　　👉 XCode 자체 오류로 인해 Storyboard 내 View Controller가 Inspector 상에 제대로 보이지 않을 수 있음  
　　👉 SnapKit  
　　　　👉 iOS에서 오토레이아웃을 스토리 보드 없이, 쉽고 간략하게 설정해줄 수 있는 기능을 가진 라이브러리  
　　　　👉 snp.makeConstraint를 이용하여 오토레이아웃을 설정  
　　🔥 NSLayoutContraint  
　　　　👉 제약사항을 파라미터로 하나씩 표현해 객체를 생성하고 이를 isActive하여 오토레이아웃 설정  
　　🔥 NSLayoutAnchor  
　　　　👉 NSLayoutConstraint를 좀 더 쉽게 활용하기 위해 만들어진 팩토리 클래스  
　　　　👉 Anchor를 기준으로 생성하기 때문에 좀 더 직관적이라는 장점이 있음  
👉 코드로 UI를 작성 시  
　　👉 (private) lazy var  
　　　　👉 항상 필요하지 않은 인스턴스를 다룰 때 사용  
　　👉 let  
　　　　👉 항상 보여지게 되는 인스턴스를 다룰 때 사용해도 무방하지만, 되도록 lazy var를 이용하는 것이 좋음  
　　　　　　👉 메모리 관리와의 연관성 (필요하지 않은데 let으로 선언하는 경우, 이는 결국 메모리 낭비이므로)  

<br>

## offset vs inset (Snapkit)
👉 offset  
　　👉 element 와의 간격에 사용  
　　👉 현재 뷰 constraint = 슈퍼뷰 constraint + offset 값, 보통 bottom과 right는 마이너스 부호를 갖게 됨  
👉 inset  
　　👉 superView 와의 간격에 사용  
　　👉 inset의 경우에는 UIEdgeInsets을 주었다고 생각하면 되기에, bottom과 right가 음수 값이 아니라 양수 값임을 유의  

<br>

## Storyboard
👉 앱의 흐름을 시각적으로 표현하고 화면을 구성할 때 사용  
👉 시각적으로 뷰를 확인할 수 있어 오토레이아웃이나 뷰의 구성을 쉽게 확인하고 수정할 수 있음  
👉 But, 뷰의 재사용이 어렵고 화면이 많아지면 프로젝트를 로드하는 속도가 느려짐  
👉 And, 협업 시 여러 사람이 스토리보드를 수정하게 되면 쉽게 충돌이 발생함  

<br>

## Segueway
👉 화면 전환용 객체  
👉 Storyboard에서 출발지와 목적지를 직접 지정하는 방식  

<br>

## @IBDesignable 🆚 @IBInspectable
👉 @IBDesignable  
　　👉 스토리 보드에서 실시간으로 확인이 가능하게 만드는 키워드  
👉 @IBInspectable  
　　👉 스토리 보드에서 해당 프로퍼티 설정 값을 변경 시킬 수 있게 만드는 키워드  


## SafeArea
👉 상단의 노치 or 네비게이션 바나 하단의 홈바 or 탭바와 같은 이런 시스템에 의해 가려지지 않고 보여지게 되는 영역  
👉 기본적으로 앱이 이 영역들을 침범하지 못하도록 SafeArea를 기준으로 오토레이아웃을 설정  

<br>

## Left(Right) 🆚 Leading(Trailing) Constraint
👉 Left(Right)  
　　👉 좌측 및 우측의 제약  
👉 Leading(Trailing)  
　　👉 Text 시작 및 종료 지점의 제약  
　　👉 대부분의 경우, 좌측에서 우측으로 문자가 표현됨  
　　👉 아랍권의 경우, 우측에서 좌측으로 문자가 표현됨  

<br>

## (Content) Hugging 🆚 (Compression) Resistance
👉 (Content) Hugging  
　　👉 최대 크기 제한 관련 속성  
　　👉 hugging의 우선순위가 높을수록 자신의 크기를 유지하고 작을수록 크기가 늘어나게 됨  
👉 (Compression) Resistance  
　　👉 최소 크기 제한 관련 속성  
　　👉 resistance의 우선순위가 높을수록 자신의 크기를 유지하고 작을수록 크기가 작아지게 됨  

<br>

## Intrinsic Size
👉 컨텐츠의 본질적인 크기를 뜻함  
👉 Intrinsic Content Size를 가지면 autolayout을 지정하지 않아도 에러가 발생하지 않음  
　　👉 UILabel, UIButton, UITextField 등이 Intrinsic Size를 가짐  
👉 But, UIView는 Intrinsic Content Size를 가지고 있지 않기 때문에 직접 Constraint를 지정해주지 않으면 레이아웃 에러가 발생함  
👉 추가적으로, 커스텀 뷰를 생성할 때는 invalidateIntrinsicContentSize() 메소드를 사용하여 view의 컨텐츠 크기가 바뀌었을 때 size를 갱신하고 autolayout이 업데이트 되도록 구현  

<br>

## CustomView 생성 방법
👉 Xib 파일을 만들고 UIView를 상속받는 클래스를 생성해 둘을 연결하는 방법  
👉 UIView를 상속받는 커스텀 뷰 클래스를 만들고 코드로 정의해 내부에서 레이아웃까지 설정하는 방법  

<br>

## Autoresizing
👉 Autoresizing mask는 SuperView의 프레임이 변경될 때, SubView의 프레임이 변경되는 방식  

<br>

## Frame 🆚 Bounds
👉 Frame  
　　👉 슈퍼뷰의 좌표 시스템에서 뷰의 위치와 크기를 나타냄  
　　👉 Frame의 origin은 슈퍼뷰의 원점에서 얼마나 떨어져 있는가를 나타냄  
　　👉 Frame의 origin을 변경하면 자신의 위치가 이동  
　　👉 Frame의 size는 슈퍼뷰에서 차지하고 있는 크기를 나타냄  
　　　　👉 회전된 사각형을 생각  
👉 Bounds  
　　👉 자신의 좌표 시스템에서 뷰의 위치와 크기를 나타냄  
　　👉 Bounds의 origin은 항상 (0, 0)임  
　　👉 Bounds의 origin을 변경하면 viewport가 이동하기 때문에 서브뷰들이 이동하는 것 처럼 보이게 됨  
　　　　👉 만약, 왼쪽으로 스와이프해서 스크롤하면 bounds의 x좌표가 증가함  
　　　　👉 스크롤 뷰는 스크롤 될 때마다 스크롤 뷰의 Bounds를 업데이트하는 영역  
　　👉 Bounds의 size는 자신 자체의 크기를 나타냄  
👉 이러한 차이로, Frame은 뷰의 위치 및 크기를 설정할 때 사용, Bounds는 뷰의 실제 크기를 알고 싶을 때 사용함  

<br>

## Delegate 🆚 NotificationCenter
👉 객체끼리 데이터를 주고 받기 위해 사용하는 개념  
👉 Delegate  
　　👉 특정 객체에서 발생한 이벤트를 다른 객체에 전달할 수 있게 해주는 iOS 디자인 패턴  
　　👉 프로토콜을 정의하고 대신 처리할 객체에서 이를 채택하고 구현하는 방식  
　　👉 객체 간의 참조 타입을 주고받는 Delegate에 따로 처리가 없다면 retain 현상이 일어날 수 있어 weak로 선언하여 retain을 방지해야 함  
　　　　👉 retain : 메모리 누수 현상  
　　👉 주로 이벤트를 1:1로 전달할 때 많이 사용  
　　👉 제 3의 객체를 필요로 하지 X, 확실한 처리 가능  
　　👉 많은 양의 코드 필요, 다수의 객체에게 이벤트를 알리고 싶을 경우 비효율적  
👉 NotificationCenter  
　　👉 앱 내에서 아무데서나 메세지를 던지면 앱 내에서 아무데서나 메시지를 받을 수 있도록 하는 기능  
　　👉 싱글톤 객체인 NotificationCenter를 통해 이벤트 발생 내용을 addObserver한 객체들에게 post하는 방식  
　　👉 주로 이벤트를 1:N로 전달할 때 용이  
　　👉 Delegate 보다 적은 양의 코드 필요, 다수의 객체에게 이벤트를 알리고 싶을 경우 효율적  
　　👉 제 3의 객체를 반드시 필요로 함, 확실하게 처리 되었는지 알기 어려움  

<br>

## Delegate 🆚 DataSource
👉 Delegate  
　　👉 Table의 동작을 담당하는 역할  
　　👉 대표 관련 func : didSelectRowAt  
👉 DataSource  
　　👉 Data를 받아 View를 그리는 역할  
　　👉 대표 관련 func : cellForRowAt, numberOfRowsInSection  

<br>

## TableView DataSource 필수 메소드
👉 numberOfRowsInSection  
　　👉 섹션마다 표시할 셀의 개수를 반환  
👉 cellForRowAt  
　　👉 어떤 셀을 사용할지 반환  
👉 code)
```swift
func tableView(UITableView, numberOfRowsInSection: Int)
func tableView(UITableView, cellForRowAt: IndexPath)
```  

<br>

## 하나의 View Controller 코드에서 여러 TableView Controller 처리
👉 각 tableview에 따라 처리하도록 구현  
👉 code)
```swift
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    // indexPath : tablewView/collectionView의 행을 식별하는 인덱스 경로 : [a, b] 형태 (a : section, b : row/item)
    switch tableView {
    case firstTableView:
        let cell = firstTableView.dequeueReusableCell(withIdentifier: "firstCell") as! UITableViewCell
        cell.textLabel?.text = data1[indexPath.row]
        // indexPath.row : tableView 섹션 내의 를 위치를 식별하는 인덱스 경로
        // + indexPath.item : collectionView 섹션 내의 위치를 식별하는 인덱스 경로
        return cell

    case secondTableView:
        // ...
        
    default:
        return UITableViewCell()
    }
}
```  

<br>

## TableView 🆚 CollectionView
👉 Cell을 기반으로 여러 데이터를 표현할 수 있는 View  
👉 TableView  
　　👉 단일 열에 배열된 행을 사용해 데이터를 표시하는 뷰  
　　👉 기본적으로 수직 스크롤 만이 가능  
　　👉 간단한 목록으로 데이터를 표현할 때 사용할 때 유용  
👉 CollectionView  
　　👉 커스텀 가능한 레이아웃을 사용해 여러 데이터를 관리하고 표시하는 뷰  
　　👉 테이블뷰에서 할 수 있는 기능을 전부 가지고 있으면서 여러 열과 행을 가질 수 있고 수직/수평 스크롤이 모두 가능  
　　👉 데이터 표현 방식을 다양한 모습으로 커스터마이징할 때 사용할 때 유용  
　　👉 cell의 위치와 배열을 원하는 대로 커스터마이징 할 수 있다는 장점  

<br>

## dequeueReusableCell()
👉 TableView, CollectionView의 셀을 생성할 때 메모리 효율성을 위하여 dequeueReusableCell(withIdentifier:) 메소드를 통해 셀을 재사용함  
👉 dequeueReusableCell(withIdentifier:) 메소드는 객체를 반환하기 직전에 prepareForReuse() 메소드가 실행됨  
👉 셀을 재사용 하면 이전에 설정한 속성이 그대로 남아있게 되는데, prepareForReuse()를 통해 이전의 속성을 초기화할 수 있음  

<br>

## UICollectionViewLayout 🆚 UICollectionViewFlowLayout
👉 UICollectionViewLayout  
　　👉 CollectionView안에 있는 구성요소들의 시각적 배열과 조직을 구성하는 역할  
　　👉 대표 관련 func : didSelectItemAt  
👉 UICollectionViewFlowLayout  
　　👉 각 섹션의 item, Header, Footer와 같은 것들의 크기를 결정  
　　👉 대표 관련 func : sizeForItemAt, insetForSectionAt  

<br>

## setNeedsDisplay 🆚 setNeedsLayout 🆚 displayIfNeeded 🆚 layoutIfNeeded
👉 setNeedsDisplay()  
　　👉 뷰의 컨텐츠를 다시 그리고 싶을 때 호출하는 메소드  
　　👉 View가 업데이트되어야 함을 명시적으로 시스템에 알리는 메소드  
　　👉 바로 다시 그려지지 않고 다음 업데이트 주기가 되고 draw() 메소드가 자동으로 호출될 때 업데이트됨  
👉 setNeedsLayout()  
　　👉 뷰의 하위 뷰들의 레이아웃을 조정하고 싶을 때 호출하는 메소드  
　　👉 레이아웃이 업데이트되어야 함을 명시적으로 시스템에 알리는 메소드  
　　👉 이 메소드를 호출한 뷰는 재계산이 필요한 뷰라고 시스템에게 알려, 이후 update cycle에서 layoutSubviews() 메소드가 호출됨  
　　　　👉 layoutSubview()  
　　　　　　👉 UIView의 인스턴스 메소드  
　　　　　　👉 이 메소드가 호출되면 해당 뷰와 하위 뷰들이 모두 연달아 호출됨  
　　　　　　👉 이 메소드는 View의 값이 재계산되어야 하는 적절한 시점에 시스템에 의해 자동으로 호출됨  
👉 displayIfNeeded()  
　　👉 현재 업데이트가 필요한 것으로 표시된 경우, layer의 업데이트 프로세스를 시작하는 메소드  
👉 layoutIfNeeded()  
　　👉 즉시 레이아웃의 업데이트를 진행하는 메소드  

<br>

## view(UIView) vs layer(CALayer)
👉 view는 UIKit의 한 요소이고, layer는 Core Animation의 한 요소  
👉 그래픽을 그리기 위해서는 그래픽 하드웨어(GPU)에 접근하여 직접 그리는 것(OpenGL)이 렌더링가 가장 속도가 빠르지만 코드의 양이 많아지는 단점이 존재  
👉 따라서, 이를 보완하기 위해 애플은 Core Graphics < Core Animation < UIKit & AppKit 프레임워크를 만듦  
　　👉 프레임워크가 저수준일수록 고수준에 비해 많은 기능을 제공하지만 전체적인 코드량이 많음  
　　👉 프레임워크가 고수준일수록 저수준에 비해 유연성은 떨어지지만 사용이 간편하고 코드량이 적음  
👉 즉, layer는 UIkit보다 많은 기능을 제공하지만, 몇 가지 기능에 대해서는 직접 구현하여 사용하여야 한다는 단점이 있음  

<br>

# reloadData()
👉 CollectionView 혹은 TableView의 모든 data를 reload 하는 메소드  
👉 CollectionView 혹은 TableView를 한 번에 처음부터 다시 그리므로, 간단하게 코드 작성이 가능하다는 장점이 있지만, 그만큼 비용이 크다는 단점이 있음  

<br>

# removeFromSuperview()
👉 해당 뷰와 상위 뷰의 연결을 해제하는 메소드  

<br>

## UI- 관련
👉 UILabel  
　　👉 단순히 텍스트를 표시해주는 UI  
👉 UISlider  
　　👉 드래그(슬라이드)를 지원하는 UI  
👉 UIActivityIndicatorView  
　　👉 원의 형태로 빙글빙글 돌아가는 UI (로딩)  
👉 UITextField  
　　👉 텍스트를 편집하기 위한 객체  
　　👉 사용자가 클릭하면 키보드가 등장하며 텍스트를 입력 및 수정할 수 있음  
　　👉 여러 줄을 사용할 수 없고 한 줄로만 작성이 가능  
👉 UITextView  
　　👉 텍스트를 여러 줄로 사용하고, 편집하기 위한 객체  
　　👉 사용자가 클릭하면 키보드가 등장하며 텍스트를 입력 및 수정할 수 있음  
　　👉 Editable 속성을 false로 설정할 경우 편집이 불가능  
　　👉 텍스트가 길어지면 자동으로 스크롤 기능을 제공  
👉 UIBarButtonItem  
　　👉 네비게이션 바 버튼 아이템  
👉 UIPageViewController  
　　👉 여러 개의 뷰를 옆으로 넘기며 화면 상에 출력할 때 사용하는 View Controller  
👉 UIPageControl  
　　👉 현재 페이지 위치를 표시해주는 UI (Ooooo / oOooo 같은 UI)  
👉 UIActivityViewController  
　　👉 내 앱에서 사용하고 있는 표준 서비스들을 다른 앱들에게 제공할 수 있게 해주는 View Controller  
　　👉 ex) 공유하기 버튼을 클릭했을 때 출력되는 UI  
👉 UIScrollView  
　　👉 손가락에 움직임에 따라 화면의 위치가 변하는 View, 확대 및 축소도 가능함  
👉 UISearchController  
　　👉 SearchBar와의 상호 작용을 기반으로 검색 결과 표시를 관리하는 View Controller  
👉 UIRefreshControl  
　　👉 TableView 혹은 CollectionView를 포함한 모든 UIScrollView에 붙일 수 있는 표준 컨트롤  
　　👉 스크롤이 가능한 뷰에 추가하여 컨텐츠를 새로고침할 수 있도록 함 (아래로 잡아 당기는 방식으로 작동)  
👉 UITableViewHeaderFooterView  
　　👉 커스텀 헤더 또는 푸터를 구현하기 위해 사용  

<br>

## textView.returnKeyType
👉 키보드의 파란 enter 키 버튼의 동작을 적용하는 속성  
　　👉 ex) textView.returnKeyType = .done  

<br>

## view.endEditing(true)
👉 파라미터로 true를 전달할 경우 뷰의 First responder의 상태를 강제로 해제한다는 의미  

<br>

## override func touchesBegan(~)
👉 뷰나 화면에 터치가 일어났을 때 호출되는 메서드  

<br>

## UIImagePickerController  
👉 갤러리에 접근하기 위해 사용하는 View Controller  
　　👉 반드시 권한을 설정해야 함 // Info.plist; Privacy - Photo Library Usage Description  
👉 code)  
```swift
extension FeedViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {
    // UINavigationControllerDelegate : 화면이 전환될 때의 동작을 지원하며, Image Picker에서 사진을 선택하거나, 취소했을 때 다시 원래 사용중이던 뷰로 돌아오는 작업을 처리함
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        // UIImagePickerControllerDelegate(:didFinishPickingMediaWithInfo) : 사용자가 선택한 사진을 처리하는 메소드
        var selectImage: UIImage?
        
        if let editedImage = info[UIImagePickerController.InfoKey.editedImage] as? UIImage {
            selectImage = editedImage
        } else if let originalImage = info[UIImagePickerController.InfoKey.originalImage] as? UIImage {
            selectImage = originalImage
        }
        
        picker.dismiss(animated: true) { [weak self] in
            let uploadViewController = UploadViewController(uploadImage: selectImage ?? UIImage())
            let navigationController = UINavigationController(rootViewController: uploadViewController)
            navigationController.modalPresentationStyle = .fullScreen
            // modalPresentationStyle: 나타나는 형태 (사이즈st)
            // + modalTransitionStyle: 나타나는 효과 (애니메이션st)
            
            self?.present(navigationController, animated: true)
        }
    }
}
```  

<br>

## imageView contentMode
👉 UIImageView에 Image를 넣을 때 어떤 비율로 넣을지 정하는 속성  
👉 대표 3가지 속성  
　　👉 scaleAspectFit  
　　　　👉 콘텐츠의 비율을 유지면서 뷰의 사이즈에 맞게 이미지를 늘리는 옵션으로, 남는 영역은 투명처리  
　　👉 scaleAspectFill  
　　　　👉 콘텐츠의 비율을 유지하면서 뷰의 사이즈에 맞게 이미지를 꽉 채우는 옵션으로, 이미지의 일부 부분이 잘릴 수 있음  
　　👉 scaleToFill  
　　　　👉 전체 이미지가 다 나올 수 있도록, 필요 시 비율을 깨트리면서 뷰의 사이즈에 맞게 이미지를 꽉 채우는 옵션  

<br>

## 이미지 리터럴(#imageLiteral)
👉 코드 상에서 이미지를 미리 확인할 수 있게 하는 기능  

<br>

## UserNotifications
👉 앱의 푸쉬 알림 기능을 구현하기 위해 사용하는 개념  

<br>

## iOS 저장 기능
👉 대표적으로, UserDefaults와 CoreData가 있음  
👉 UserDefaults  
　　👉 기본적으로, 간단하게 많이 사용하는 기능  
　　👉 앱의 기본 데이터베이스에 영구적으로 데이터를 저장할 수 있는 기능  
　　👉 key와 value 쌍으로 저장  
　　👉 Singleton 패턴으로 설계되어 앱 전체에서 단 하나의 인스턴스만 존재함  
👉 CoreData  
　　👉 좀 더 복잡한 데이터를 저장할 때 적합한 기능  
　　👉 CoreData는 Database가 아닌, 객체 그래프를 관리하는 프레임워크  
　　👉 그 중 대표적인 기능이 Persistence이며, SQLite에 의해 지원됨  

<br>

## PropertyListEncoder().encode & PropertyListDecoder().decode
👉 UserDefaults 관련하여 많이 볼 수 있는 코드  
👉 UserDefaults에는 PropertyList만 저장되어야 하며, 그렇지 않으면 에러가 발생  
👉 따라서, PropertyListEncoder, PropertyListDecoder 객체를 사용하여 인코딩 및 디코딩을 진행  
　　👉 여기서, PropertyList는 plist를 의미  

<br>

## URLSession
👉 URLSession은 네트워크 통신을 제공하는 기본 프레임워크의 클래스  
👉 URLSession에는 싱글톤 세션이 있는데 이는 기본적인 데이터 전송만을 지원하는 세션  
👉 커스터마이징을 할 수 없지만 제한된 기능만을 사용할 경우 유용하게 사용할 수 있음  
👉 URLSession은 URLSessionConfiguration으로 생성되며, 3가지 유형으로 만들 수 있음  
　　👉 default  
　　　　👉 쿠키와 같은 저장 객체를 사용하는 기본 통신을 할 때 사용  
　　👉 emphemral  
　　　　👉 쿠키나 캐시를 저장하지 않는 정책을 사용할 때 이용  
　　👉 background  
　　　　👉 앱의 백그라운드에서 컨텐츠를 다운로드/업로드 할 때 사용  
👉 URLSession은 작업에 따라 URLSessionTask를 여러 개 만들어 실제 서버와 통신  
　　👉 URLSessionDataTask  
　　　　👉 기본적인 데이터를 받는 경우 사용  
　　　　👉 NSData 타입으로 데이터를 내려받기 때문에 로컬 저장소에는 저장하지 않음  
　　👉 URLSessionUploadTask  
　　　　👉 파일을 업로드할 때 사용  
　　👉 URLSessionDownloadTask  
　　　　👉 실제 파일을 다운받을 시 사용  
　　　　👉 내려받은 파일은 temp 디렉토리에 저장되며, 따라서 백그라운드 세션을 지원함  

<br>

## DateFormatter
👉 날짜 혹은 문자열을 변환해주는 역할  
👉 문자열을 Date 타입으로 혹은 Date 타입을 사람이 이해하는 날짜 형식으로 변환할 때 사용하는 클래스  

<br>

## CoreLocation
👉 기기의 위치, 고도, 방향 등을 알려주는 기능을 가진 프레임워크  
v CLLocationManager : CLLocationManager 클래스 객체를 활용하여 CoreLocation 서비스를 구성하고, 시작하고 중지할 수 있으며, 권한을 반드시 받아야 함

<br>

## MapKit
👉 애플 맵의 확대, 축소 및 이동하는 등 지도에 관한 여러 기능을 제공하는 프레임워크  

<br>

## Test 개념(in Apple)
👉 XCTest  
　　👉 애플에서 제공하는 Test 프레임워크  
　　👉 애플에서 제공하는 Test 프레임워크  
👉 관련 라이브러리 : Nimble(lib), Stubber(lib)  
👉 Test Coverage(Code Coverage)  
　　👉 소프트웨어의 테스트가 얼마나 충족되었는지를 나타냄  
　　👉 이를 통해, 테스트를 진행할 때 코드의 어떠한 부분이 테스트되었고, 테스트되지 않았는지를 알 수 있음  

<br>

## 의존성 주입  
👉 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 주입 받아 사용하는 것  
　　👉 객체 간 의존성을 줄일 수 있으며, 유닛 테스트 및 유지 보수가 용이하다는 장점이 있음  
　　　　👉 유지 보수가 용이하다 : (일반적으로)코드의 가독성이 높아지고, 재사용성이 높아진다는 뜻  

<br>

## Swift Singleton
👉 설명은 CS-Basic 참고  
👉 static property 혹은 private init을 사용하여 싱글톤 객체를 만들 수 있음  
👉 UserDefaults, NotificationCenter 등에서 활용  

<br>

## Nib vs Xib
👉 Nib, Xib는 기능적으로는 동일하지만, Nib는 binary 기반이며, Xib는 xml 기반  
👉 Xib는 bundle이 아닌 xml 기반의 플랫 파일이기에 소스 제어 관리 시스템에서 보다 쉽게 처리 가능  
　　👉 플랫 파일 : 아무런 구조적 상호관계가 없는 레코드들이 들어 있는 파일  
👉 추가적으로, iOS의 UI를 구성하는 대표적인 세 가지 방법으로 Storyboard & Xib(인터페이스 빌더) + Code가 있음  
👉 인터페이스 빌더로 만드는 모든 UI 구성요소는 Xib 파일 형태로 만들어지며, 컴파일 시 바이너리 형태인 Nib 파일로 바뀌게 됨  

<br>

## Info.plist
👉 실행 패키지에 관한 필수 설정 정보가 포함되어 있는 구조화된 텍스트 파일  

<br>

## App Bundle
👉 실행 가능한 코드와 리소스를 한 공간에 묶는 디렉터리 모음  
👉 애플리케이션을 실행시키기 위한 모든 것들이 저장되어 있음  
👉 실행 파일, 앱 아이콘, Info.plist, 리소스 등이 포함되어 있음  

<br>

## Localization
👉 다양한 언어를 지원하는 것  

<br>

## App thinning
👉 앱이 설치될 때 디바이스의 특성에 맞게 앱을 설치하는 최적화 기술  
👉 기술 요소 3가지  
　　👉 슬라이싱  
　　　　👉 앱이 지원하는 여러 디바이스에 대해 각각의 번들을 생성해놓고, 사용자의 디바이스에 가장 적합한 번들 조각을 전달하는 기술  
　　👉 주문형 리소스  
　　　　👉 앱을 설치할 때 당장 필요한 기능을 제외하고는 다운로드를 하지 않고, 추후 사용자가 필요로 할 경우 다운로드를 진행하는 방식  
　　👉 비트코드  
　　　　👉 앱스토어에 앱을 올릴 때 기계어로 구성된 바이너리 파일을 업로드 하는 것 아니라, 그 전 단계인 비트코드로 업로드 하는 것을 의미  
　　　　👉 비트코드를 사용해 업로드를 진행하면 Apple 측에서 이를 재컴파일하여 App binary를 생성  
　　　　👉 비트코드를 사용하지 않으면 모든 디바이스 케이스를 바이너리로 생성하여 fat binary를 업로드  
　　　　👉 비트코드를 사용하면 필요에 따라 재컴파일하게 되므로 그 때 최적화가 가능해짐  

<br>

## 실제 디바이스 🆚 시뮬레이터
👉 시뮬레이터에서는 카메라, 마이크, 전화, 센서를 사용할 수 X  
👉 Apple의 푸시 알림 받기와 보내기 기능을 지원하지 X  
👉 Mac과 iPhone의 성능 차이로 CPU, memory에서 차이가 O  
👉 앱 백그라운드 전환, 터치, 다크모드 등 기본적인 기능은 시뮬레이터에서도 가능  

<br>

## 테마 설정(일반/다크모드)
👉 Color Asset에 Any, Dark, Light을 모두 설정하면 모드에 맞게 설정한 색이 화면에 출력됨  
👉 window의 backgroundColor를 systemBackground로 설정하여 기기 테마의 설정을 따르도록 구현 가능  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>

[Link1]: https://babbab2.tistory.com/117
[Link11]: https://mrgamza.tistory.com/845
[Link12]: https://zeddios.tistory.com/243
[Link13]: https://zeddios.tistory.com/245
[Link14]: https://zeddios.tistory.com/251
[Link15]: https://babbab2.tistory.com/168
[Link16]: https://babbab2.tistory.com/169
[Link17]: https://www.zehye.kr/ios/2021/08/03/iOS_required_init_coder/
[Link18]: https://jeonyeohun.tistory.com/359
[Link2]: https://babbab2.tistory.com/68?category=831129
[Link3]: https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48
[Link31]: https://babbab2.tistory.com/27
[Link4]: https://zeddios.tistory.com/1218
[Link5]: https://zeddios.tistory.com/1220