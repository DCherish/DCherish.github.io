---
layout: page
title:  "Data Structure"
subtitle: "Computer Science of Data Structure"
date:   2021-10-17 11:11:11 +0530
categories: ["CS"]
comments: true
---
## Pointer
👉 자료형과 주소값을 저장하는 변수  
👉 int *ptr = &a; // & ; 주소 연산자 (ampersand)  
👋 포인터 변수 앞 * 붙이면 해당 주소에 저장된 값을 의미  
👋 int a = 3; (가정) // cout << *ptr << endl; // 3 출력  

<br>

## Call-by-Value 🆚 Call-by-Reference ✔️
#### - Call-by-Value
👉 함수 호출 시 인자 전달 과정에서 발생  
👉 데이터를 복사하는 과정에서 발생  
#### - Call-by-Reference
👉 전달되는 인자를 레퍼런스로 받으면 데이터의 복사 연산이 필요하지 않음 // ∴ 성능 향상  
👉 원본 데이터 변경 막을때는 const  
👋 1. 포인터를 넘겨주는 방식 // add(&a, &b), void add(int *a, int *b)  
👋 2. 레퍼런스를 이용하는 방식 // add(a, b), void add(int &a, int &b)  

<br>

## 함수 오버로딩(Overloading) ✔️
👉 동일한 이름을 가진 함수를 중복해서 정의하는 것  
👉 단, 반드시 인자 개수 혹은 타입이 달라야 함  
👉 가능한 이유 : 호출할 함수를 매개변수의 정보까지 참조해서 호출하기 때문  
👉 return 타입만 다를 경우는 error  

<br>

## 오버라이딩(Overriding) ✔️
👉 상속 받았을 때 부모 클래스의 함수를 사용하지 않고 다른 기능을 실행할 때 함수를 자식클래스에서 같은 이름으로 재정의해서 사용하는 것  

<br>

## 프로그래밍 패러다임
👉 프로그래머에게 프로그래밍의 관점을 갖게하고 코드를 어떻게 작성할 지 결정하는 역할  
### - 명령형 프로그래밍
👉 무엇(What)을 할 것인지를 나타내기보다 어떻게(How) 할 것인지를 설명하는 방식  
#### -> 객체 지향 프로그래밍 ✔️
👉 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 패러다임  
👋 코드 재사용이 용이하며, 유지 보수가 쉬우므로 대형 프로젝트에 적합  
👋 But, 처리속도가 상대적으로 느리므로, 객체가 많으면 용량이 커질 수 있음  
#### -> 절차 지향 프로그래밍(절차적 프로그래밍)
👉 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결이 되도록 만드는 프로그래밍 패러다임  
### - 선언형 프로그래밍
👉 어떻게(How) 할 것인지를 나타내기보다 무엇(What)을 할 것인지를 설명하는 방식  
#### -> 함수형 프로그래밍
👉 부수 효과를 없애고 순수 함수를 만들어 모듈화 수준을 높이는 프로그래밍 패러다임  
👉 객체 지향 프로그래밍에서 멤버 변수를 다룸에 있어 예상치 못한 버그가 일어날 수 있기에 이를 보완하기 위해 쓰임  

<br>

## 제네릭 프로그래밍(Generic Programming)
👉 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두고 재사용성을 높일 수 있는 프로그래밍 방식  
👋 Generic Programming is a style of computer programming in which algorithms are written in terms of types to be specified-later that are then instantiated when needed for specific types provided as parameters  

<br>

## 객체 지향 프로그래밍의 5가지 키워드
👉 클래스/객체, 추상화, 캡슐화, 상속, 다형성  

<br>

## Class
👉 어떠한 객체를 만들기 위해 변수와 메서드를 정의하는 틀  

<br>

## Object 🆚 Instance
#### - Object
👉 소프트웨어 세계에 구현할 대상  
#### - Instance
👉 소프트웨어 세계에 구현된 실체  
👋 An Object is an Instance of a Class  
👋 a = Cookie() // a 객체는 Cookie 클래스의 인스턴스  

<br>

## 데이터 추상화(Data Abstraction)
👉 현실 세계의 사물을 데이터적인 측면과 기능적인 측면으로 모델링하여 시스템 내의 사물로 정의  

<br>

## 다형성(Polymorphism)
👉 보이는 모습은 하나이지만 실질적으로 쓰이는 기능은 여러 가지를 수행 가능하다는 것  
👋 Polymorphism is the provision of a single interface to entities of different types or the use of a single symbol to represent multiple different types  
👋 Overloading, Overriding  

<br>

## 상속(Inheritance)
👉 이미 존재하는 클래스(or 객체)로 부터 기본적인 특성(멤버 함수 및 변수)을 물려받아 새로운 클래스를 작성하는 것  
👋 Inheritance is when an object or class is based on another object or class, using the same implementation  
👋 Inheritance in most class-based object oriented languages is a mechanism in which one object acquires all the properties and behaviors of parent object  

<br>

## 캡슐화(Encapsulation)
👉 관련있는 데이터와 함수를 하나의 단위로 묶는 것  
👋 코드를 재수정없이 재활용할 수 있음  
👉 또한, 객체가 기능을 어떻게 구현했는지 외부에 감추는 것  
👉 즉, 정보 은닉의 의미를 포함하고 있음  

<br>

## 정보 은닉(Information hiding)
👉 객체 내의 데이터 및 함수에 대한 접근 권한을 제어  
👋 객체 안의 데이터가 다른 객체에게 잘못 조작되는 것을 막아줌으로 에러를 방지  
👋 public, private, protected  

<br>

## 접근 제한자 getter, setter 쓰는 이유
👋 getter, setter는 정보 은닉이라는 특성을 잘 보여주고 있음  
👉 사용하는 결정적인 이유는 객체의 무결성을 보장하기 위함  
👉 메서드를 통해서만 접근할 수 있기 때문에, 객체 안의 데이터가 다른 객체에게 잘못 조작되는 것을 막아줌  
👉 또한, 메서드 안에서 매개변수같이 어떤 올바르지 않은 입력에 대해 사전에 처리할 수 있게 제한하거나 조절할 수 있음  

<br>

## Preprocessor
👉 전처리기 구문(#으로 시작하는 구문)을 처리하는 역할 // .cpp -> .i  
👋 A **Preprocessor** is a program that processes its input data to produce output that is used as input to another program  

<br>

## Compiler
👉 고수준의 언어를 기계어와 가장 유사한 상태인 어셈블리어로 변환하는 역할 // .i -> .s  
👋 A **Compiler** is a computer program that translates computer code written in one programming language into another language  

<br>

## Assembler
👉 완전히 기계어로 변환하는 역할 // .s -> .o  
👋 An **Assembler** program creates object code by translating combinations of mnemonics and syntax for operations and addressing modes into their numerical equivalents  

<br>

## Linker
👉 여러 개의 오브젝트 파일들을 합치거나 라이브러리를 합쳐주는 역할 // .o -> .exe  
👋 **Linker** is a computer program that takes one or more object files generated by a compiler and combines them into a single executable file, etc  

<br>

## Compile
👉 사람이 이해하는 언어를 컴퓨터가 이해할 수 있는 언어로 바꾸어주는 과정  
👋 컴파일 과정은 위의 4가지 과정(P -> C -> A -> L)을 거침  

<br>

## Build
👉 소스코드 파일을 실행 가능한 소프트웨어 산출로 만드는 과정  

<br>

## Compile Error
👉 컴파일시 발생하는 에러, 주로 syntax 오류로 인해 발생하는 에러  

<br>

## Runtime Error
👉 프로그램 실행시 발생하는 에러, 주로 논리적 오류로 인해 발생하는 에러  
👋 논리적 오류 ; Divide by Zero, Infinite Loop, Out of Bounds 등  

<br>

## Struct(C++)
👉 사용자가 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 타입  

<br>

## Template(C++)
👉 C++ 프로그래밍 언어의 한 기능으로, 함수와 클래스가 제네릭 형과 동작할 수 있게 도와줌  
👋 Templates are a feature of the C++ Programming language that allows functions and classes to operate with generic types  

<br>

## 프로그램 실행 순서
👉 1. 사용자가 OS에게 프로그램 실행요청함  
👉 2. OS는 프로그램의 정보를 읽어 메모리에 로드함  
👉 3. CPU는 프로그램 코드를 가져다 메모리를 관리하고 명령문을 실행  
👉 4. 동적메모리가 할당되면 FreeStore 영역을 사용 (아래쪽으로 이동)  
👉 5. 스택메모리가 할당되면 FreeStore 영역을 사용 (위쪽으로 이동)  

<br>

## 메모리 구조 ✔️
### - Code
👉 작성한 소스코드가 들어가는 부분, 텍스트 영역  
👉 실행 파일을 구성하는 구성하는 명령어들이 올라가는 메모리 영역  
👋 함수, 제어문, 상수 등이 이곳에 지정됨  
### - Data
👉 프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 소멸되는 영역  
👋 전역변수와 static 변수가 이곳에 할당  
### - Heap
👉 프로그래머가 할당/해제하는 메모리 공간, 이 공간에 메모리 할당하는 것을 동적 할당이라고 함  
👉 런 타임에 크기가 결정됨  
### - Stack
👉 프로그램이 자동으로 사용하는 임시 메모리 영역  
👉 컴파일 타임에 크기가 결정됨  
👋 함수 호출시 생성되는 지역 변수와 매개변수가 이곳에 저장됨  
👋 함수 호출이 완료되면 사라짐  

⚠️ Heap과 Stack은 같은 공간을 공유  
⚠️ Heap은 위쪽 주소부터 할당되며, Stack은 아래쪽부터 할당되는 방식  
⚠️ 각 영역이 상대 공간을 침범하는 일이 발생할 수 있음  
⚠️ 이를, Heap Overflow, Stack Overflow  
⚠️ Stack 영역이 크면 클수록 Heap 영역이 작아지고, 반대도 동일함  

<br>

## static 변수
👉 여러 객체가 하나의 변수를 공유하고자 할 때 쓰이는 변수  
👉 compile 타임에 주소 및 크기가 결정, main 함수 실행되기 전 static area에 자리함  
👉 이 변수는 각각의 객체의 멤버로 존재하는 것이 X
👉 접근할 수 있는 권한이 부여되는 개념

<br>

## using namespace std
👉 std ; C++ 표준라이브러리의 모든 것은 std라는 namespace에 존재  
👉 namespace ; 모든 식별자(변수, 함수)가 고유하도록 보장하는 코드 영역  
👉 using ; 사용하겠다  

<br>

## Bubble Sort
👉 O(n^2)  
👉 stable sort  
👉 in-place sort  
👋 13 7 9 3 ➡️ 7 13 9 3 ➡️ 7 9 13 3 ➡️ 7 9 3 **13**  
👋 7 9 3 **13** ➡️ 7 3 **9 13** ➡️ 3 **7 9 13** ➡️ **3 7 9 13**  
👋 2개씩 지정, swap  

<br>

## Insertion Sort
👉 O(n^2) // Best일 경우 O(n)  
👉 stable sort  
👉 in-place sort  
👉 거의 정렬이 되어 있을 경우 빠름  
👋 **13** 7 9 3 ➡️ 13 **7** 9 3 ➡️ **7 13** 9 3  
👋 7 13 **9** 3 ➡️ **7 9 13** 3 ➡️ 7 9 13 **3** ➡️ **3 7 9 13**  
👋 한 곳 기준 정렬, 자신에게 맞는 위치에 insert  

<br>

## Selection Sort
👉 O(n^2)  
👉 unstable sort  
👉 in-place sort  
👋 **13 9** 7 3 ➡️ **13** 9 **7** 3 ➡️ **13** 9 7 **3**  
👋 **3** 9 7 **13** ➡️ 3 **9** **7** 13 ➡️ 3 **7 9** 13  
👋 하나 기준, 제외 min/max 찾은 후 swap  

<br>

## Merge Sort
👉 O(nlogn)  
👉 stable sort  
👉 not in-place sort  
👋 **7 2 9 4** ➡️ **7 2** | 9 4 ➡️ **7** | **2** | 9 4  
👋 **2 7** | 9 4 ➡️ 2 7 | **9 4** ➡️ 2 7 | **9** | **4**  
👋 2 7 | **4 9** ➡️ **2 4 7 9**  
👋 먼저 반으로 나누고, 후에 병합  
👋 병합 시 비교하며 순서에 맞게 & temp 배열이 필요(not in-place)  

<br>

## Quick Sort
👉 O(nlogn) // Worst일 경우 O(n^2)  
👉 unstable sort  
👉 in-place sort  
👋 3 7 8 1 5 9 6 10 2 4  
👋 **3** '7' 8 1 5 9 6 10 2 "4"  
👋 **3** '7' 8 1 5 9 6 10 "2" 4  
👋 **3** '2' 8 1 5 9 6 10 "7" 4  
👋 **3** 2 '8' 1 5 9 6 10 "7" 4  
👋 **3** 2 '8' "1" 5 9 6 10 7 4  
👋 **3** 2 '1' "8" 5 9 6 10 7 4  
👋 **3** 2 "1" '8' 5 9 6 10 7 4  
👋 **1** 2 "**3**" '8' 5 9 6 10 7 4  
👋 **1** "'2'" | 3 | **8** '5' 9 6 10 7 "4"  
👋 ...  
👋 3개의 포인터(p, l, r), l > r 되는 순간 swap(p, r) 

<br>

## Heap Sort
👉 O(nlogn)  
👉 unstable sort  
👉 in-place sort  
👋 3 7 8 1 5 9 6 10 2 4 ➡️ **1 2 6 3 4 9 8 10 7 5**  
👋 **1** 2 6 3 4 9 8 10 7 **5** ➡️ **5** 2 6 3 4 9 8 10 7 **1**  
👋 5 2 6 3 4 9 8 10 7 | 1 ➡️ **2 3 6 5 4 9 8 10 7** | 1  
👋 **2** 3 6 5 4 9 8 10 **7** | 1 ➡️ **7** 3 6 5 4 9 8 10 **2** | 1  
👋 7 3 6 5 4 9 8 10 | 2 1 ➡️ ...  
👋 index 순으로 parent와 비교 후 swap -> heapify  
👋 heapify 후 root와 end_index swap, end_index - 1까지 다시 heapify  
👋 priority_queue의 원리  

<br>

### Shell Sort
👉 O(n) ~ O(n^2) // Avg O(n^1.5)  
👉 stable sort  
👉 in-place sort  
👋 삽입 정렬을 보완한 알고리즘  
👋 따라서, 거의 정렬이 되어 있을 경우 가장 빠름  
👋 삽입 정렬은 요소들이 삽입될 때, 이웃한 위치로 이동 // 삽입 정렬의 최대 문제점  
👋 code  
```c++
void shellsort(int p[], int n)
{
	int s, j = 0;

	for (int h = 1; h < n; h = 3 * h + 1)
	{
		s = h; // find h maxsize
	}

	for (int h = s; h > 0; h = h / 3) // h decrease, h는 size 개념
	{
		for (int i = h + 1; i <= n; i++)
		{
			int v = p[i]; // 하나 기준
			j = i;

			while (j > h && p[j - h] > v) // 기준보다 큰 것이 h칸 앞에 있다면
			{
				p[j] = p[j - h]; // swap
				j = j - h; // h칸 앞으로
			}

			p[j] = v; // v go to p[j]
		}
	}
}
```  

<br>

### Counting Sort
👉 O(n+k) // k가 클 경우 비효율적  
👉 stable sort  
👉 not in-place sort  
👋 누적 합 techinc을 이용한 알고리즘  
👋 잘 활용될 경우 꽤 유용한 sort  
👋 적합하지 않을 경우 사용하면 매우 비 효율적  
👋 code  
```c++ (pseudo)
void countingsort(A, B, C, min, max)
{
        for (i = min; i <= max; i++) C[i] = 0; // 초기화

        for (i = 0; i < A.size; i++) C[A[i]]++; // ex) 해당 점수 개수 + 1

        for (i = min + 1; i <= max; i++) C[i] += C[i - 1]; // 누적합
        
        for (i = A.size - 1; i >= 0; i++) // ex) A 역순으로 맞는 자리 찾아 B에 할당 & 해당 점수 개수 - 1
        {
                 B[C[A[i]]] = A[i];
                 C[A[i]]--;
        }
}
```  

<br>

### Radix Sort
👉 O(n) // 정확하게는 O(d(n+k))  
👉 must be stable  
👉 not in-place sort  
👋 countingsort 이용한 알고리즘 (k)  
👋 k는 0-9 or a-z ...  
👋 각 기수 정렬 시 ㅇㅇ  
👋 code  
```c++
void Radix_Sort()
{
        int Radix = 1;
    
        while (true) // d 계산 (최대 자리수)
        {
                if (Radix >= Max_Value) break; // Max_Value는 배열 중 최대값
                Radix = Radix * 10;        
        }

        for (int i = 1; i < Radix; i = i * 10) // 1의 자리부터 10씩 곱하면서 최대자릿수 까지 반복
        {
                for (int j = 0; j < MAX; j++) // 모든 배열 탐색
                {
                        int K;
                        if (Arr[j] < i) K = 0; // 만약 현재 배열 값 해당 자릿수보다 작으면 0
                        else K = (Arr[j] / i) % 10; // 그게 아니라면 배열 기수 삽입
                        Q[K].push(Arr[j]); // Queue에 순차 저장
                }

                int Idx = 0;
                
                for (int j = 0; j < 10; j++) // Queue에 저장된 값들 순차적으로 빼내기
                {
                        while (Q[j].empty() == 0) // 해당 Index번호의 Queue가 빌 때 까지 반복
                        {
                                Arr[Idx] = Q[j].front(); // 하나씩 빼며 배열에 다시 저장
                                Q[j].pop();
                                Idx++;
                        }
                }
        }
}
```  

<br>







<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>