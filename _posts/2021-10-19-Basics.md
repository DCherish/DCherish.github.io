---
layout: page
title:  "Basics"
subtitle: "Computer Science of Basics"
date:   2021-10-19 11:11:11 +0530
categories: ["CS"]
comments: true
---
## 동기 🆚 비동기 ✔️
👉 동기 방식  
　　👉 요청을 보낸 후 응답을 받아야지만 다음 동작이 이루어지는 방식  
　　👋 호출한 함수가 호출되는 함수의 작업의 완료 후의 return을 기다리거나 return을 받더라도 작업 완료 여부를 호출한 함수 스스로 확인하며 신경씀  
　　👋 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어짐  
　　👋 설계가 매우 간단하고 직관적  
👉 비동기 방식  
　　👉 요청을 보낸 후 응답과 상관없이 다음 동작이 이루어지는 방식  
　　👋 여러가지 요청을 동시에 처리할 수 있어 자원을 효율적으로 사용할 수 있음  
　　👋 동기 방식에 비해 설계가 복잡함  
　　👋 호출되는 함수에게 callBack을 전달해서 작업이 완료되면 전달받은 callBack을 실행하고, 호출한 함수는 작업 완료 여부를 신경쓰지 X  

<br>

## Blocking 🆚 Non-Blocking ✔️
👉 Blocking  
　　👉 자신의 작업을 모두 마칠 때까지 제어권을 넘겨주지 않고 대기하게 만드는 방식  
👉 Non-Blocking  
　　👉 호출된 즉시 바로 return하여 호출한 함수에게 제어권을 넘겨주고 호출한 함수가 다른 일을 할 수 있는 기회를 주는 방식  

<br>

## 동기 & 비동기 🆚 Blocking & Non-Blocking
👉 관심사에 차이가 있음  
　　👉 동기 & 비동기  
　　　　👉 호출되는 함수의 작업 완료 여부를 누가 신경쓰는지  
　　👉 Blocking & Non-Blocking  
　　　　👉 호출되는 함수가 즉시 return을 하는지  

<br>

## 병렬성은 아니지만 동시 수행성을 가지는 것이 가능한가?
👉 사용자가 인식하지 못할 정도로 빠르게 문맥 교환(context switching)을 수행하면 사용자는 프로그램이나 기능이 동시에 수행되는 것처럼 느끼기 때문에 병렬성은 아니지만 동시 수행성을 가지는 것이 가능  

<br>

## 아키텍처 패턴 🆚 디자인 패턴 ✔️
👉 아키텍처 패턴  
　　👉 주어진 문맥 안에서 소프트웨어 아키텍처의 공통적인 발생 문제에 대해 재사용 가능한 해결책  
👉 디자인 패턴  
　　👉 특정 문맥에서 소프트웨어 디자인의 공통적인 발생 문제에 대해 재사용 가능한 해결책  
👋 아키텍처 패턴이 조금 더 넓은 범위에 속함   

<br>

## MVC 패턴 ✔️
👉 프로그램을 각각의 역할에 따라 Model, View, Controller로 나누어 설계한 디자인 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 Controller  
　　👉 데이터와 UI 요소를 잇는 역할, event 처리 역할  
👉 모든 입력은 Controller로 전달  
👉 Controller는 입력에 해당하는 Model 업데이트  
👉 Controller는 View를 선택만 할 뿐, 직접 업데이트하지 X  
👉 View를 업데이트  
　　👉 1. View가 Model을 직접 이용하여  
　　👉 2. Model에서 View에게 Notify  
　　👉 3. View가 Polling하여 Model 변화를 감지하여  
👉 View를 업데이트하기 위해 M-V 사이의 의존성이 존재  
👉 안드로이드는 Activity(or Fragment)가 Controller와 View 모두 처리하기 때문에, 한 클래스에서 M-V-C 모두 처리하는 문제점 발생  
👋 Controller : View = 1 : N, 하나의 C 여러 개의 V 관리 가능  
👋 View는 Controller를 알 수 X  
👉 가장 단순한 패턴  
👉 But, M-V 사이 의존성 // 앱이 커지고 복잡해질수록 유지보수가 어려움  

<br>

## MVP 패턴 🔥
👉 MVC에서 파생된, M과 V 간 의존성이 없는 디자인 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 Presenter  
　　👉 View에서 요청한 정보로 Model을 가공하여 View에 전달  
　　👉 View와 Model의 다리 역할  
👉 모든 입력은 View로 전달  
👉 Presenter는 입력에 해당하는 Model 업데이트  
👉 Model 업데이트 결과 기반으로 View 업데이트  
👉 Presenter는 해당 View를 참조  
👉 Presenter는 View와 Model 인스턴스를 가지고, Model과 View 사이의 다리 역할  
👉 Presenter가 M-V 사이 관리, MVC와는 다르게 M-V 사이 의존성이 X  
👋 Presenter : View = 1 : 1  
👉 But, 앱이 커지고 복잡해질수록 V-P 간 의존성이 강해지는 문제점이 발생  

<br>

## MVVM 패턴 🔥
👉 MVC에서 파생된, M과 V 간 의존성뿐만 아니라 C와 V 간 의존성도 고려하여 각 구성 요소가 독립적으로 작성되고 테스트될 수 있도록 설계한 디자인 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 ViewModel  
　　👉 View를 표현하기 위해 만든 View를 위한 Model  
　　👉 View를 나타내주기 위한 Model이자 View를 나타내기 위한 데이터  
👉 모든 입력은 View로 전달  
👉 ViewModel은 입력에 해당하는 Presentation Logic을 처리하여 View에 데이터 전달  
👉 ViewModel은 View를 참조하지 않기 때문에 독립적  
👉 따라서 View는 자신이 이용할 ViewModel을 선택해 바인딩하여 업데이트 받음  
👉 Model이 변경되면 해당하는 ViewModel을 이용하는 View가 자동으로 업데이트  
👉 ViewModel은 View를 나타내 주기 위한 Model이자, View의 Presentation Logic을 처리  
👋 ViewModel : View = 1 : N  
👉 MVP와 마찬가지로 M-V 사이 의존성 X, MVP처럼 V-VM이 1:1 관계가 아닌 독립적이기 때문에 의존성 X  

<br>

## MVI 패턴 🔥
👉 JS 생태계에서 탄생했으며 MVC에서 파생된, 능동적인 Controller 대신 Intent라고 불리는 Reactive 요소를 이용한 디자인 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
　　👉 App의 상태와 Business Logic 관리  
👉 View  
　　👉 UI 요소  
👉 Intent  
　　👉 상태를 변화시키려는 Action  
👉 Intent로 User로 부터 입력을 가져옴  
👉 Intent는 Model에서 처리해야 하는 동작을 제공  
👉 Model은 Intent로부터 동작을 가져옴  
👉 Model은 View에 표시할 새로운 모델을 생성  
👉 View는 Model로부터 새로운 모델을 가져와 표시  
👋 Android의 Intent와 다른 개념  
👉 Android에서 발생할 수 있는 여러 이슈들(화면 회전, Process death 등)로 인해 코드들이 복잡해지기 쉬운데, MVI는 단방향 데이터 흐름과 불변성으로 인해 예측 가능한 상태가 만들어지기 때문에 유지보수가 좀 더 용이함  
👉 RxJava와 같은 Observable 한 외부 라이브러리를 이용해야 함  

<br>

## Flux 패턴 🔥
👉 MVC 패턴의 양방향 데이터 흐름으로 인하여 버그가 꽤 많이 발생함  
👉 따라서, 단방향 데이터 흐름 Flux 도입  
👉 Action  
　　👉 type 속성과 일부 데이터가 있는 단순한 객체  
👉 Store  
　　👉 상태값을 저장하고 있는 저장소  
👉 Dispatcher  
　　👉 일종의 허브역할, Action의 type 속성을 읽어 Store에 등록된 콜백함수를 호출  
👉 View  
　　👉 Store가 변경된 상태를 알려주면 해당 부분만 리렌더링함  

<br>

## Singleton 패턴
👉 단 하나의 인스턴스를 생성하여 사용하는 디자인 패턴  
👉 객체 지향 설계 원칙에 적합하지 X  
　　👉 자기 자신 클래스 안에 응집도는 높이고 타 클래스 간 결합도는 낮추는 원칙  
👉 Lifecycle 제어가 힘들고, 멀티 스레드 환경에서 여러 개의 객체가 생성되는 문제가 발생할 수 있음  

<br>

## Git 🆚 Github ✔️
👉 Git  
　　👉 분산 버전 관리 시스템  
　　👉 프로젝트 파일의 변경 사항을 추적하는 시스템  
　　👉 개발자들은 이를 통해, 프로젝트 변경사항을 기록하고 특정 시점의 버전으로 언제든 돌아갈 수 있음  
👉 Github  
　　👉 Git을 사용하는 프로젝트를 위한 호스팅 플랫폼 or 서비스  
👋 repository : 프로젝트 저장소  
👋 commit : 프로젝트의 현재 상태를 나타내는 체크포인트, 즉, 현재상태를 커밋에 저장  

<br>

## daemon 🔥
👉 백그라운드에서 실행하면서 종료되지 않고 지속적으로 무엇인가 처리하는 프로그램  
✋ a daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user  
✋ the process names of a daemon end with the letter d (ex. syslogd)  

<br>

## AJAX(Asynchronous Javascript And Xml) 🔥
👉 클라이언트와 서버간에 정보를 비동기적으로 전달하기 위해 JavaScript에서 사용하는 하나의 라이브러리  

<br>

## jQuery 🔥
👉 웹 사이트에서 JavaScript를 쉽게 활용할 수 있도록 도와주는 오픈소스 기반의 JavaScript 라이브러리  

<br>

## React 🔥
👉 UI를 만드는데 사용되는 오픈소스 기반의 JavaScript 라이브러리  

<br>

## Vue.js 🔥
👉 웹 앱의 UI를 만들기 위해 사용하는 오픈소스 프로그래시브(자유도가 높은) JavaScript 프레임워크  

<br>

## Java 프로그램 실행 과정 🔥
👉 프로그램이 실행되면 JVM은 OS로부터 프로그램이 필요로 하는 메모리를 할당받음  
👉 컴파일러가 소스코드(.java)를 자바 바이트 코드(.class)로 변환  
👉 JVM이 바이트 코드를 기계어로 변환하고 인터프리터 방식으로 애플리케이션 실행  
　　👋 Class Loader를 통해 class 파일들을 JVM으로 로딩  
　　👋 Execution Engine을 통해 로딩된 class 파일들, 즉, 바이트 코드를 바이너리 코드로 변환  
　　👋 해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이뤄짐  
　　　　👋 Method Area : 모든 Thread에 공유, 클래스/변수/static/상수 정보 등이 저장되는 영역  
　　　　👋 Heap Area : 모든 Thread에 공유, new 명령어로 생성된 인스턴스/객체가 저장되는 영역  
　　　　👋 Stack Area : 각 Thread마다 하나씩 저장, 매개변수/지역변수 등이 저장되는 영역  
　　　　👋 PC Register : 각 Thread마다 하나씩 저장, CPU Register와 역할 비슷  
　　　　👋 Native Method Stack : 각 Thread마다 하나씩 저장, 다른 언어의 메서드 호출을 위해 할당되는 영역  
👉 실행과정 속에서 JVM의 필요에 따라 Thread Synchronization & GC 와 같은 관리 작업을 수행  

<br>

## Garbage Collector(Java)
👉 Garbage를 청소해주는 JVM의 실행 엔진의 한 요소  
👉 Garbage Collector가 메모리를 정리하는 과정을 Garbage Collection  
👋 Garbage : 더 이상 참조되지 않는 메모리  

<br>

## Java Thread
👉 자바에는 프로세스가 없으며 스레드만 존재, JVM이 OS 역할  

<br>

## JDK 🆚 SDK
👉 JDK  
　　👉 Java로 소프트웨어를 개발할 수 있도록 여러 가지 기능들을 제공하는 패키지, 개발 도구 모음  
👉 SDK  
　　👉 특정 플랫폼을 대상으로 소프트웨어를 개발할 수 있도록 여러 가지 기능들을 제공하는 패키지, 개발 도구 모음  

<br>

## JRE 🆚 JVM
👉 JRE(J Runtime Env)  
　　👉 JVM 실행 환경을 구현한 것, 프로그램 동작에 필요한 라이브러리 파일들과 기타 파일들을 가지고 있음  
👉 JVM  
　　👉 자바 프로그램을 컴파일 해서 나온 바이트 코드(.class)를 실행시켜주는 가상 머신  
　　👉 메모리 등의 자원을 할당 및 관리하며 정보를 처리하는 작업을 함  

<br>

## GIL(Global Interpreter Lock, Python)
👉 한 번에 하나의 Thread만 수행할 수 있도록 인터프리터에 lock을 거는 기능  
👋 reference count라는 공유 자원 접근 시 race condition 문제를 겪을 수 있기 때문  

<br>

## TDD(Test Driven Development) ✔️
👉 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스  
👉 쉽게 말해, 개발함에 있어 테스트를 많이 고려하는 프로그램 개발 방법  

<br>

## CI/CD
👉 CI(Continuous Integration, 지속적 통합)  
　　👉 코드에 대한 통합을 지속적으로 진행함으로써 품질을 유지하자는 개념  
　　👉 빌드 및 테스트 자동화  
👉 CD(Continuous Deployment, 지속적 배포)  
　　👉 소프트웨어가 항상 신뢰 가능한 수준에서 배포될 수 있도록 지속적으로 관리하자는 개념  
　　👉 배포 자동화  
👋 Jenkins, Travice CI, Bamboo, etc  

<br>

## Unit Test
👉 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트  

<br>

## Refactoring
👉 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법  
👋 소프트웨어를 보다 쉽게 이해할 수 있도록 만드는 작업  

<br>

## Agile Software Development
👉 작업 계획을 짧은 단위로 세우고 시제품을 만들어 나가는 사이클을 반복함으로써 고객의 요구 변화에 유연하고도 신속하게 대응하는 개발 방법 방식  

<br>

## Endian
👉 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법  
👉 Big Endian  
　　👉 큰 단위가 앞에 나오는 방법  
　　👋 0x1234 : 12 34  
👉 Little Endian  
　　👉 작은 단위가 앞에 나오는 방법  
　　👋 0x1234 : 34 12  

<br>

## PNG 🆚 JPG 🔥
👉 이미지 파일 형식, 비트맵 방식 이용  
　　👋 아주 작은 픽셀로 분해하고, 각 화소의 색상과 위치를 기록해 저장  
👉 PNG  
　　👉 비손실 압축방식, 원본이 훼손 되지 X  
　　✋ 투명배경이 지원  
👉 JPG  
　　👉 손실 압축방식, 원본이 훼손  
　　✋ 복잡한 풍경, 인물사진 저장에 적합  
　　　　✋ 파일 크기가 매우 커질 수 있기 때문에  
　　👋 JPEG : 사람의 눈에 거슬리지 않을 정도로 원본을 훼손해 압축 효과를 극대화하는 알고리즘  
➕ GIF  
　　👉 압축률을 우선적으로 고려한 그림 파일 형식  
　　👉 손실 압축 방식, 원본이 훼손  

<br>

## URL 🆚 URI
👉 URL(Uniform Resource Locator)  
　　👉 네트워크 상에서 자원 위치를 알려주기 위한 규약  
👉 URI(Uniform Resource Identifier)  
　　👉 인터넷에 있는 자원을 나타내는 유일한 주소  
✋ URI가 URL의 상위 개념  

<br>

## 에러 🆚 예외
👉 에러  
　　👉 시스템에 미리 예측할 수 없던 비정상적인 상황이 생겼을 때 발생  
👉 예외  
　　👉 미리 예측하여 프로그램의 코드로 처리할 수 있는 예외적인 상황  

<br>

## Client 🆚 Server
👉 두 개의 컴퓨터 프로그램 사이에 이루어지는 역할 관계 나타내는 것  
👉 Client  
　　👉 다른 프로그램에게 서비스를 요청하는 프로그램  
👉 Server  
　　👉 요청되는 정보를 처리하여 응답을 해주는 프로그램   

<br>

## HDD 🆚 SSD 🔥
👉 컴퓨터의 정보와 자료 등을 저장하고 읽을 수 있는 장치  
👉 HDD(Hard Disk Drive)  
　　👉 고속으로 디스크를 회전시켜 저장하는 방식  
👉 SSD(Solid State Drive)  
　　👉 메모리 반도체를 기반하여 저장하는 방식  
　　👉 HDD에 비해 압도적으로 속도가 빠름  

<br>

## ROM 🆚 RAM 🔥
👉 ROM(Read Only Memory)  
　　👉 컴퓨터를 구동하기 위한 기본적인 정보가 담겨있음  
　　👉 비휘발성 메모리  
👉 RAM(Random Access Memory)  
　　👉 컴퓨터가 빠른 액세스를 하기 위해 데이터를 단기간 저장하는 구성 요소  
　　👉 휘발성 메모리  

<br>

## Parameter 🆚 Argument
👉 Parameter  
　　👉 함수를 정의할 때 나열되는 변수 명  
　　✋ void solution(int a, int b)  
👉 Argument  
　　👉 함수 호출 시 함수의 파라미터로 전달된 실제 값  
　　✋ solution(7, 9) // 7, 9 ; argument  

<br>

## API(Application Programming Interface)
👉 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어하며 사용할 수 있게 만드는 인터페이스  

<br>

## Load Balancing
👉 둘 이상의 CPU or 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것  
👉 클라이언트와 서버 사이에 Load Balancer를 두어 부하가 일어나지 않도록 함  
✋ Round Robin, Least Connection Method, IP Hash, etc  

<br>

## CPU 작동 원리
👉 연산장치  
　　👉 산술연산 및 논리연산 수행  
　　👉 연산에 필요한 데이터를 레지스터에서 가져오고, 결과를 다시 레지스터로 전송  
👉 제어장치  
　　👉 명령어를 순서대로 실행할 수 있도록 제어  
　　👉 메인 메모리에서 프로그램 명령어를 꺼내 해독하고, 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄  
👉 레지스터  
　　👉 고속 기억장치  
　　👉 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장  

<br>

## CPU 동작 과정
👉 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴  
👉 CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장  
👉 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄  
👉 제어장치는 1~3과정에서 명령어가 순서대로 실행되도록 각 장치를 제어  

<br>

## Problem Thread with 전역변수
✋ 서로 다른 Thread에서 동시에 같은 변수에 접근하면  
✋ 4개의 Thread, 각각 전역변수 a에 +1, 2500000번 실행  
✋ a = 4 * 2500000 = 10000000을 예상  
✋ 실제 결과, ex) a = 4827031  
✋ Why?  
👉 같은 변수를 동시에 접근했기 때문  
👉 CPU 연산 과정의 문제  
　　👉 1. a의 값을 메모리에서 레지스터로 불러옴  
　　👉 2. 레지스터에서 더함  
　　👉 3. 더한 값을 실제로 a가 있는 메모리에 저장  
👉 즉, 4개의 Thread가 거의 동시에 실행하려다 보면 3번째 과정이 끝나기 전에 다른 Thread가 a의 값을 메모리에서 레지스터로 불러올 수 있음  

<br>

## ASCII Code 🆚 UniCode 🆚 UTF-8
👉 숫자로 문자를 표현하기 위한 일종의 약속된 코드  
👉 ASCII Code  
　　👉 1byte로 표현  
　　👉 1bit, parity bit  
👉 UniCode  
　　👉 2byte로 표현  
👋 UTF-8  
　　👋 -  
👋 parity bit : 통신 에러 검출을 한 비트  

<br>

## Memory Leak
👉 컴퓨터 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상  

<br>

## Dangling Pointer
👉 여전히 해제된 메모리 영역을 가리키고 있는 포인터  

<br>

## 자료형 크기 및 범위 🔥
👉 char / 1byte / -2^7 ~ 2^7-1  
👉 short / 2byte / -2^15 ~ 2^15-1  
👉 int / 4byte / -2^31 ~ 2^31-1  
👉 long(C++) / 4byte / -2^31 ~ 2^31-1  
👉 long long(C++) / 8byte / -2^63 ~ 2^63-1  
👉 long(Kotlin) / 8byte / -2^63 ~ 2^63-1  
👋 field : 부호 + 값  
👋 Kotlin에는 long long 없음  
👉 float / 4byte / 3.4E-38 ~ 3.4E+38  
👉 double / 8byte / 1.7E-308 ~ 1.7E+308    
👋 field : 부호 + 지수 + 가수  

<br>

## int 🆚 long (C++) 🔥
👉 int  
　　👉 4byte(32bit OS, 64bit OS)  
👉 long  
　　👉 4byte(32bit OS)  
　　👉 8byte(64bit OS)  
　　👉 4byte(windows, 64bit OS)  
👋 OS bit : Register 크기  

<br>

## float 🆚 double 🔥
👉 float  
　　👉 4byte, 유효자릿수 7자리  
👉 double  
　　👉 8byte, 유효자릿수 16자리  
👉 유효자릿수 : 몇 자리까지 오차없이 표현할 수 있는지  

<br>

## 부동 소수점 개념 🔥
👉 실수의 덧셈 및 곱셈 교환법칙 성립  
　　👋 a + b = b + a  
　　👋 a * b = b * a  
👉 실수의 덧셈 및 곱셉 결합법칙 성립 X  
　　👋 (a + b) + c ≠ a + (b + c)  
　　👋 (a * b) * c ≠ a * (b * c)  

<br>

## 컴퓨터 음수의 표현 🔥
👉 컴퓨터는 음수를 표현하기 위해서 2의 보수라는 개념을 사용  
　　👋 ex) -6  
　　👋 6(2) = 0000 0110  
　　👋 0000 0110 ➡️ 1111 1001 : 전부 뒤집고  
　　👋 1111 1001 ➡️ 1111 1010 : +1  
　　👋 -6(2) = 1111 1010  
👉 컴퓨터의 연산기에는 사실 덧셈 기능의 회로만 있음  
👉 따라서, 뺄셈 기능으로 덧셈으로 구현  

<br>

## CPU 실행시간 계산 관련 🔥
👉 프로그램 CPU 실행시간  
👉 = CPU 클럭 사이클 수 / 클럭 속도  
👋 = CPI * IC / 클럭 속도  
👋 = CPU 클럭 사이클 수 * 클럭 사이클 시간  
✋ 클럭 사이클 시간 = 1 / 클럭 속도  
　　👋 ex) 2GHz 컴퓨터 A 10초 수행 프로그램 -> B 6초 수행, A보다 1.2배 많은 클럭 사이클 필요할 때, B 클럭 속도?  
　　👋 A = 10 = A 클럭 사이클 수 / 2GHz  
　　👋 20 * 10^9 = A 클럭 사이클 수  
　　👋 B 클럭 속도 = 1.2 * 20 * 10^9 / 6 = 4 * 10^9 = 4GHz  
👋 Kilo, Mega, Giga // 10^3, 10^6, 10^9  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>