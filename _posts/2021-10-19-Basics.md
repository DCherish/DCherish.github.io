---
layout: page
title:  "Basics"
subtitle: "Computer Science of Basics"
date:   2021-10-19 11:11:11 +0530
categories: ["CS"]
comments: true
---
## Memory Leak
👉 컴퓨터 프로그램이 필요하지 않은 메모리를 계쏙 점유하고 있는 현상  

<br>

## Dangling Pointer
👉 여전히 해제된 메모리 영역을 가리키고 있는 포인터  

<br>

## 디자인 패턴, 아키텍쳐 패턴
👉 개발을 진행하며 자주, 반복적으로, 공통적으로 문제를 발견하여 해결해야 되는 경우가 생기는데, 문제에 대해 재사용이 가능한 솔루션  

<br>

## MVC 패턴
👉 프로그램을 각각의 역할에 따라 Model, View, Controller로 나누어 설계한 아키텍쳐 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 Controller  
　　👉 데이터와 UI 요소를 잇는 역할, event 처리 역할  
👉 모든 입력은 Controller로 전달  
👉 Controller는 입력에 해당하는 Model 업데이트  
👉 Controller는 View를 선택만 할 뿐, 직접 업데이트하지 X  
👉 View를 업데이트  
　　👉 1. View가 Model을 직접 이용하여  
　　👉 2. Model에서 View에게 Notify  
　　👉 3. View가 Polling하여 Model 변화를 감지하여  
👉 View를 업데이트하기 위해 M-V 사이의 의존성이 존재  
👉 안드로이드는 Activity(or Fragment)가 Controller와 View 모두 처리하기 때문에, 한 클래스에서 M-V-C 모두 처리하는 문제점 발생  
👋 Controller : View = 1 : N, 하나의 C 여러 개의 V 관리 가능  
👋 View는 Controller를 알 수 X  
👉 가장 단순한 패턴  
👉 But, M-V 사이 의존성 // 앱이 커지고 복잡해질수록 유지보수가 어려움  

<br>

## MVP 패턴
👉 MVC에서 파생된, M과 V 간 의존성이 없는 아키텍쳐 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 Presenter  
　　👉 View에서 요청한 정보로 Model을 가공하여 View에 전달  
　　👉 View와 Model의 다리 역할  
👉 모든 입력은 View로 전달  
👉 Presenter는 입력에 해당하는 Model 업데이트  
👉 Model 업데이트 결과 기반으로 View 업데이트  
👉 Presenter는 해당 View를 참조  
👉 Presenter는 View와 Model 인스턴스를 가지고, Model과 View 사이의 다리 역할  
👉 Presenter가 M-V 사이 관리, MVC와는 다르게 M-V 사이 의존성이 X  
👋 Presenter : View = 1 : 1  
👉 But, 앱이 커지고 복잡해질수록 V-P 간 의존성이 강해지는 문제점이 발생  

<br>

## MVVM 패턴
👉 MVC에서 파생된, M과 V 간 의존성뿐만 아니라 C와 V 간 의존성도 고려하여 각 구성 요소가 독립적으로 작성되고 테스트될 수 있도록 설계한 아키텍쳐 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 ViewModel  
　　👉 View를 표현하기 위해 만든 View를 위한 Model  
　　👉 View를 나타내주기 위한 Model이자 View를 나타내기 위한 데이터  
👉 모든 입력은 View로 전달  
👉 ViewModel은 입력에 해당하는 Presentation Logic을 처리하여 View에 데이터 전달  
👉 ViewModel은 View를 참조하지 않기 때문에 독립적  
👉 따라서 View는 자신이 이용할 ViewModel을 선택해 바인딩하여 업데이트 받음  
👉 Model이 변경되면 해당하는 ViewModel을 이용하는 View가 자동으로 업데이트  
👉 ViewModel은 View를 나타내 주기 위한 Model이자, View의 Presentation Logic을 처리  
👋 ViewModel : View = 1 : N  
👉 MVP와 마찬가지로 M-V 사이 의존성 X, MVP처럼 V-VM이 1:1 관계가 아닌 독립적이기 때문에 의존성 X  

<br>

## MVI 패턴
👉 JS 생태계에서 탄생했으며 MVC에서 파생된, 능동적인 Controller 대신 Intent라고 불리는 Reactive 요소를 이용한 아키텍쳐 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
　　👉 App의 상태와 Business Logic 관리 
👉 View  
　　👉 UI 요소  
👉 Intent  
　　👉 상태를 변화시키려는 Action  
👉 Intent로 User로 부터 입력을 가져옴  
👉 Intent는 Model에서 처리해야 하는 동작을 제공  
👉 Model은 Intent로부터 동작을 가져옴  
👉 Model은 View에 표시할 새로운 모델을 생성  
👉 View는 Model로부터 새로운 모델을 가져와 표시  
👋 Android의 Intent와 다른 개념  
👉 Android에서 발생할 수 있는 여러 이슈들(화면 회전, Process death 등)로 인해 코드들이 복잡해지기 쉬운데, MVI는 단방향 데이터 흐름과 불변성으로 인해 예측 가능한 상태가 만들어지기 때문에 유지보수가 좀 더 용이함  
👉 RxJava와 같은 Observable 한 외부 라이브러리를 이용해야 함  

<br>

## Flux 패턴
👉 MVC 패턴의 양방향 데이터 흐름으로 인하여 버그가 꽤 많이 발생함  
👉 따라서, 단방향 데이터 흐름 Flux 도입  
👉 Action  
　　👉 type 속성과 일부 데이터가 있는 단순한 객체  
👉 Store  
　　👉 상태값을 저장하고 있는 저장소  
👉 Dispatcher  
　　👉 일종의 허브역할, Action의 type 속성을 읽어 Store에 등록된 콜백함수를 호출  
👉 View  
　　👉 Store가 변경된 상태를 알려주면 해당 부분만 리렌더링함  

<br>

## Singleton 패턴
👉 단 하나의 인스턴스를 생성하여 사용하는 디자인 패턴
👉 객체 지향 설계 원칙에 적합하지 X  
　　👉 자기 자신 클래스 안에 응집도는 높이고 타 클래스 간 결합도는 낮추는 원칙  
👉 Lifecycle 제어가 힘들고, 멀티 스레드 환경에서 여러 개의 객체가 생성되는 문제가 발생할 수 있음  

<br>

## Git 🆚 Github  
👉 Git  
　　👉 분산 버전 관리 시스템  
　　👉 프로젝트 파일의 변경 사항을 추적하는 시스템  
　　👉 개발자들은 이를 통해, 프로젝트 변경사항을 기록하고 특정 시점의 버전으로 언제든 돌아갈 수 있음  
👉 Github  
　　👉 Git을 사용하는 프로젝트를 위한 호스팅 플랫폼 or 서비스  
👋 repository : 프로젝트 저장소  
👋 commit : 프로젝트의 현재 상태를 나타내는 체크포인트, 즉, 현재상태를 커밋에 저장  

<br>

## daemon
👉 리눅스 시스템이 처음 가동될 때 실행되는 백그라운드 프로세스의 일종  
👋 a daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user  
👋 the process names of a daemon end with the letter d (ex. syslogd)  

<br>

## AJAX(Asynchronous Javascript And Xml)
👉 JavaScript 라이브러리 중 하나  
👉 전체 페이지를 새로 고치지 않고도 페이지의 일부 만을 위한 데이터를 로드하는 기법  
👉 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고 받는 기술  

<br>

## jQuery
👉 웹 사이트에서 JavaScript를 쉽게 활용할 수 있도록 도와주는 오픈소스 기반의 JS 라이브러리  

<br>

## JDK 🆚 SDK  
👉 JDK  
　　👉 자바 앱을 구축하기 위한 핵심 플랫폼 구성요소  
　　👉 개발자들이 JVM과 JRE에 의해 실행되고 구동될 수 있는 자바 프로그램을 생성할 수 있게 해주는 개발 도구 모음  
👉 SDK  
　　👉 특정 플랫폼을 대상으로 소프트웨어 응용 프로그램을 개발하는데 사용할 수 있도록 하는 개발 도구 모음  

<br>

## JRE 🆚 JVM  
👉 JRE  
　　👉 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있음  
　　👉 즉, JVM 실행 환경을 구현한 것  
👉 JVM  
　　👉 자바 소스 코드로부터 만들어지는 자바 바이너리 파일을 실행할 수 있도록 하는 가상 머신  

<br>

## TDD(Test Driven Development)
👉 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스  
👉 쉽게 말해, 개발함에 있어 테스트를 많이 고려하는 프로그램 개발 방법  

<br>

## PNG 🆚 JPG
👉 비트맵 방식  
　　👉 아주 작은 픽셀로 분해하고, 각 화소의 색상과 위치를 기록해 저장  
👉 PNG  
　　👉 비손실 압축방식, 원본이 훼손 되지 X  
　　👉 투명배경이 지원  
👉 JPG  
　　👉 손실 압축방식, 원본이 훼손  
　　👉 복잡한 풍경, 인물사진 저장에 적합  
　　　　👋 파일 크기가 매우 커질 수 있기 때문에  
　　👉 JPEG : 사람의 눈에 거슬리지 않을 정도로 원본을 훼손해 압축 효과를 극대화하는 알고리즘  
➕ GIF  
　　👉 손실 압축방식, 원본이 훼손  

<br>

## URI 🆚 URL
👉 URI(Uniform Resource Identifier)  
　　👉 네트워크 상에서 자원 위치를 알려주기 위한 규약  
　　👉 인터넷에서 요구되는 기본조건, 인터넷 프로토콜과 항상 붙어다님  
👉 URL(Uniform Resource Locator)  
　　👉 통합 자원 식별자로 인터넷에 있는 자원을 나타내는 유일한 주소  
👋 URI가 URL의 상위 개념  

<br>

## 에러 🆚 예외  
👉 에러  
　　👉 시스템에 미리 예측할 수 없던 비정상적인 상황이 생겼을 때 발생  
👉 예외  
　　👉 미리 예측하여 프로그램의 코드로 처리할 수 있는 예외적인 상황  

<br>

## Client 🆚 Server  
👉 두 개의 컴퓨터 프로그램 사이에 이루어지는 역할 관계 나타내는 것  
👉 Client  
　　👉 다른 프로그램에게 서비스를 요청하는 프로그램  
👉 Server  
　　👉 요청되는 정보를 처리하여 응답을 해주는 프로그램   

<br>

## HDD 🆚 SSD
👉 컴퓨터의 정보와 자료 등을 저장하고 읽을 수 있는 장치  
👉 HDD(Hard Disk Drive)  
　　👉 고속으로 디스크를 회전시켜 저장하는 방식  
👉 SSD(Solid State Drive)  
　　👉 메모리 반도체를 기반하여 저장하는 방식  
　　👉 HDD에 비해 압도적으로 속도가 빠름  

<br>

## ROM 🆚 RAM
👉 ROM(Read Only Memory)  
　　👉 컴퓨터를 구동하기 위한 기본적인 정보가 담겨있으며, 이 정보들을 기억하기 위해 다른 정보들은 기억하지 X  
　　👉 비휘발성 메모리  
👉 RAM(Random Access Memory)  
　　👉 컴퓨터가 빠른 액세스를 하기 위해 데이터를 단기간 저장하는 구성 요소  
　　👉 휘발성 메모리  


<br>

## Parameter 🆚 Argument  
👉 Parameter  
　　👉 함수를 정의에서 나열되는 변수 명  
　　👋 void solution(int a, int b)  
👉 Argument  
　　👉 함수가 호출할 때 함수의 파라미터로 전달된 실제 값  
　　👋 solution(7, 9) // 7, 9 ; argument  

<br>

## 동기 🆚 비동기  
👉 동기 방식  
　　👉 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식  
　　👉 호출한 함수가 호출되는 함수의 작업의 완료 후의 return을 기다리거나 return을 받더라도 작업 완료 여부를 호출한 함수 스스로 확인하며 신경씀  
　　👉 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어짐  
　　👉 설계가 매우 간단하고 직관적  
👉 비동기 방식  
　　👉 요청을 보내고 해당 동작 처리 여부와 상관없이 다음 요청이 동작하는 방식  
　　👉 호출되는 함수에게 callBack을 전달해서 작업이 완료되면 전달받은 callBack을 실행하고, 호출한 함수는 작업 완료 여부를 신경쓰지 X  
　　👉 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있음  
　　👉 동기 방식에 비해 설계가 복잡함  

<br>

## Blocking 🆚 Non-Blocking  
👉 Blocking  
　　👉 자신의 작업을 모두 마칠 때까지 제어권을 넘겨주지 않고 대기하게 만드는 방식  
👉 Non-Blocking  
　　👉 호출된 즉시 바로 return해서 호출한 함수에게 제어권을 넘겨주고 호출한 함수가 다른 일을 할 수 있는 기회를 주는 방식  

<br>

## API(Application Programming Interface)
👉 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스  

<br>

## Load Balancing
👉 둘 이상의 CPU or 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것  
👉 여러 서버에게 균등하게 트래픽을 분산시켜주는 것  
👉 클라이언트와 서버 사이에 Load Balancer를 두고 부하가 일어나지 않도록 함  
👋 Round Robin, Least Connection Method, IP Hash, etc  

<br>

## CPU 작동 원리
👉 연산장치  
　　👉 산술연산 및 논리연산 수행  
　　👉 연산에 필요한 데이터를 레지스터에서 가져오고, 결과를 다시 레지스터로 전송  
👉 제어장치  
　　👉 명령어를 순서대로 실행할 수 있도록 제어  
　　👉 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄  
👉 레지스터  
　　👉 고속 기억장치  
　　👉 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장  

<br>

## CPU 동작 과정
👉 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴  
👉 CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장  
👉 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄  
👉 제어장치는 1~3과정에서 명령어가 순서대로 실행되도록 각 장치를 제어  

<br>

## Garbage Collector
👉 **Garbage**를 청소해주는 JVM의 실행 엔진의 한 요소  
👉 Garbage Collector가 메모리를 정리하는 과정을 **Garbage Collection**  
👋 **Garbage** : 더 이상 참조되지 않는 메모리  

<br>

## Problem Thread with 전역변수
👉 서로 다른 Thread에서 동시에 같은 변수에 접근하면  
👋 4개의 Thread, 각각 전역변수 a에 +1, 2500000번 실행  
👋 a = 4 * 2500000 = 10000000을 예상  
👋 실제 결과, ex) a = 4827031  
👉 같은 변수를 동시에 접근했기 때문  
👉 CPU 연산 과정의 문제  
　　👉 1. a의 값을 메모리에서 레지스터로 불러옴  
　　👉 2. 레지스터에서 더함  
　　👉 3. 더한 값을 실제로 a가 있는 메모리에 저장  
👉 즉, 4개의 Thread가 거의 동시에 실행하려다 보면 3번째 과정이 끝나기 전에 다른 Thread가 a의 값을 메모리에서 레지스터로 불러올 수 있음  

<br>

## 자료형 크기 및 범위
👉 char / 1byte / -2^7 ~ 2^7-1  
👉 short / 2byte / -2^15 ~ 2^15-1  
👉 int / 4byte / -2^31 ~ 2^31-1  
👉 long(C++) / 4byte / -2^31 ~ 2^31-1  
👉 long long(C++) / 8byte / -2^63 ~ 2^63-1  
👉 long(Kotlin) / 8byte / -2^63 ~ 2^63-1  
👋 field : 부호 + 값  
👋 Kotlin에는 long long 없음  
👉 float / 4byte / 3.4E-38 ~ 3.4E+38  
👉 double / 8byte / 1.7E-308 ~ 1.7E+308    
👋 field : 부호 + 지수 + 가수  

<br>

## int 🆚 long (C++)
👉 int  
　　👉 4byte(32bit, 32bit)  
👉 long  
　　👉 4byte(32bit)  
　　👉 8byte(64bit)  
　　👉 4byte(windows, 64bit)  

<br>

## 컴퓨터 음수의 표현
👉 컴퓨터는 음수를 표현하기 위해서 2의 보수라는 개념을 사용  
　　👋 ex) -6  
　　👋 6(2) = 0000 0110  
　　👋 0000 0110 ➡️ 1111 1001 : 전부 뒤집고  
　　👋 1111 1001 ➡️ 1111 1010 : +1  
　　👋 -6(2) = 1111 1010  
👉 컴퓨터의 연산기에는 사실 덧셈 기능의 회로만 있음  
👉 따라서, 뺄셈 기능으로 덧셈으로 구현  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>