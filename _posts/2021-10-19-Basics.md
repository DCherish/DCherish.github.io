---
layout: page
title:  "Basics"
subtitle: "Computer Science of Basics"
date:   2021-10-19 11:11:11 +0530
categories: ["CS"]
comments: true
---
## 동기 🆚 비동기 ✔️
👉 동기 방식  
　　👉 요청을 보낸 후 응답을 받아야지만 다음 동작이 이루어지는 방식  
　　👋 호출한 함수가 호출되는 함수의 작업의 완료 후의 return을 기다리거나 return을 받더라도 작업 완료 여부를 호출한 함수 스스로 확인하며 신경씀  
　　👋 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어짐  
　　👋 설계가 매우 간단하고 직관적  
👉 비동기 방식  
　　👉 요청을 보낸 후 응답과 상관없이 다음 동작이 이루어지는 방식  
　　👋 여러가지 요청을 동시에 처리할 수 있어 자원을 효율적으로 사용할 수 있음  
　　👋 동기 방식에 비해 설계가 복잡함  
　　👋 호출되는 함수에게 callBack을 전달해서 작업이 완료되면 전달받은 callBack을 실행하고, 호출한 함수는 작업 완료 여부를 신경쓰지 X  

<br>

## Blocking 🆚 Non-Blocking ✔️
👉 Blocking  
　　👉 자신의 작업을 모두 마칠 때까지 제어권을 넘겨주지 않고 대기하게 만드는 방식  
👉 Non-Blocking  
　　👉 호출된 즉시 바로 return하여 호출한 함수에게 제어권을 넘겨주고 호출한 함수가 다른 일을 할 수 있는 기회를 주는 방식  

<br>

## 동기 & 비동기 🆚 Blocking & Non-Blocking
👉 관심사에 차이가 있음  
　　👉 동기 & 비동기  
　　　　👉 호출한 함수가 호출되는 함수의 작업 완료 여부를 누가 신경쓰는지  
　　　　　　👉 Yes : 동기, No : 비동기  
　　👉 Blocking & Non-Blocking  
　　　　👉 호출되는 함수가 즉시 제어권을 return을 하는지  
　　　　　　👉 Yes : Non-Blocking, No : Blocking  

<br>

## 병렬성은 아니지만 동시 수행성을 가지는 것이 가능한가?
👉 사용자가 인식하지 못할 정도로 빠르게 문맥 교환(context switching)을 수행하면 사용자는 프로그램이나 기능이 동시에 수행되는 것처럼 느끼기 때문에 병렬성은 아니지만 동시 수행성을 가지는 것이 가능  

<br>

## 아키텍처 패턴 🆚 디자인 패턴 ✔️
👉 아키텍처 패턴  
　　👉 주어진 문맥 안에서 소프트웨어 아키텍처의 공통적인 발생 문제에 대해 재사용 가능한 해결책  
👉 디자인 패턴  
　　👉 특정 문맥에서 소프트웨어 디자인의 공통적인 발생 문제에 대해 재사용 가능한 해결책  
👋 아키텍처 패턴이 조금 더 넓은 범위에 속함   

<br>

## MVC 패턴 ✔️
👉 프로그램을 각각의 역할에 따라 Model, View, Controller로 나누어 설계한 디자인 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 Controller  
　　👉 데이터와 UI 요소를 잇는 역할, event 처리 역할  
👉 모든 입력은 Controller로 전달  
👉 Controller는 입력에 해당하는 Model 업데이트  
👉 Controller는 View를 선택만 할 뿐, 직접 업데이트하지 X  
👉 View를 업데이트  
　　👉 1. View가 Model을 직접 이용하여  
　　👉 2. Model에서 View에게 Notify  
　　👉 3. View가 Polling하여 Model 변화를 감지하여  
👉 View를 업데이트하기 위해 M-V 사이의 의존성이 존재  
👉 안드로이드는 Activity(or Fragment)가 Controller와 View 모두 처리하기 때문에, 한 클래스에서 M-V-C 모두 처리하는 문제점 발생  
👋 Controller : View = 1 : N, 하나의 C 여러 개의 V 관리 가능  
👋 View는 Controller를 알 수 X  
👉 가장 단순한 패턴  
👉 But, M-V 사이 의존성 // 앱이 커지고 복잡해질수록 유지보수가 어려움  

<br>

## MVP 패턴 🔥
👉 MVC에서 파생된, M과 V 간 의존성이 없는 디자인 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 Presenter  
　　👉 View에서 요청한 정보로 Model을 가공하여 View에 전달  
　　👉 View와 Model의 다리 역할  
👉 모든 입력은 View로 전달  
👉 Presenter는 입력에 해당하는 Model 업데이트  
👉 Model 업데이트 결과 기반으로 View 업데이트  
👉 Presenter는 해당 View를 참조  
👉 Presenter는 View와 Model 인스턴스를 가지고, Model과 View 사이의 다리 역할  
👉 Presenter가 M-V 사이 관리, MVC와는 다르게 M-V 사이 의존성이 X  
👋 Presenter : View = 1 : 1  
👉 But, 앱이 커지고 복잡해질수록 V-P 간 의존성이 강해지는 문제점이 발생  

<br>

## MVVM 패턴 🔥
👉 MVC에서 파생된, M과 V 간 의존성뿐만 아니라 C와 V 간 의존성도 고려하여 각 구성 요소가 독립적으로 작성되고 테스트될 수 있도록 설계한 디자인 패턴  
👉 Model  
　　👉 App의 정보, 데이터(DB, 변수 등)  
👉 View  
　　👉 UI 요소  
👉 ViewModel  
　　👉 View를 표현하기 위해 만든 View를 위한 Model  
　　👉 View를 나타내주기 위한 Model이자 View를 나타내기 위한 데이터  
👉 모든 입력은 View로 전달  
👉 ViewModel은 입력에 해당하는 Presentation Logic을 처리하여 View에 데이터 전달  
👉 ViewModel은 View를 참조하지 않기 때문에 독립적  
👉 따라서 View는 자신이 이용할 ViewModel을 선택해 바인딩하여 업데이트 받음  
👉 Model이 변경되면 해당하는 ViewModel을 이용하는 View가 자동으로 업데이트  
👉 ViewModel은 View를 나타내 주기 위한 Model이자, View의 Presentation Logic을 처리  
👋 ViewModel : View = 1 : N  
👉 MVP와 마찬가지로 M-V 사이 의존성 X, MVP처럼 V-VM이 1:1 관계가 아닌 독립적이기 때문에 의존성 X  

<br>

## Singleton 패턴
👉 단 하나의 인스턴스를 생성하여 사용하는 디자인 패턴  
👉 데이터 공유가 쉬우며, 메모리 측면에서 여러 이점이 있음  
　　👉 미리 생성한 인스턴스를 이용하는 것이기에, 속도 측면에 이점이 있고, 메모리 낭비를 방지할 수 있음  
👉 멀티 스레드 환경에서 여러 개의 객체가 생성되는 문제가 발생할 수 있음  
👋 객체 지향 설계 원칙에 적합하지 X  
　　👋 자기 자신 클래스 안에 응집도는 높이고 타 클래스 간 결합도는 낮추는 원칙  

<br>

## Git 🆚 Github ✔️
👉 Git  
　　👉 분산 버전 관리 시스템  
　　👉 프로젝트 파일의 변경 사항을 추적하는 시스템  
　　👉 개발자들은 이를 통해, 프로젝트 변경사항을 기록하고 특정 시점의 버전으로 언제든 돌아갈 수 있음  
👉 Github  
　　👉 Git을 사용하는 프로젝트를 위한 호스팅 플랫폼 or 서비스  
👋 repository : 프로젝트 저장소  
👋 add : 커밋에 변경 사항을 추가  
👋 push : 원격 저장소로 커밋을 전송  
👋 pull : 원격 저장소의 변경 내용 가져오기  
👋 commit : 프로젝트의 현재 상태를 나타내는 체크포인트, 커밋을 생성  
👋 clone : 원격 저장소의 프로젝트를 로컬 저장소로 내려 받기  
👋 branch : 독립적인 작업을 위해 새로운 버전을 생성하는 것  

<br>

## Pull Request
👉 수정한 코드가 있으니, branch를 가져가 검토 후 병합해 줄 것을 요청하는 것  
👉 코드 충돌 최소화, push 권한이 없는 오픈 소스 프로젝트에 적합  
👉 fork, clone, branch, add/commit/push, PR, merge PR, 데이터 동기화 및 branch 삭제  

<br>

## daemon 🔥
👉 백그라운드에서 실행하면서 종료되지 않고 지속적으로 무엇인가 처리하는 프로그램  
✋ a daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user  
✋ the process names of a daemon end with the letter d (ex. syslogd)  

<br>

## TDD(Test Driven Development) ✔️
👉 매우 짧은 개발 사이클을 반복하는 소프트웨어 개발 프로세스  
👉 쉽게 말해, 개발함에 있어 테스트를 많이 고려하는 프로그램 개발 방법  

<br>

## CI/CD
👉 애플리케이션 개발 단계부터 배포 단계까지 모든 단계를 자동화를 통해서 고객들에게 좀 더 빠르게 효율적으로 제공하기 위한 방법  
👉 CI(Continuous Integration, 지속적 통합)  
　　👉 빌드 및 테스트 자동화  
　　👋 코드에 대한 통합을 지속적으로 진행함으로써 품질을 유지하자는 개념  
👉 CD(Continuous Deployment, 지속적 배포)  
　　👉 배포 자동화  
　　👋 소프트웨어가 항상 신뢰 가능한 수준에서 배포될 수 있도록 지속적으로 관리하자는 개념  
👋 Jenkins, Travice CI, Bamboo, etc  

<br>

## Unit Test
👉 응용 프로그램에서 실행 및 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트  

<br>

## Refactoring
👉 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법  
👋 소프트웨어를 보다 쉽게 이해할 수 있도록 만드는 작업  

<br>

## Agile Software Development
👉 신속한 반복 작업을 통하여 실행 가능한 소프트웨어를 개발해 이를 지속적으로 제공하기 위한 소프트웨어 개발 프로세스  

<br>

## URL 🆚 URI
👉 URL(Uniform Resource Locator)  
　　👉 네트워크 상에서 자원 위치를 알려주기 위한 규약  
👉 URI(Uniform Resource Identifier)  
　　👉 인터넷에 있는 자원을 나타내는 유일한 주소  
✋ URI가 URL의 상위 개념  

<br>

## 에러 🆚 예외
👉 에러  
　　👉 시스템에 미리 예측할 수 없던 비정상적인 상황이 생겼을 때 발생  
👉 예외  
　　👉 미리 예측하여 프로그램의 코드로 처리할 수 있는 예외적인 상황  

<br>

## Client 🆚 Server
👉 두 개의 컴퓨터 프로그램 사이에 이루어지는 역할 관계를 나타내는 용어  
👉 Client  
　　👉 다른 프로그램에게 서비스를 요청하는 프로그램  
👉 Server  
　　👉 요청을 처리하여 응답을 해주는 프로그램   

<br>

## Parameter 🆚 Argument
👉 Parameter  
　　👉 함수를 정의할 때 나열되는 변수 명  
　　✋ void solution(int a, int b)  
👉 Argument  
　　👉 함수 호출 시 함수의 파라미터로 전달된 실제 값  
　　✋ solution(7, 9) // 7, 9 ; argument  

<br>

## API(Application Programming Interface)
👉 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어하며 사용할 수 있게 해주는 인터페이스  

<br>

## Load Balancing
👉 둘 이상의 CPU or 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것  
👉 클라이언트와 서버 사이에 Load Balancer를 두어 부하가 일어나지 않도록 함  
✋ Round Robin, Least Connection Method, IP Hash, etc  

<br>

## Problem Thread with 전역변수
✋ 서로 다른 Thread에서 동시에 같은 변수에 접근하면  
✋ 4개의 Thread, 각각 전역변수 a에 +1, 2500000번 실행  
✋ a = 4 * 2500000 = 10000000을 예상  
✋ 실제 결과, ex) a = 4827031  
✋ Why?  
👉 같은 변수를 동시에 접근했기 때문  
👉 CPU 연산 과정의 문제  
　　👉 1. a의 값을 메모리에서 레지스터로 불러옴  
　　👉 2. 레지스터에서 더함  
　　👉 3. 더한 값을 실제로 a가 있는 메모리에 저장  
👉 즉, 4개의 Thread가 거의 동시에 실행하려다 보면 3번째 과정이 끝나기 전에 다른 Thread가 a의 값을 메모리에서 레지스터로 불러올 수 있음  

<br>

## ASCII Code 🆚 UniCode 🆚 UTF-8
👉 숫자로 문자를 표현하기 위한 일종의 약속된 코드  
👉 ASCII Code  
　　👉 1byte로 표현  
　　👉 1bit, parity bit  
　　👉 즉, 128(2^7)개의 문자 표현 가능  
👉 UniCode  
　　👉 2byte로 표현  
　　👉 즉, 65536(2^16)개의 문자 표현 가능  
　　👉 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드가 등장, But, 이 역시 부족  
👋 UTF-8  
　　👋 대표적인 유니코드 인코딩 방식  
　　　　👋 인코딩 방식이란, 컴퓨터가 어떤 글자를 만났을 때 얼만큼씩 읽어야 하는지 미리 말해주는 것  
　　👋 유니코드 한 문자를 나타내기 위해서 1byte에서 4byte까지 사용, 이를 가변 길이 인코딩 방식이라 함  
　　　　👋 가변적으로 인코딩하는 이유는, ASCII 문자들은 1byte로 문자를 표현할 수 있는데, 모든 문자를 4byte를 사용한다면 저장소의 낭비  
　　👋 따라서, ASCII Code로 표현 가능한 것들은 1byte로 표현, 그것이 안된다면 2바이트 이상을 사용하는데, 이때 이 방식이 UTF-8 방식  
　　👋 첫번째 바이트를 통해 몇 바이트를 읽을 지 구분  
　　　　👋 0xxxxxxx : 첫 번째 바이트가 0으로 시작한다면 0 이외의 나머지 7비트를 아스키로 인식  
　　　　👋 110xxxxx 10xxxxxx : 두번째 바이트까지 읽어서 11비트로 하나의 문자로 표현  
　　　　👋 1110xxxx 10xxxxxx 10xxxxxx : 세번째 바이트까지 읽어서 16비트로 하나의 문자로 표현  
　　　　👋 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx : 네번째 바이트까지 읽어서 21비트 하나의 문자로 표현  
👋 parity bit  
　　👉 통신 에러 탐지 비트  
　　👉 일곱 자리 중 1의 개수 홀수 개면 1, 아니면 0을 덧붙임  
　　👉 정밀하지는 않지만, 어느 정도 에러 탐지 가능  

<br>

## Memory Leak
👉 컴퓨터 프로그램이 더이상 필요하지 않은 메모리를 계속해서 점유하고 있는 현상  

<br>

## Dangling Pointer
👉 여전히 해제된 메모리 영역을 가리키고 있는 포인터  

<br>

## 일급 객체 특징
👉 변수에 담을 수 있음  
👉 인자로 전달 가능  
👉 반환 값에 사용 가능  

<br>

## 고차 함수
👉 다른 함수를 인자로 사용하거나, 결과 값으로 반환하는 함수  

<br>

## Garbage Collector(Java)
👉 Garbage를 청소해주는 JVM의 실행 엔진의 한 요소  
👉 Garbage Collector가 메모리를 정리하는 과정을 Garbage Collection  
👋 Garbage : 더 이상 참조되지 않는 메모리  
👋 [Link][Link1]  
👋 [Link2][Link2]  

<br>

## JDK 🆚 SDK
👉 JDK  
　　👉 Java로 소프트웨어를 개발할 수 있도록 여러 가지 기능들을 제공하는 개발 도구 모음  
👉 SDK  
　　👉 특정 플랫폼을 대상으로 소프트웨어를 개발할 수 있도록 여러 가지 기능들을 제공하는 개발 도구 모음  

<br>

## JRE 🆚 JVM
👉 JRE(J Runtime Env)  
　　👉 JVM 실행 환경을 구현한 것, 프로그램 동작에 필요한 라이브러리 파일들과 기타 파일들을 가지고 있음  
👉 JVM  
　　👉 자바 프로그램을 컴파일 해서 나온 바이트 코드(.class)를 실행시켜주는 가상 머신  
　　👉 메모리 등의 자원을 할당 및 관리하며 정보를 처리하는 작업을 함  

<br>

## 컴퓨터 음수의 표현 🔥
👉 컴퓨터는 음수를 표현하기 위해서 2의 보수라는 개념을 사용  
　　👋 ex) -6  
　　👋 6(2) = 0000 0110  
　　👋 0000 0110 ➡️ 1111 1001 : 전부 뒤집고  
　　👋 1111 1001 ➡️ 1111 1010 : +1  
　　👋 -6(2) = 1111 1010  
👉 컴퓨터의 연산기에는 사실 덧셈 기능의 회로만 있음  
👉 따라서, 뺄셈 기능으로 덧셈으로 구현  

<br>

## 자료형 크기 및 범위 🔥
👉 char / 1byte / -2^7 ~ 2^7-1  
👉 short / 2byte / -2^15 ~ 2^15-1  
👉 int / 4byte / -2^31 ~ 2^31-1  
👉 long(C++) / 4byte / -2^31 ~ 2^31-1  
👉 long long(C++) / 8byte / -2^63 ~ 2^63-1  
👉 long(Kotlin) / 8byte / -2^63 ~ 2^63-1  
👋 field : 부호 + 값  
👋 Kotlin에는 long long 없음  
👉 float / 4byte / 3.4E-38 ~ 3.4E+38  
👉 double / 8byte / 1.7E-308 ~ 1.7E+308    
👋 field : 부호 + 지수 + 가수  

<br>

## int 🆚 long (C++) 🔥
👉 int  
　　👉 4byte(32bit OS, 64bit OS)  
👉 long  
　　👉 4byte(32bit OS)  
　　👉 8byte(64bit OS)  
　　👉 4byte(windows, 64bit OS)  
👋 OS bit : Register 크기  

<br>

## float 🆚 double 🔥
👉 float  
　　👉 4byte, 유효자릿수 7자리  
👉 double  
　　👉 8byte, 유효자릿수 16자리  
👉 유효자릿수 : 몇 자리까지 오차없이 표현할 수 있는지  
👋 [Link][Link6]  

<br>

## 부동(浮動) 소수점 개념 🔥
👉 실수의 덧셈 및 곱셈 교환법칙 성립  
　　👋 a + b = b + a  
　　👋 a * b = b * a  
👉 실수의 덧셈 및 곱셉 결합법칙 성립 X  
　　👋 (a + b) + c ≠ a + (b + c)  
　　👋 (a * b) * c ≠ a * (b * c)  

<br>

## PNG 🆚 JPG 🔥
👉 이미지 파일 형식, 비트맵 방식 이용  
　　👋 아주 작은 픽셀로 분해하고, 각 화소의 색상과 위치를 기록해 저장  
👉 PNG  
　　👉 비손실 압축방식, 원본이 훼손 되지 X  
　　✋ 투명배경이 지원  
👉 JPG  
　　👉 손실 압축방식, 원본이 훼손  
　　✋ 복잡한 풍경, 인물사진 저장에 적합  
　　　　✋ 파일 크기가 매우 커질 수 있기 때문에  
　　👋 JPEG : 사람의 눈에 거슬리지 않을 정도로 원본을 훼손해 압축 효과를 극대화하는 알고리즘  
➕ GIF  
　　👉 압축률을 우선적으로 고려한 그림 파일 형식  
　　👉 손실 압축 방식, 원본이 훼손  

<br>

## HDD 🆚 SSD 🔥
👉 컴퓨터의 정보와 자료 등을 저장하고 읽을 수 있는 장치  
👉 HDD(Hard Disk Drive)  
　　👉 고속으로 디스크를 회전시켜 저장하는 방식  
👉 SSD(Solid State Drive)  
　　👉 메모리 반도체를 기반하여 저장하는 방식  
　　👉 HDD에 비해 압도적으로 속도가 빠름  

<br>

## ROM 🆚 RAM 🔥
👉 ROM(Read Only Memory)  
　　👉 컴퓨터를 구동하기 위한 기본적인 정보가 담겨있음  
　　👉 비휘발성 메모리  
👉 RAM(Random Access Memory)  
　　👉 컴퓨터가 빠른 액세스를 하기 위해 데이터를 단기간 저장하는 구성 요소  
　　👉 휘발성 메모리  

<br>

## CPU 작동 원리
👉 연산장치  
　　👉 산술연산 및 논리연산 수행  
　　👉 연산에 필요한 데이터를 레지스터에서 가져오고, 결과를 다시 레지스터로 전송  
👉 제어장치  
　　👉 명령어를 순서대로 실행할 수 있도록 제어  
　　👉 메인 메모리에서 프로그램 명령어를 꺼내 해독하고, 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄  
👉 레지스터  
　　👉 고속 기억장치  
　　👉 CPU 안에서 연산을 처리하기 위한 데이터를 일시적으로 저장하는 공간  

<br>

## CPU 동작 과정
👉 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴  
👉 CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장  
👉 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄  
👉 제어장치는 1~3과정에서 명령어가 순서대로 실행되도록 각 장치를 제어  

<br>

## CPU 실행시간 계산 관련 🔥
👉 프로그램 CPU 실행시간  
👉 = CPU 클럭 사이클 수 / 클럭 속도  
👋 = CPI * IC / 클럭 속도  
👋 = CPU 클럭 사이클 수 * 클럭 사이클 시간  
✋ 클럭 사이클 시간 = 1 / 클럭 속도  
　　👋 ex) 2GHz 컴퓨터 A 10초 수행 프로그램 -> B 6초 수행, A보다 1.2배 많은 클럭 사이클 필요할 때, B 클럭 속도?  
　　👋 A = 10 = A 클럭 사이클 수 / 2GHz  
　　👋 20 * 10^9 = A 클럭 사이클 수  
　　👋 B 클럭 속도 = 1.2 * 20 * 10^9 / 6 = 4 * 10^9 = 4GHz  
👋 Kilo, Mega, Giga // 10^3, 10^6, 10^9  

<br>

## Endian
👉 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법  
👉 Big Endian  
　　👉 큰 단위가 앞에 나오는 방법  
　　👋 0x1234 : 12 34  
👉 Little Endian  
　　👉 작은 단위가 앞에 나오는 방법  
　　👋 0x1234 : 34 12  

<br>

## CS 계산 문제 관련 🔥
👋 [Link][Link3]  
👋 [Link][Link4]  

<br>

## 여러 가지 웹 해킹기법 🔥
👋 [Link][Link5]  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>

[Link1]: https://mangkyu.tistory.com/94
[Link2]: https://lovestudycom.tistory.com/entry/%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-Garbage-collection
[Link3]: https://wonit.tistory.com/103?category=740633
[Link4]: https://wonit.tistory.com/104?category=740633
[Link5]: https://continuetochallenge.tistory.com/98
[Link6]: https://velog.io/@syleemk/CS-%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%98%A4%EC%B0%A8