---
layout: page
title:  "Others"
subtitle: "Computer Science of Others"
date:   2021-10-20 11:11:11 +0530
categories: ["CS"]
comments: true
---
# Kotlin

<br>

## fun
👉 함수 선언  
👋 fun main(){..}  

<br>

## Unit
👉 void 개념과 대응  
👋 특수한 객체를 반환  
👋 void는 아무 것도 반환하지 X  

<br>

## val 🆚 var
👉 val  
　　👉 불변형  
👉 var  
　　👉 가변형  
👉 자료형을 자동으로 추론  
👉 but, 반드시 값이 할당되어야 함  
👋 val c = 100 (O)  
👋 val num (X)  

<br>

## NPE(Java, Kotlin) ✔️
👉 자바에선 컴파일 타임에 null을 잡을 수 없고, 런타임에서 null을 잡아 NPE 발생  
👉 코틀린에선 컴파일 타임에 잡기 위해 다음과 같은 방법을 고안함  

<br>

## Kotlin null ✔️
👉 Kotlin 변수 기본적으로 non-null  
👋 NPE를 미리 방지할 수 있음  
👉 ? 기호를 명시하여 nullable  
👉 세이프 콜 (?.) : str?.length  
　　👉 null or str.length 출력  
👉 non-null 단정 (!!.) : str!!.length  
　　👉 NPE or str.length 출력  
👉 엘비스 연산자 (?:) : str?.length ?: -1  
　　👉 -1 or str.length 출력  

<br>

## Array 🆚 List
👉 Array  
　　👉 사이즈 변경 불가능  
　　👉 원소 직접 변경 가능  
　　👋 arr[0] = 5 (O)  
👉 List  
　　👉 읽기 전용, 사이즈 변경 가능  
　　👉 원소 직접 변경 불가능  
　　👋 arr[0] = 3 (X)  
　　👉 MutableList  
　　　　👉 사이즈 변경 가능  
　　　　👉 원소 직접 변경 가능  
　　　　👋 arr[0] = 1 (O)  
　　　　👋 ArrayList : MutableList  

<br>

## let()
👉 리시브 객체를 람다식 안으로  
👋 email?.let { println("${email.name}") }  

<br>

## 순수 함수
👉 어떤 함수에 같은 인자를 전달하여 항상 같은 결과를 출력할 경우 이를 **부작용 없는 함수**  
👉 부작용 없는 함수가 함수 외부에 아무 영향을 주지 않을 경우 이를 **순수 함수**  

<br>

## 람다식 ✔️
👉 **일급 객체** 특징을 가진 이름없는 함수  
👋 인자로 전달 가능  
👋 반환 값에 사용 가능  
👋 변수에 담을 수 있음  
👋 함수형 프로그래밍에서 자주 쓰임  
👋 val square : (Int) -> (Int) = {number -> number * number}  
👋 val square = {number: Int -> number * number}  
👉 코틀린 및 안드로이드에서 왜 중요할까?  
　　👉 편리하기 때문  
　　👉 method가 단 하나 뿐인 자바 인터페이스에 대해 람다식을 사용하여 코드를 간결하게 적용할 수 있음  

<br>

## 고차 함수
👉 다른 함수를 인자로 사용하거나 함수를 결과 값으로 반환하는 함수  

<br>

## Class init
👉 초기화 블록  
👉 주 생성자 생성시 같이 생성됨  

<br>

## 상속
👉 부모 클래스 앞 open 키워드를 붙임  
👉 자식 클래스는 동일  
👉 final을 해제하는 개념  
👋 code  
```kotlin
open class Human(val name: String = "Jordan") {
        // 주 생성자 및 default

        constructor(_name: String) {
                name = _name
        }
        // 부 생성자

        init {
                println("Hello")
        }
        // 초기화 블록

        open fun sing() {
                println("lalala")
        }
        // overriding 허용

        final fun dance() {
                println("yeyeye")
        }
        // overriding 불가
}

class Korean : Human() {
        override fun sing() {
                super.sing()
                // 부모 클래스
                println("라라라")
        }
        // overriding

        override fun sing() {
                println("라라라")
        }
        // Error
}
```  

<br>

## 지연 초기화
👉 프로퍼티 선언하면 기본적으로 모두 초기화함  
👉 but, 객체의 정보가 나중에 나타나는 경우와 객체 생성 동시에 초기화하기 힘든 경우에 사용  
👉 lateinit  
　　👉 var로 선언된 프로퍼티만 가능  
　　👉 프로퍼티 게터 및 세터 사용 불가  
👉 lazy  
　　👉 val로 선언된 프로퍼티만 가능  
　　👉 호출 시점에 by lazy { } 정의에 의해 블록부분 초기화 진행  

<br>

## 추상클래스 🆚 인터페이스 🆚 데이터클래스(kotlin) ✔️
👉 추상클래스  
　　👉 대략적인 설계 명세와 공통 기능을 구현한 클래스  
　　👉 하위 클래스에서 구체화할 필요가 있음  
　　👉 extends 키워드 사용, 다중 상속 구현 불가능  
👉 인터페이스  
　　👉 모든 메소드가 추상 메소드인 경우  
　　👉 뼈대만 있으며 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듬  
　　👉 implements 키워드 사용, 다중 상속 구현 가능  
👉 데이터클래스  
　　👉 데이터 저장에 초점을 맞추기 위해 코틀린에서 특별히 고안된 클래스  
　　👉 클래스 내용을 쉽게 확인 가능  

<br>

## Companion Object
👉 코틀린에서는 정적 변수를 사용할 때 static 키워드가 없는 대신 Companion Object를 제공함  

<br>

## Generic
👉 자료형을 일반화해 내부에서 그 자료형에 맞춰 교체하는 방법  

<br>

## 코루틴 ✔️
👉 동시성 프로그래밍을 가능케 하도록 하는 개념  
👉 Context Switching이 없고 최적화된 비동기 함수를 통해 비선점형으로 작동  
👉 Non-Blocking or 비동기 코드를 마치 동기 코드처럼 쉽게 작성이 가능  
👉 코틀린에서 기본으로 제공  
👉 라이브러리에 추가하여 사용  

<br>

## 코루틴 빌더 🔥
👉 launch  
　　👉 일단 실행하고 잊어버리는 형태의 코루틴으로 메인 프로그램과 독립되어 실행할 수 있음  
　　👉 기본적으로 즉시 실행하며 블록 내의 실행 결과는 반환하지 X  
👉 async  
　　👉 비동기 호출을 위해 만든 코루틴으로 결과나 예외를 반환함  

<br>

## 코루틴 플로우 🔥
👉 다중 데이터를 순차적으로 방출하는 데이터 스트림을 위해 제공  

<br>
<br>

# Android

<br>

## View
👉 쉽게 말해, UI 구성 요소  

<br>

## Layout
👉 View 배치 방식  
　　👉 LinearLayout  
　　　　👉 한 방향으로 View를 쌓는 layout  
　　👉 ConstraintLayout  
　　　　👉 직접 View의 위치를 설정하는 layout  
　　👉 RelativeLayout  
　　　　👉 특정 View와의 상대적인 위치를 이용해 위치를 결정하는 layout  
　　👉 TableLayout  
　　　　👉 표나 엑셀 시트와 같은 형태로 화면을 구성하는 layout  
　　👉 FrameLayout  
　　　　👉 이 layout에 View를 넣으면 그 중 하나의 View만 화면에 표시  
👋 gravity : 정렬  

<br>

## dp 🆚 sp
👉 dp  
　　👉 해당도에 따라 px 값 계싼  
👉 sp  
　　👉 글꼴 크기, 단말의 설정을 따름  

<br>

## margin 🆚 padding
👉 margin  
　　👉 View 영역 테두리 기준 바깥쪽 여백  
👉 padding  
　　👉 View 영역 테두리 기준 안쪽 여백  

<br>

## EditText inputType
👉 입력되는 글자의 유형 정의  
　　👉 키패드가 다르게 올라오는 것을 확인할 수 있음  

<br>

## 단말 방향 전환 ✔️
👉 onStop() ➡️ onDestroy() ➡️ onCreate() ➡️ onStart()  
👉 액티비티가 메모리에서 없어졌다가 다시 만들어짐  
👉 layout-land 폴더에 xml 파일을 새롭게 구성해야 함  
👉 onSaveInstanceState 콜백 메서드를 통해 변수 값을 저장  
👉 액티비티가 종료되기 전 상태를 저장  
👉 onCreate()에서 번들 객체로 복원  
👋 가로, 세로 액티비티가 다를 수 있기 때문  
👉 액티비티 동일, 화면 레이아웃만 바꾸고 싶다면?  
　　👉 매니페스트 파일의 <activity> 태그 안에 configChanges 속성에 orientation | screensize 설정  
　　👉 그 후 onConfiguration Changed() 메서드 재정의  

<br>

## 토스트 🆚 스낵바
👉 간단한 메시지를 잠깐 보여줬다가 없어지는 뷰  
👉 Toast  
　　👉 앱 위에 떠있는 뷰  
👉 SnackBar  
　　👉 아래쪽에서 올라왔다 내려가는 뷰  

<br>

## Inflation
👉 앱이 실행되어 xml 레이아웃 내용이 메모리에 객체화 되는 과정  
👋 객체화된 xml 레이아웃을 소스 파일에서 사용하여 출력함  

<br>

## TextWatcher
👉 EditText의 addTextChangedListener()메서드와 함께 Text 변경 Event 처리  

<br>

## 안드로이드 기본 구성요소 4가지 ✔️
👉 앱을 만들어 설치했을 때, 안드로이드 시스템이 이 요소에 대한 정보를 요구함  
👉 1. Activity  
　　👉 사용자에게 UI가 있는 화면을 제공하는 구성요소  
　　👉 액티비티 매니저라는 객체에 의해 액티비티 스택이라는 것으로 관리됨  
👉 2. Service  
　　👉 백그라운드에서 실행되는 앱의 구성 요소  
　　👉 메인 액티비티에서 startService() 메서드 호출  
　　👉 비정상적으로 종료되어도 시스템이 자동 재실행  
　　👉 stopService() 메서드를 호출하여 실행 서비스를 종료할 수 있음  
　　👉 카톡이 실행되어있지 않아도, 화면상에 보이지 않아도 메시지를 받을 수 있는 이유  
　　👋 IntentService : 백그라운드에서 실행되지만 한 번 실행되고 끝나는 작업  
👉 3. Broadcast Receiver  
　　👉 여러 앱 구성요소에 메시지를 전달할 때 사용하는 구성요소  
　　👉 기기안에서 동작하는 다른 앱 A로 부터 특정 메시지를 받기 위해 앱에 이 브로드캐스트 수신자를 등록하면 A 앱의 메시지가 앱으로 전달됨  
　　👉 registerReceiver() 메서드로 시스템에 등록  
👉 4. Content Provider  
　　👉 한 앱에서 관리하는 데이터를 다른 앱에서도 접근할 수 있도록 하는 구성요소  
　　👉 앱의 보안 때문에 중요한 구성요소  
　　👉 보통 DB, 파일, SharedPreferences를 접근  
　　👉 허용한 통로로 접근하기 위해서는 Content Resolver 객체를 이용해야 함  
👉 이 정보들은 전부 매니페스트 파일에 있음  

<br>

## 매니페스트 파일 ✔️
👉 4가지 기본 구성요소, 앱 패키지 이름, 권한 등의 정보가 들어있음  
👉 앱에 대한 필수적인 정보를 안드로이드 빌드 Tool과 스토어에 제공함  

<br>

## Flag
👉 중복 액티비티를 관리하기 위한 방법이자 기능  
👉 시스템은 인텐트 별로 새로운 액티비티를 띄우기 때문  
👉 SINGLE_TOP : 이미 액티비티가 생성 되어 있다면 그것을 그대로 사용  
👉 NO_HISTORY : 처음 이후에 실행된 액티비티는 스택에 추가되지 X  
👉 CLEAR_TOP : 액티비티 위에 있는 다른 액티비티를 모두 종류  

<br>

## Bundle
👉 인텐트 안에 있는 객체  
👉 부가 데이터를 넣거나 뺄 수 있음  

<br>

## Context
👉 현재 사용되고 있는 App에 대한 포괄적인 정보를 지니고 있는 객체  

<br>

## Intent
👉 앱 구성 요소 간에 작업 수행을 위한 정보 전달하는 역할  
👉 Action + Data  
👉 수행할 기능 + 수행할 대상 정보  

<br>

## Activity LifeCycle ✔️ 
👉 New  Run  
　　👉 사용자에게 UI가 있는 화면을 제공하는 구성요소  
　　👉 액티비티 매니저라는 객체에 의해 액티비티 스택이라는 것으로 관리됨  
👉 2. Service  
　　👉 백그라운드에서 실행되는 앱의 구성 요소  
　　👉 메인 액티비티에서 startService() 메서드 호출  
　　👉 비정상적으로 종료되어도 시스템이 자동 재실행  
　　👉 stopService() 메서드를 호출하여 실행 서비스를 종료할 수 있음  
　　👉 카톡이 실행되어있지 않아도, 화면상에 보이지 않아도 메시지를 받을 수 있는 이유  
　　👋 IntentService : 백그라운드에서 실행되지만 한 번 실행되고 끝나는 작업  
👉 3. Broadcast Receiver  
　　👉 여러 앱 구성요소에 메시지를 전달할 때 사용하는 구성요소  
　　👉 기기안에서 동작하는 다른 앱 A로 부터 특정 메시지를 받기 위해 앱에 이 브로드캐스트 수신자를 등록하면 A 앱의 메시지가 앱으로 전달됨  
　　👉 registerReceiver() 메서드로 시스템에 등록  
👉 4. Content Provider  
　　👉 한 앱에서 관리하는 데이터를 다른 앱에서도 접근할 수 있도록 하는 구성요소  
　　👉 앱의 보안 때문에 중요한 구성요소  
　　👉 보통 DB, 파일, SharedPreferences를 접근  
　　👉 허용한 통로로 접근하기 위해서는 Content Resolver 객체를 이용해야 함  
👉 이 정보들은 전부 매니페스트 파일에 있음  

<br>

## URI 🆚 URL
👉 URI(Uniform Resource Identifier)  
　　👉 네트워크 상에서 자원 위치를 알려주기 위한 규약  
　　👉 인터넷에서 요구되는 기본조건, 인터넷 프로토콜과 항상 붙어다님  
👉 URL(Uniform Resource Locator)  
　　👉 통합 자원 식별자로 인터넷에 있는 자원을 나타내는 유일한 주소  
👋 URI가 URL의 상위 개념  

<br>

## 에러 🆚 예외
👉 에러  
　　👉 시스템에 미리 예측할 수 없던 비정상적인 상황이 생겼을 때 발생  
👉 예외  
　　👉 미리 예측하여 프로그램의 코드로 처리할 수 있는 예외적인 상황  

<br>

## Client 🆚 Server
👉 두 개의 컴퓨터 프로그램 사이에 이루어지는 역할 관계 나타내는 것  
👉 Client  
　　👉 다른 프로그램에게 서비스를 요청하는 프로그램  
👉 Server  
　　👉 요청되는 정보를 처리하여 응답을 해주는 프로그램   

<br>

## HDD 🆚 SSD 🔥
👉 컴퓨터의 정보와 자료 등을 저장하고 읽을 수 있는 장치  
👉 HDD(Hard Disk Drive)  
　　👉 고속으로 디스크를 회전시켜 저장하는 방식  
👉 SSD(Solid State Drive)  
　　👉 메모리 반도체를 기반하여 저장하는 방식  
　　👉 HDD에 비해 압도적으로 속도가 빠름  

<br>

## ROM 🆚 RAM 🔥
👉 ROM(Read Only Memory)  
　　👉 컴퓨터를 구동하기 위한 기본적인 정보가 담겨있으며, 이 정보들을 기억하기 위해 다른 정보들은 기억하지 X  
　　👉 비휘발성 메모리  
👉 RAM(Random Access Memory)  
　　👉 컴퓨터가 빠른 액세스를 하기 위해 데이터를 단기간 저장하는 구성 요소  
　　👉 휘발성 메모리  


<br>

## Parameter 🆚 Argument
👉 Parameter  
　　👉 함수를 정의에서 나열되는 변수 명  
　　👋 void solution(int a, int b)  
👉 Argument  
　　👉 함수가 호출할 때 함수의 파라미터로 전달된 실제 값  
　　👋 solution(7, 9) // 7, 9 ; argument  

<br>

## 동기 🆚 비동기 ✔️
👉 동기 방식  
　　👉 요청을 보내고 실행이 끝나면 다음 동작을 처리하는 방식  
　　👉 호출한 함수가 호출되는 함수의 작업의 완료 후의 return을 기다리거나 return을 받더라도 작업 완료 여부를 호출한 함수 스스로 확인하며 신경씀  
　　👉 여러가지 요청을 동시에 처리할 수 없어 효율이 떨어짐  
　　👉 설계가 매우 간단하고 직관적  
👉 비동기 방식  
　　👉 요청을 보내고 해당 동작 처리 여부와 상관없이 다음 요청이 동작하는 방식  
　　👉 호출되는 함수에게 callBack을 전달해서 작업이 완료되면 전달받은 callBack을 실행하고, 호출한 함수는 작업 완료 여부를 신경쓰지 X  
　　👉 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 자원을 효율적으로 사용할 수 있음  
　　👉 동기 방식에 비해 설계가 복잡함  

<br>

## Blocking 🆚 Non-Blocking ✔️
👉 Blocking  
　　👉 자신의 작업을 모두 마칠 때까지 제어권을 넘겨주지 않고 대기하게 만드는 방식  
👉 Non-Blocking  
　　👉 호출된 즉시 바로 return해서 호출한 함수에게 제어권을 넘겨주고 호출한 함수가 다른 일을 할 수 있는 기회를 주는 방식  

<br>

## API(Application Programming Interface)
👉 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스  

<br>

## Load Balancing
👉 둘 이상의 CPU or 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것  
👉 여러 서버에게 균등하게 트래픽을 분산시켜주는 것  
👉 클라이언트와 서버 사이에 Load Balancer를 두고 부하가 일어나지 않도록 함  
👋 Round Robin, Least Connection Method, IP Hash, etc  

<br>

## CPU 작동 원리
👉 연산장치  
　　👉 산술연산 및 논리연산 수행  
　　👉 연산에 필요한 데이터를 레지스터에서 가져오고, 결과를 다시 레지스터로 전송  
👉 제어장치  
　　👉 명령어를 순서대로 실행할 수 있도록 제어  
　　👉 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄  
👉 레지스터  
　　👉 고속 기억장치  
　　👉 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장  

<br>

## CPU 동작 과정
👉 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴  
👉 CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장  
👉 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄  
👉 제어장치는 1~3과정에서 명령어가 순서대로 실행되도록 각 장치를 제어  

<br>

## Problem Thread with 전역변수
👉 서로 다른 Thread에서 동시에 같은 변수에 접근하면  
👋 4개의 Thread, 각각 전역변수 a에 +1, 2500000번 실행  
👋 a = 4 * 2500000 = 10000000을 예상  
👋 실제 결과, ex) a = 4827031  
👉 같은 변수를 동시에 접근했기 때문  
👉 CPU 연산 과정의 문제  
　　👉 1. a의 값을 메모리에서 레지스터로 불러옴  
　　👉 2. 레지스터에서 더함  
　　👉 3. 더한 값을 실제로 a가 있는 메모리에 저장  
👉 즉, 4개의 Thread가 거의 동시에 실행하려다 보면 3번째 과정이 끝나기 전에 다른 Thread가 a의 값을 메모리에서 레지스터로 불러올 수 있음  

<br>

## 자료형 크기 및 범위 🔥
👉 char / 1byte / -2^7 ~ 2^7-1  
👉 short / 2byte / -2^15 ~ 2^15-1  
👉 int / 4byte / -2^31 ~ 2^31-1  
👉 long(C++) / 4byte / -2^31 ~ 2^31-1  
👉 long long(C++) / 8byte / -2^63 ~ 2^63-1  
👉 long(Kotlin) / 8byte / -2^63 ~ 2^63-1  
👋 field : 부호 + 값  
👋 Kotlin에는 long long 없음  
👉 float / 4byte / 3.4E-38 ~ 3.4E+38  
👉 double / 8byte / 1.7E-308 ~ 1.7E+308    
👋 field : 부호 + 지수 + 가수  

<br>

## int 🆚 long (C++) 🔥
👉 int  
　　👉 4byte(32bit, 32bit)  
👉 long  
　　👉 4byte(32bit)  
　　👉 8byte(64bit)  
　　👉 4byte(windows, 64bit)  

<br>

## 컴퓨터 음수의 표현 🔥
👉 컴퓨터는 음수를 표현하기 위해서 2의 보수라는 개념을 사용  
　　👋 ex) -6  
　　👋 6(2) = 0000 0110  
　　👋 0000 0110 ➡️ 1111 1001 : 전부 뒤집고  
　　👋 1111 1001 ➡️ 1111 1010 : +1  
　　👋 -6(2) = 1111 1010  
👉 컴퓨터의 연산기에는 사실 덧셈 기능의 회로만 있음  
👉 따라서, 뺄셈 기능으로 덧셈으로 구현  

<br>

## ASCII Code 🆚 UniCode
👉 숫자로 문자를 표현하기 위한 일종의 약속된 코드  
👉 ASCII Code  
　　👉 1byte로 표현  
　　👉 마지막 1bit, **parity bit**  
　　👋 통신 에러 검출을 한 비트  
👉 UniCode  
　　👉 2byte로 표현  
　　👉 2byte로 표현  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>