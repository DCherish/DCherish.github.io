---
layout: page
title:  "Others"
subtitle: "Computer Science of Others"
date:   2021-10-20 11:11:11 +0530
categories: ["CS"]
comments: true
---
# 💛 Kotlin

<br>

## fun
👉 함수 선언  
✋ fun main(){..}  

<br>

## Unit
👉 void 개념과 대응  
👋 특수한 객체를 반환  
👋 void는 아무 것도 반환하지 X  

<br>

## val 🆚 var
👉 val  
　　👉 불변형  
👉 var  
　　👉 가변형  
👋 자료형을 자동으로 추론  
👋 but, 반드시 값이 할당되어야 함  
✋ val c = 100 (O)  
✋ val num (X)  

<br>

## NPE(Java, Kotlin) ✔️
👉 자바에선 컴파일 타임에 null을 잡을 수 없고, 런타임에서 null을 잡아 NPE 발생  
👉 코틀린에선 컴파일 타임에 잡기 위해 다음과 같은 방법을 고안함  

<br>

## Kotlin null ✔️
👉 Kotlin 변수 기본적으로 non-null  
👋 NPE를 미리 방지할 수 있음  
👉 ? 기호를 명시하여 nullable  
👉 세이프 콜 (?.) : str?.length  
　　👉 null or str.length 출력  
👉 non-null 단정 (!!.) : str!!.length  
　　👉 NPE or str.length 출력  
👉 엘비스 연산자 (?:) : str?.length ?: -1  
　　👉 -1 or str.length 출력  

<br>

## Array 🆚 List
👉 Array  
　　👉 사이즈 변경 불가능  
　　👉 원소 직접 변경 가능  
　　👋 arr[0] = 5 (O)  
👉 List  
　　👉 읽기 전용, 사이즈 변경 가능  
　　👉 원소 직접 변경 불가능  
　　👋 arr[0] = 3 (X)  
　　👉 MutableList  
　　　　👉 사이즈 변경 가능  
　　　　👉 원소 직접 변경 가능  
　　　　👋 arr[0] = 1 (O)  
　　　　👋 ArrayList : MutableList  

<br>

## let()
👉 리시브 객체를 람다식 안으로  
👋 email?.let { println("${email.name}") }  

<br>

## 순수 함수
👉 어떤 함수에 같은 인자를 전달하여 항상 같은 결과를 출력할 경우 이를 부작용 없는 함수  
👉 부작용 없는 함수가 함수 외부에 아무 영향을 주지 않을 경우 이를 순수 함수  

<br>

## 람다식 ✔️
👉 일급 객체 특징을 가진 이름없는 함수  
👋 인자로 전달 가능  
👋 반환 값에 사용 가능  
👋 변수에 담을 수 있음  
👋 함수형 프로그래밍에서 자주 쓰임  
👋 val square : (Int) -> (Int) = {number -> number * number}  
👋 val square = {number: Int -> number * number}  
👉 코틀린 및 안드로이드에서 왜 중요할까?  
　　👉 편리하기 때문  
　　👉 method가 단 하나 뿐인 자바 인터페이스에 대해 람다식을 사용하여 코드를 간결하게 적용할 수 있음  

<br>

## 고차 함수
👉 다른 함수를 인자로 사용하거나 함수를 결과 값으로 반환하는 함수  

<br>

## Class init
👉 초기화 블록  
👉 주 생성자 생성시 같이 생성됨  

<br>

## 상속
👉 부모 클래스 앞 open 키워드를 붙임  
👉 자식 클래스는 동일  
👉 final을 해제하는 개념  
👋 code  
```kotlin
open class Human(val name: String = "Jordan") {
        // 주 생성자 및 default

        constructor(_name: String) {
                name = _name
        }
        // 부 생성자

        init {
                println("Hello")
        }
        // 초기화 블록

        open fun sing() {
                println("lalala")
        }
        // overriding 허용

        final fun dance() {
                println("yeyeye")
        }
        // overriding 불가
}

class Korean : Human() {
        override fun sing() {
                super.sing()
                // 부모 클래스
                println("라라라")
        }
        // overriding

        override fun sing() {
                println("라라라")
        }
        // Error
}
```  

<br>

## 지연 초기화
👉 프로퍼티 선언하면 기본적으로 모두 초기화함  
👉 but, 객체의 정보가 나중에 나타나는 경우와 객체 생성 동시에 초기화하기 힘든 경우에 사용  
👉 lateinit  
　　👉 var로 선언된 프로퍼티만 가능  
　　👉 프로퍼티 게터 및 세터 사용 불가  
👉 lazy  
　　👉 val로 선언된 프로퍼티만 가능  
　　👉 호출 시점에 by lazy { } 정의에 의해 블록부분 초기화 진행  

<br>

## 추상클래스 🆚 인터페이스 🆚 데이터클래스(kotlin) ✔️
👉 추상클래스  
　　👉 대략적인 설계 명세와 공통 기능을 구현한 클래스  
　　👉 하위 클래스에서 구체화할 필요가 있음  
　　👉 extends 키워드 사용, 다중 상속 구현 불가능  
👉 인터페이스  
　　👉 모든 메소드가 추상 메소드인 경우  
　　👉 뼈대만 있으며 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듬  
　　👉 implements 키워드 사용, 다중 상속 구현 가능  
👉 데이터클래스  
　　👉 데이터 저장에 초점을 맞추기 위해 코틀린에서 특별히 고안된 클래스  
　　👉 클래스 내용을 쉽게 확인 가능  

<br>

## Companion Object
👉 코틀린에서는 정적 변수를 사용할 때 static 키워드가 없는 대신 Companion Object를 제공함  

<br>

## Generic
👉 자료형을 일반화해 내부에서 그 자료형에 맞춰 교체하는 방법  

<br>

## 코루틴 ✔️
👉 동시성 프로그래밍을 가능케 하도록 하는 개념  
👉 Context Switching이 없고 최적화된 비동기 함수를 통해 비선점형으로 작동  
👉 Non-Blocking or 비동기 코드를 마치 동기 코드처럼 쉽게 작성이 가능  
👉 코틀린에서 기본으로 제공  
👉 라이브러리에 추가하여 사용  

<br>

## 코루틴 빌더 🔥
👉 launch  
　　👉 일단 실행하고 잊어버리는 형태의 코루틴으로 메인 프로그램과 독립되어 실행할 수 있음  
　　👉 기본적으로 즉시 실행하며 블록 내의 실행 결과는 반환하지 X  
👉 async  
　　👉 비동기 호출을 위해 만든 코루틴으로 결과나 예외를 반환함  

<br>

## 코루틴 플로우 🔥
👉 다중 데이터를 순차적으로 방출하는 데이터 스트림을 위해 제공  

<br>
<br>

# 💛 Android

<br>

## View
👉 쉽게 말해, UI 구성 요소  

<br>

## Layout
👉 View 배치 방식  
　　👉 LinearLayout  
　　　　👉 한 방향으로 View를 쌓는 layout  
　　👉 ConstraintLayout  
　　　　👉 직접 View의 위치를 설정하는 layout  
　　👉 RelativeLayout  
　　　　👉 특정 View와의 상대적인 위치를 이용해 위치를 결정하는 layout  
　　👉 TableLayout  
　　　　👉 표나 엑셀 시트와 같은 형태로 화면을 구성하는 layout  
　　👉 FrameLayout  
　　　　👉 이 layout에 View를 넣으면 그 중 하나의 View만 화면에 표시  
👋 gravity : 정렬  

<br>

## dp 🆚 sp
👉 dp  
　　👉 해당도에 따라 px 값 계싼  
👉 sp  
　　👉 글꼴 크기, 단말의 설정을 따름  

<br>

## margin 🆚 padding
👉 margin  
　　👉 View 영역 테두리 기준 바깥쪽 여백  
👉 padding  
　　👉 View 영역 테두리 기준 안쪽 여백  

<br>

## EditText inputType
👉 입력되는 글자의 유형 정의  
　　👉 키패드가 다르게 올라오는 것을 확인할 수 있음  

<br>

## 단말 방향 전환 ✔️
👉 onStop() ➡️ onDestroy() ➡️ onCreate() ➡️ onStart()  
👉 액티비티가 메모리에서 없어졌다가 다시 만들어짐  
👉 layout-land 폴더에 xml 파일을 새롭게 구성해야 함  
👉 onSaveInstanceState 콜백 메서드를 통해 변수 값을 저장  
👉 액티비티가 종료되기 전 상태를 저장  
👉 onCreate()에서 번들 객체로 복원  
👋 가로, 세로 액티비티가 다를 수 있기 때문  
👉 액티비티 동일, 화면 레이아웃만 바꾸고 싶다면?  
　　👉 매니페스트 파일의 <activity> 태그 안에 configChanges 속성에 orientation | screensize 설정  
　　👉 그 후 onConfiguration Changed() 메서드 재정의  

<br>

## 토스트 🆚 스낵바
👉 간단한 메시지를 잠깐 보여줬다가 없어지는 뷰  
👉 Toast  
　　👉 앱 위에 떠있는 뷰  
👉 SnackBar  
　　👉 아래쪽에서 올라왔다 내려가는 뷰  

<br>

## Inflation ✔️
👉 앱이 실행되어 xml 레이아웃 내용이 메모리에 객체화 되는 과정  
👋 객체화된 xml 레이아웃을 소스 파일에서 사용하여 출력함  

<br>

## TextWatcher 🔥
👉 EditText의 addTextChangedListener()메서드와 함께 Text 변경 Event 처리  

<br>

## 안드로이드 기본 구성요소 4가지 ✔️
👉 앱을 만들어 설치했을 때, 안드로이드 시스템이 이 요소에 대한 정보를 요구함  
👉 1. Activity  
　　👉 사용자에게 UI가 있는 화면을 제공하는 구성요소  
　　👉 액티비티 매니저라는 객체에 의해 액티비티 스택이라는 것으로 관리됨  
👉 2. Service  
　　👉 백그라운드에서 실행되는 앱의 구성 요소  
　　👉 메인 액티비티에서 startService() 메서드 호출  
　　👉 비정상적으로 종료되어도 시스템이 자동 재실행  
　　👉 stopService() 메서드를 호출하여 실행 서비스를 종료할 수 있음  
　　👉 카톡이 실행되어있지 않아도, 화면상에 보이지 않아도 메시지를 받을 수 있는 이유  
　　👋 IntentService : 백그라운드에서 실행되지만 한 번 실행되고 끝나는 작업  
👉 3. Broadcast Receiver  
　　👉 여러 앱 구성요소에 메시지를 전달할 때 사용하는 구성요소  
　　👉 기기안에서 동작하는 다른 앱 A로 부터 특정 메시지를 받기 위해 앱에 이 브로드캐스트 수신자를 등록하면 A 앱의 메시지가 앱으로 전달됨  
　　👉 registerReceiver() 메서드로 시스템에 등록  
👉 4. Content Provider  
　　👉 한 앱에서 관리하는 데이터를 다른 앱에서도 접근할 수 있도록 하는 구성요소  
　　👉 앱의 보안 때문에 중요한 구성요소  
　　👉 보통 DB, 파일, SharedPreferences를 접근  
　　👉 허용한 통로로 접근하기 위해서는 Content Resolver라는 객체를 이용해야 함  
👉 이 정보들은 전부 매니페스트 파일에 있음  

<br>

## 매니페스트 파일 ✔️
👉 4가지 기본 구성요소, 앱 패키지 이름, 권한 등의 정보가 들어있음  
👉 앱에 대한 필수적인 정보를 안드로이드 빌드 Tool과 스토어에 제공함  

<br>

## Flag
👉 중복 액티비티를 관리하기 위한 방법이자 기능  
👉 시스템은 인텐트 별로 새로운 액티비티를 띄우기 때문  
👉 SINGLE_TOP : 이미 액티비티가 생성 되어 있다면 그것을 그대로 사용  
👉 NO_HISTORY : 처음 이후에 실행된 액티비티는 스택에 추가되지 X  
👉 CLEAR_TOP : 액티비티 위에 있는 다른 액티비티를 모두 종류  

<br>

## Bundle
👉 인텐트 안에 있는 객체  
👉 부가 데이터를 넣거나 뺄 수 있음  

<br>

## Context
👉 현재 사용되고 있는 App에 대한 포괄적인 정보를 지니고 있는 객체  

<br>

## Intent ✔️
👉 앱 구성 요소 간에 작업 수행을 위한 정보 전달하는 역할  
👉 Action + Data  
👉 수행할 기능 + 수행할 대상 정보  

<br>

## Activity LifeCycle ✔️
👉 앱이 생성, 일시정지, 재생, 정지, 재개, 종료되는 등의 상태 변화와 그에 따른 콜백 메서드를 총칭  
<br>
<img src="{{ '/assets/cs/cs_and_1.png' }}" style="width: 500px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 New ➡️ Run  
　　👉 onCreate() ➡️ onStart() ➡️ onResume()  
👉 Run ➡️ Pause  
　　👉 onPause()  
👉 Pause ➡️ Run  
　　👉 onResume()  
👉 Pause ➡️ Stop  
　　👉 onStop()  
👉 Stop ➡️ Run  
　　👉 onRestart() ➡️ onStart() ➡️ onResume()  
👉 Stop ➡️ End  
　　👉 onDestroy()  
<br>
👉 1. onCreate()  
　　👉 액티비티 처음 생성될 때 호출  
　　👉 이전에 저장된 정보가 있다면 번들을 참조하여 복원 가능  
👉 2. onStart()  
　　👉 액티비티가 화면에 보이기 직전에 호출됨  
　　👉 화면 상에 액티비티가 정상적으로 보인다면 onResume() 호출됨  
👉 3. onResume()  
　　👉 액티비티와 사용자가 상호작용하기 바로 직전에 호출됨  
👉 4. onRestart()  
　　👉 onStop() 이후 다시 시작되기 바로 직전에 호출됨  
👉 5. onPause()  
　　👉 또 다른 액티비티를 시작하려고 할 때 호출됨  
　　👉 이 메서드가 리턴하기 전에는 다음 액티비티는 시작될 수 없기에 매우 빨리 수행된 후 리턴되어야 함  
👉 6. onStop()  
　　👉 액티비티가 소멸되거나 또다른 액티비티가 화면을 가려 사용자에게 더 이상 보이지 않을 때 호출됨  
👉 7. onDestroy()  
　　👉 소멸되어 없어지기 전에 호출되며, 액티비티가 받는 마지막 호출이 됨  
👉 8. onSaveInstanceState()  
　　👉 파라미터로 전달되는 번들 객체를 이용하여 데이터를 저장  
　　👉 onPause() 전 호출됨  
👉 9. onRestoreInstanceState()  
　　👉 번들에 저장된 데이터를 이용하여 onCreate 혹은 이곳에서 복원  
　　👉 onCreate() 혹은 onStart()와 onResume() 사이에 호출  

<br>

## Fragment ✔️
👉 부분 화면을 위한 레이아웃  
👉 소스 코드를 한 번만 정의하여 재사용할 수 있도록 만든 레이아웃  
👉 코드가 복잡해지는 것을 방지하기 위해 각 부분 화면의 코드를 분리시킴  
👋 현재는 단순히 화면 UI를 위해 많이 활용하는 레이아웃  
👉 프래그먼트는 항상 액티비티 위에 올라가 있어야 함  
👉 제대로 동작하는 시점 : 프래그먼트가 메모리에 만들어진 시점 X, 액티비티에 올라가는 시점  
👉 프래그먼트 매니저가 프래그먼트들을 관리  
👉 인텐트는 시스템을 이해하는 방식이므로 프래그먼트와 액티비티 사이에서 전달하는 것은 바람직하지 않음  
👉 프래그먼트와 액티비티 간 데이터 전달은 단순히 메서드를 만들고 호출하는 방식으로 진행  
👉 액티비티에 추가하는 방법  
　　👉 뷰와 마찬가지로 xml 레이아웃에 <fragment> 태그 추가  
　　👉 소스 코드에서 new 연산자로 객체를 만들어 프래그먼트 매니저로 추가  
👉 프래그먼트를 전환하는 효과  
　　👉 프래그먼트 매니저를 이용하여 액티비티에서 전환을 처리  
　　👋 프래그먼트 관리를 액티비티에서 하기 때문  
👉 프래그먼트가 직접 프래그먼트를 띄우는 것이 X  
　　👉 액티비티를 통해 띄워야 함  

<br>

## Fragment LifeCycle ✔️
👉 프래그먼트가 액티비티에 올라가며 일어나는 상태 변화와 그에 따른 콜백 메서드를 총칭  
<br>
<img src="{{ '/assets/cs/cs_and_2.png' }}" style="width: 550px; height: auto; margin-left: auto; margin-right: auto; display: block;">  
👉 New ➡️ Run  
　　👉 onAttach() ➡️ onCreate() ➡️ onCreateView() ➡️ onActivityCreated() ➡️ onStart() ➡️ onResume()  
👉 Remove or Replace Fragment (not using Back stack)  
　　👉 onPause() ➡️ onStop() ➡️ onDestroyView() ➡️  onDestroy() ➡️ onDetach()  
👉 Remove or Replace Fragment (using Back stack)  
　　👉 onPause() ➡️ onStop() ➡️ onDestoryView()  
👉 Restore Fragment (using Back stack)  
　　👉 (onDestroyView ➡️) onCreateView() ➡️ onActivityCreated() ➡️ onStart() ➡️ onResume()  
<br>
👉 1. onAttach()  
　　👉 프래그먼트가 액티비티와 연결될 때 호출됨  
👉 2. onCreate()  
　　👉 프래그먼트가 초기화될 때 호출됨  
　　👉 new 연산자를 이용해 새로운 프래그먼트 객체를 만드는 시점이 X  
👉 3. onCreateView()  
　　👉 프래그먼트와 관련되는 뷰 계층을 만들어서 리턴함  
👉 4. onActivityCreated()  
　　👉 프래그먼트와 연결된 액티비티가 onCreate() 메서드의 작업을 완료했을 때 호출됨  
👉 5. onStart()  
　　👉 프래그먼트와 연결된 액티비티가 onStart() 되어 사용자에게 프래그먼트가 보일 때 호출됨  
👉 6. onResume()  
　　👉 프래그먼트와 연결된 액티비티가 onResume() 되어 사용자와 상호작용을 할 수 있을 때 호출됨  
👉 7. onPause()  
　　👉 프래그먼트와 연결된 액티비티가 onPause() 되어 사용자와 상호작용을 중지할 때 호출됨  
👉 8. onStop()  
　　👉 프래그먼트와 연결된 액티비티가 onStop() 되어 화면에 더 이상 보이지 않을 때 혹은 프래그먼트가 기능 중지될 때 호출됨  
👉 9. onDestroyView()  
　　👉 프래그먼트와 관련된 뷰 리소스를 해제할 수 있도록 호출됨  
👉 10. onDestroy()  
　　👉 프래그먼트의 상태를 마지막으로 정리할 수 있도록 호출됨  
👉 11. onDetach()  
　　👉 프래그먼트가 액티비티와 연결을 끊기 바로 직전에 호출됨  
👉 onPause()와 onStop() 메소드는 액티비티의 onPause()와 onStop() 메서드가 호출될 때와 같은 상태 메서드  
👋 Back stack : 프래그먼트가 화면에 보이지 않는 순간 제거가 아닌 저장했다 다시 이용할 수 있게 하는 기능  

<br>

## Permission
👉 일반 권한 + 위험 권한  
👉 위험 권한은 개인정보랑 연관이 되어 있으므로 항상 주의  

<br>

## Application 구성
👉 자바 코드 + 리소스 파일  
👉 자바 코드 : 앱의 흐름과 기능을 정의  
👉 리소스 파일 : 레이아웃/이미지 처럼 보여주기 위한 사용하는 파일 및 데이터 관리  

<br>

## Gradle ✔️
👉 앱을 실행하거나 스토어에 올릴 때 소스 파일이나 리소스 파일을 빌드하거나 배포하기 위해 사용되는 빌드 및 배포 도구  
👉 프로젝트 수준의 그래들 설정 파일  
　　👉 프로젝트 안에 들어 있는 모든 모듈에 적용되는 설정  
　　👋 일반적으로 이 파일은 거의 수정을 하지 않음  
👉 모듈 수준의 그래들 설정 파일  
　　👉 각각의 모듈에 대한 설정  
　　👉 빌드에 필요한 중요한 정보들이 있음  
　　👋 dependencies에는 외부 라이브러리 추가  
　　👋 새로운 모듈을 추가한다면, 그 모듈에 대한 build.gradle 파일로 새로 추가 됨  
👉 setting.gradle  
　　👉 어떤 모듈을 포함할 것인지에 대한 정보가 있음  

<br>

## Jetpack ✔️
👉 androidx라는 패키지명으로 시작하며, 개발자들이 쉽고 빠르고 퀄리티 좋은 앱을 만들수 있도록 도와주는 라이브러리  
👋 appcompat, recyclerview, viewpager2, drawerlayout, fragment  
👋 appcompat : 안드로이드 앱의 화면을 구성하는 액티비티를 만들며 API 레벨의 호환성 문제를 해결해 줌  
👋 viewpager2 : 옆으로 swipe하는 layout  
👋 drawerlayout : 안 보이다가 swipe하면 등장하는 layout  

<br>

## RecyclerView ✔️
👉 여러 가지 아이템을 나타내는 면에서 ListView와 비슷한 View  
👉 메모리를 효율적으로 사용하도록 캐시 매커니즘을 구현  
👋 ViewHolder, Adapter, LayoutManager // 뷰 객체, 항목 구성, 항목 배치  
👋 ListView 대신 사용하는 것을 권장  
　　👋 가로/세로 방향 모두 지원  
　　👋 아이템 애니메이션 처리 클래스 있음  
　　👋 ViewHolder 패턴을 사용하여 findViewById() 호출 횟수 낮음  

<br>

## SharedPreferences ✔️
👉 앱을 만들면서 데이터를 간단하게 저장하고 싶을 때 사용하는 기능  
👉 파일을 앱 내부에 하나 만들어 데이터를 저장하거나 읽어오는 방식  

<br>

## SQLite
👉 표준 SQL을 지원하며, 조회 속도가 빠른 모바일 데이터베이스  
👋 스키마를 업데이트할 때, SQLiteHelper 클래스 사용  

<br>

## Thread & Handler ✔️
👉 멀티 Thread를 이용할 경우 사용자가 만든 Thread가 UI 객체에 접근하기 위하여 Handler 객체를 이용  
👉 UI 관리하는 메인 스레드와 리소스 동시 접근으로 인한 DeadLock이 발생할 수 있으므로  

<br>

## Glide 🆚 Volley 🆚 Gson
👉 Glide  
　　👉 이미지 처리를 위해 만들어진 라이브러리  
👉 Volley  
　　👉 웹 요청과 응답을 단순화하기 위해 만들어진 라이브러리  
👉 Gson  
　　👉 Json 문자열을 자바 객체로 변환할 수 있도록 하는 라이브러리  

<br>

## Material Design 🔥
👉 구글이 안드로이드에 적용한 디자인 트렌드 중 하나  

<br>

## 알림 (배너)
👉 NotificationManager 시스템 서비스 사용  

## 푸시 서비스
👉 업데이트 메시지를 구글 클라우드 서버에서 구글 Play 스토어가 설치된 단말기로 보내주는 방식  
　　👉 1. 구글 클라우드 서버에 단말을 등록하고 서버로부터 등록 ID를 받음  
　　👉 2. 등록 ID는 메시지 전송 담당 애플리케이션 서버로 보낸 후 메시지를 기다림  
　　👉 3. 보내려는 메시지를 애플리케이션 서버에서 클라우드에 접속해 전송  
　　👉 4. 메시지가 대상 단말에 보내짐  

<br>
<br>

# 💛 Machine Learning & Deep Learning

<br>

## Machine Learning ✔️
👉 컴퓨터가 학습할 수 있도록 하는 알고리즘과 기술을 개발하는 AI의 한 분야  
👋 Linear Regression, Decision Tree, Random Forest, etc  

<br>

## Deep Learning ✔️
👉 머신러닝의 한 분야로, 여러 층을 가진 인공신경망을 이용한 머신러닝  
👋 DNN, CNN, RNN, LSTM, etc  

<br>

## Gradient Descent Algorithm ✔️
👉 cost를 최소화하는 알고리즘  
👋 cost : 예측 값과 결과 값의 차이 정도를 알려주는 값  
👋 Hypothesis : 훈련을 통해 예측한 방정식, 개념  

<br>

## Linear Regression
👉 어떤 변수에 다른 변수들이 주는 영향력을 선형적으로 분석하는 학습 기법  

<br>

## Decision Tree
👉 일련의 분류 규칙을 통해 데이터를 분류하는 학습 기법  
👉 overfitting 문제가 잘 발생함  
👋 overfitting : 학습 결과가 준비한 훈련 데이터에서는 정확하지만 일반적인 상황에 대해 정확도가 현저히 떨어지는 현상  

<br>

## Random Forest
👉 학습 과정에서 구성한 다수의 Decision Tree를 이용하는 학습 기법  

<br>

## Adaboost
👉 약한 분류기들이 상호 보완하도록 단계적으로, adaptive하게 학습함  
👋 boost : 성능이 낮은 약한 분류기를 조합하여 강한 분류기를 만드는 방법  

<br>

## Clustering
👉 주어진 개체들을 속성값, 특성을 고려해 유사한 개체끼리 그룹화하는 것  

<br>

## Regression 🆚 Classfication
👉 Regression  
　　👉 연속적인 값을 예측  
👉 Classfication  
　　👉 이산적인 값을 예측  

<br>

## Softmax Regression
👉 다중 클래스 분류 문제를 해결하는 학습 기법  
👋 다중 클래스 분류 문제 : 3개 이상 선택지 중 하나를 택하는 문제  

<br>

## Feed Forwarding
👉 신경망에서 Input Layer에서 Hidden, Output layer를 거쳐 출력되는 과정  

<br>

## Backpropagation ✔️
👉 Output layer에서부터 역방향으로 편미분을 수행해가며 weight, bias를 갱신하는 것  

<br>

## Dropout
👉 overfitting을 방지하기 위하여 일부 데이터를 학습 데이터에 포함하지 않는 것  

<br>

## Regularization
👉 overfitting을 방지하기 위하여 weight를 handling 하는 것  

<br>

## DNN(Deep Neural Network) ✔️
👉 사람의 신경망 원리와 구조를 모방하여 만든 머신러닝 알고리즘  
👉 Hidden layer를 2개 이상으로 많이 구성하여 학습 결과를 향상시킴  
👋 분류 및 수치예측에 강점이 있음  

<br>

## CNN(Convolutional Neural Network) ✔️
👉 DNN을 응용하여 데이터의 특징을 추출하여 특징들의 패턴을 파악하는 머신러닝 알고리즘  
👋 Convolution : 데이터 각 성분의 인접 특성을 고려하여 하나의 특징으로 도출하는 과정  
👋 Pooling : Convolution 과정을 거친 layer의 사이즈를 줄이는 과정  
👋 이미지 처리 작업에 강점이 있음  

<br>

## RNN(Recurrent Neural Network) ✔️
👉 반복적이고 순차적인 데이터 학습에 특화된 머신러닝 알고리즘  
👉 이전 정보를 현재 문제 해결에 있어 활용할 수 있음  
👉 내부에 순환 구조가 포함되어 있기 때문  
👋 자연어 처리 분야에 강점이 있음  
👋 LSTM  

<br>

## LSTM(Long Short Term Memory)
👉 RNN의 Gradient Vanishing Problem을 극복하기 위해 Hidden layer에 logic을 추가적으로 구현한 머신러닝 알고리즘  
👋 GVP : backpropagation 과정에서 gradient 값이 소실되어 제대로 학습이 되지 않는 문제  
✋ Tanh를 미분한 값이 1보다 작기 때문에 곱하다 보면 값이 소실됨  

<br>

## Q-Learning
👉 모델없이 학습하는 강화 학습 기법  
👋 강화 학습 : 시행착오를 통해 학습하는 방법  
👋 어떤 state에 대하여 action에 따라 reward가 주어지는데, 이 reward를 최대화하기 위한 방향으로 학습이 진행됨  

<br>

## DQN(Deep Q-Learning)
👉 심층신경망을 이용하는 Q-Learning  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>