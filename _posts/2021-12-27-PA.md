---
layout: page
title:  "PA"
subtitle: "To Improve Myself In PA"
date:   2021-12-27 11:11:11 +0530
categories: ["Field"]
comments: true
---
## override
👉 하위 클래스의 가상함수 뒤에 키워드를 붙임  
👉 이 가상함수가 상속받아 오버라이딩한 함수임을 의미  

<br>

## final
👉 하위 클래스의 가상함수 뒤에 키워드를 붙임  
👉 가상함수의 마지막을 가르킴을 의미  

<br>

## constexpr
👉 객체나 함수 앞에 키워드를 붙임  
👉 해당 객체나 함수의 리턴값을 컴파일 타임에 값을 알 수 있음을 의미    
👉 const, 컴파일러에 따라 런타임 혹은 컴파일에 초기화를 할 지 결정 가능  
👉 constexpr, 컴파일 타임에 상수를 확실히 사용하고 싶을 때 사용  

<br>

## explicit
👉 자신이 원하지 않은 형변환이 일어나지 않도록 제한하는 키워드  
👋 [Link][Link1]  

<br>

## enum 🆚 enum class
👉 enum은 스코프를 제공하지 않음  
　　👉 int형으로 암묵적 변환  
　　👉 접근하기 쉽기 때문에, 같은 이름이 있다면 충돌  
　　👉 전방 선언 불가능  
👉 eum class는 스코프를 제공함  
　　👉 int형으로 암묵적 변환 X. But, static_cast 가능  
　　👉 전방 선언 가능  

<br>

## noexcept
👉 함수 선언시 그 함수가 예외를 던질 것인지 여부를 명시적으로 표기하고 싶을 때 사용하는 키워드  
　　👉 인터페이스의 측면에서 사용자는 예외 상황을 고려하지 않고 사용할 수 있음  
　　👉 또한, 컴파일러가 스택 풀기를 위한 스택을 확보할 필요가 없어 최적화의 여지가 있음  

<br>

## singleton
👉 전역 변수를 사용 X, 객체를 단 하나만 생성하도록 하여 생성한 객체를 어디서든 참조할 수 있도록 하는 패턴  
👉 고정된 메모리 영역을 얻으면서 한 번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지  
👉 싱글톤 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움  
👉 하지만, 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 수정 및 테스트가 어려워짐  
👉 또한, 멀티 스레드 환경에서 동기화 처리를 안하면 인스턴스가 두 개가 생성되는 경우도 발생 가능  

<br>

## static_assert
👉 컴파일 타임에 assertion을 진행  
👉 상수 표현식이 true일 경우 nothing, false일 경우 literal string을 표시  
👋 static_assert(sizeof(Command) == sizeof(a.cmd) + sizeof(a.len), "Command size is different");  
👉 런타임 도중 발생하는 오류는 발생 상황까지 플그램을 진행해야 하며, 조건을 만족시키기 어려운 경우도 존재할 수 있음  
👉 그렇기 때문에 런타임 도중 발생하는 오류보다 컴파일 타임에 발생하는 오류가 발견하기도, 개선시키기도 당연히 쉬움  

<br>

## virtual function table
👉 클래스에 가상 함수가 존재한다면 가상 함수 테이블이 생성됨  
👋 [Link][Link2]  

<br>

## unique_ptr 🆚 shared_ptr
👉 포인터 객체를 생성    
👉 unique_ptr은 유일 접근만 허용, 복사 생성자 delete, 소유권 이전은 가능(std::move)  
👉 shared_ptr은 따로 제한 X  
👋 [Link1][Link3]  
👋 [Link2][Link4]  

<br>

## reserve() 🆚 resize() // STL method
👉 reserve(), 메모리 크기 할당만 (capicity 변화 O, size 변화 X)  
👉 resize(), 메모리 크기 할당 및 초기화 (capicity 변화 O, size 변화 O)  

<br>

## 얕은 복사 🆚 깊은 복사
👉 메모리 주소만을 복사, 대상체 1개에 접근 포인터가 2개(소멸자 error 발생 가능)  
👉 리소스 자체를 복사(새로운 메모리를 할당), 대상체 2개에 접근 포인터가 2개  

<br>

## template
👋 [Link][Link5]  

<br>

## debug 🆚 release
👉 debug, 디버깅에 적합한 빌드  
👉 release, 배포에 적합한 빌드  
👋 [Link][Link6]  

<br>

## parsing
👉 일정한 문법을 토대로 나열된 data들을 그 문법에 맞게 분석하여 새롭게 구성하는 작업  

<br>

## .h & .cpp why seperate?
👉 모든 코드를 한 파일에 작성한다면 매우 길어져 알아보기 힘들어지기 때문  
👉 또한, 다른 곳에서 코드를 재사용할 것이라고 생각되는 경우가 존재하기 때문  

<br>

## using 🆚 typedef
👉 using은 타입을 별칭, 선언  
👉 typedef은 타입을 짧게 축약하여 사용  
👉 using을 사용하는 것이 권장, template 별칭 직접 지원 및 코드 가독성 향상에 이점  

<br>

## -
👉 -  

<br>
<br>

<script src="https://utteranc.es/client.js"
        repo="DCherish/DCherish.github.io"
        issue-term="pathname"
        theme="boxy-light"
        crossorigin="anonymous"
        async>
</script>

[Link1]: https://dydtjr1128.github.io/cpp/2019/07/13/Cpp-explicit-keyowrd.html
[Link2]: https://musket-ade.tistory.com/entry/C-%EA%B0%80%EC%83%81%ED%95%A8%EC%88%98-%ED%85%8C%EC%9D%B4%EB%B8%94-V-Table
[Link3]: https://modoocode.com/229
[Link4]: https://modoocode.com/252
[Link5]: https://modoocode.com/219
[Link6]: https://itisguide.tistory.com/4
